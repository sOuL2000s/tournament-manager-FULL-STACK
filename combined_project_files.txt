
--- START FILE: .gitignore ---

# ‚öôÔ∏è Node.js
node_modules/
dist/
.vite/
.env

# ‚öôÔ∏è Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ‚öôÔ∏è IDEs and editors
.vscode/
.idea/
*.sublime-project
*.sublime-workspace

# ‚öôÔ∏è System files
.DS_Store
Thumbs.db

# ‚öôÔ∏è Firebase emulators & CLI cache (if using locally)
.firebase/
.firebaserc
.firebase-debug.log


--- END FILE: .gitignore ---

--- START FILE: combined.py ---

import os

def combine_files_to_single_file(root_dir, output_filename="combined_project_files.txt"):
    """
    Combines the content of all files in a directory into a single file,
    excluding 'node_modules' directories and 'package-lock.json' files.

    Args:
        root_dir (str): The root directory of the project.
        output_filename (str): The name of the output file.
    """
    combined_content = []
    excluded_dirs = ['node_modules', '.git', '.vscode', '.idea', 'dist', 'build']
    excluded_files = ['package-lock.json', 'yarn.lock', 'bun.lockb', '.env'] # Added .env as it might contain sensitive info

    print(f"Starting to combine files from: {root_dir}")
    print(f"Excluding directories: {excluded_dirs}")
    print(f"Excluding files: {excluded_files}")

    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Modify dirnames in-place to skip excluded directories
        dirnames[:] = [d for d in dirnames if d not in excluded_dirs]

        for filename in filenames:
            if filename in excluded_files:
                print(f"Skipping excluded file: {os.path.join(dirpath, filename)}")
                continue

            file_path = os.path.join(dirpath, filename)
            # Make path relative to root_dir for the header
            relative_file_path = os.path.relpath(file_path, root_dir)

            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                combined_content.append(f"\n--- START FILE: {relative_file_path} ---\n\n")
                combined_content.append(content)
                combined_content.append(f"\n\n--- END FILE: {relative_file_path} ---\n")
                print(f"Included file: {relative_file_path}")
            except UnicodeDecodeError:
                print(f"Skipping binary or undecodable file (UnicodeDecodeError): {relative_file_path}")
            except Exception as e:
                print(f"Error reading file {relative_file_path}: {e}")

    output_path = os.path.join(root_dir, output_filename)
    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("".join(combined_content))
        print(f"\nSuccessfully combined all files into: {output_path}")
    except Exception as e:
        print(f"Error writing output file {output_path}: {e}")

if __name__ == "__main__":
    # Get the current working directory where the script is run
    # This assumes you run the script from your project's root directory
    project_root = os.getcwd()
    combine_files_to_single_file(project_root)


--- END FILE: combined.py ---

--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#1f2937" /> <!-- Defines a theme color for the browser UI, useful for mobile browsers -->
    <title>Tournament Manager</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <!-- Link to the favicon for the browser tab -->
    
    <!-- Preconnect to Google Fonts domains for improved loading performance of fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Link to the 'Inter' font from Google Fonts. Loads weights 400, 500, 600, 700. -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <!-- 
    Apply base Tailwind CSS classes for background and text colors.
    'bg-gray-100' and 'text-gray-900' for light mode.
    'dark:bg-gray-900' and 'dark:text-white' for dark mode (controlled by 'dark' class on html element via JavaScript).
    'font-inter' class ensures the 'Inter' font is used throughout the body.
  -->
  <body class="bg-gray-100 text-gray-900 dark:bg-gray-900 dark:text-white font-inter">
    <div id="root"></div> <!-- This is the root element where your React application will be mounted by main.jsx -->
    <script type="module" src="/src/main.jsx"></script> <!-- This script tag is the entry point for your client-side React application -->
  </body>
</html>


--- END FILE: index.html ---

--- START FILE: package.json ---

{
  "name": "tournament-manager",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "chart.js": "^4.5.0",
    "firebase": "^10.12.0",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.1.0",
    "autoprefixer": "^10.4.19",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.1",
    "vite": "^5.2.8"
  }
}


--- END FILE: package.json ---

--- START FILE: postcss.config.js ---

// ‚úÖ postcss.config.js (CommonJS)
module.exports = {
  plugins: {
    tailwindcss: {}, // Plugin for processing Tailwind CSS
    autoprefixer: {}, // Plugin for adding vendor prefixes to CSS rules
  },
};


--- END FILE: postcss.config.js ---

--- START FILE: README.md ---

check out the website here: https://tournament-manager-website.netlify.app/


--- END FILE: README.md ---

--- START FILE: tailwind.config.js ---

/** @type {import('tailwindcss').Config} */
export default {
  // Configure files to scan for Tailwind classes.
  // These paths tell Tailwind CSS where to look for class names
  // to generate the final CSS bundle, optimizing its size.
  content: [
    "./index.html", // Include the main HTML file where global classes might be used.
    "./src/**/*.{js,ts,jsx,tsx}", // Include all JavaScript, TypeScript, and React files in the 'src' directory.
  ],

  // Enable dark mode based on the presence of a 'dark' class on the HTML element.
  // This allows you to toggle dark/light themes by adding/removing 'dark' class via JavaScript.
  darkMode: "class", // üåô Enable dark mode via class

  theme: {
    // Extend the default Tailwind CSS theme.
    // This allows you to add custom configurations without overriding Tailwind's defaults.
    extend: {
      // Define a custom color palette.
      // These colors can then be used as Tailwind classes (e.g., `bg-primary`, `text-secondary`).
      colors: {
        primary: "#1d4ed8",   // A shade of blue (e.g., for primary buttons, links) - corresponds to blue-700
        secondary: "#9333ea", // A shade of purple (e.g., for accents or secondary actions) - corresponds to purple-600
      },
      fontFamily: { // Define custom font family.
        // Add 'Inter' font, which should be imported from Google Fonts in index.html.
        // This allows you to use `font-inter` class in your components.
        inter: ['Inter', 'sans-serif'],
      },
    },
  },

  // Add any Tailwind CSS plugins here.
  // Plugins extend Tailwind's capabilities with new utilities or components.
  plugins: [],
};


--- END FILE: tailwind.config.js ---

--- START FILE: vite.config.js ---

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react'; // Vite plugin for React applications

export default defineConfig({
  // Define plugins for Vite. Plugins extend Vite's capabilities.
  // The 'react()' plugin is essential for React support, enabling JSX transformation, HMR, etc.
  plugins: [react()],

  // Configure the development server.
  server: {
    port: 5173 // Specify the port number on which the development server will run.
              // If this port is already in use, Vite will automatically try the next available port.
  },

  // Build configuration (optional, currently commented out in the provided code).
  // This section would define how Vite builds your application for production.
  // build: {
  //   sourcemap: true, // Enabling sourcemaps is useful for debugging production builds.
  // },

  // Further configurations could include:
  // - `resolve.alias`: For setting up path aliases (e.g., '@components' to 'src/components').
  // - `css.postcss`: If custom PostCSS processing is needed beyond the default setup.
  // - `optimizeDeps`: For fine-tuning dependency pre-bundling.
});


--- END FILE: vite.config.js ---

--- START FILE: src\App.jsx ---

import React, { useEffect, useState } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom'; // Removed Link as it's not used here

// Import Page Components
import Dashboard from './pages/Dashboard';
import TournamentPage from './pages/TournamentPage';
import FixturesPage from './pages/FixturesPage';
import LeaderboardPage from './pages/LeaderboardPage';
import AuthPage from './pages/AuthPage'; // Authentications page (login/signup)
import KnockoutPage from './pages/KnockoutPage';
import AIPredictionPage from './pages/AIPredictionPage';
import StatsPage from './pages/StatsPage';
import PlayerPage from './pages/PlayerPage';

// Import Reusable Components
import Header from './components/Header';
import ProtectedRoute from './components/ProtectedRoute'; // Component to protect routes requiring authentication

// Import Custom Hooks
import { useAuth } from './hooks/useAuth'; // Custom hook for authentication state management

export default function App() {
  // Destructure user, loading state, and logout function from the useAuth hook
  const { user, loading, logout } = useAuth();

  // State for dark mode preference, initialized from localStorage
  const [darkMode, setDarkMode] = useState(() => localStorage.getItem('dark') === 'true');

  // State for language preference, initialized from localStorage, defaults to 'en'
  const [lang, setLang] = useState(() => localStorage.getItem('lang') || 'en');

  // useEffect to apply or remove the 'dark' class from the HTML document element
  // and persist the preference in localStorage whenever darkMode state changes.
  useEffect(() => {
    if (darkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
    localStorage.setItem('dark', darkMode); // Persist dark mode setting
  }, [darkMode]);

  // useEffect to persist the language preference in localStorage whenever lang state changes.
  useEffect(() => {
    localStorage.setItem('lang', lang);
  }, [lang]);

  // Translations object for Internationalization (i18n)
  // Provides different language strings for UI elements.
  const translations = {
    en: { // English translations
      title: 'Tournament Manager',
      logout: 'Logout',
      light: 'Light Mode',
      dark: 'Dark Mode',
      dashboard: 'Dashboard',
    },
    hi: { // Hindi translations
      title: '‡§ü‡•Ç‡§∞‡•ç‡§®‡§æ‡§Æ‡•á‡§Ç‡§ü ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§®',
      logout: '‡§≤‡•â‡§ó ‡§Ü‡§â‡§ü',
      light: '‡§≤‡§æ‡§á‡§ü ‡§Æ‡•ã‡§°',
      dark: '‡§°‡§æ‡§∞‡•ç‡§ï ‡§Æ‡•ã‡§°',
      dashboard: '‡§°‡•à‡§∂‡§¨‡•ã‡§∞‡•ç‡§°',
    },
    bn: { // Bengali translations
      title: '‡¶ü‡ßÅ‡¶∞‡ßç‡¶®‡¶æ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú‡¶æ‡¶∞',
      logout: '‡¶≤‡¶ó ‡¶Ü‡¶â‡¶ü',
      light: '‡¶≤‡¶æ‡¶á‡¶ü ‡¶Æ‡ßã‡¶°',
      dark: '‡¶°‡¶æ‡¶∞‡ßç‡¶ï ‡¶Æ‡ßã‡¶°',
      dashboard: '‡¶°‡ßç‡¶Ø‡¶æ‡¶∂‡¶¨‡ßã‡¶∞‡ßç‡¶°',
    },
  };

  // Select the current translation based on the 'lang' state, falling back to English if not found.
  const t = translations[lang] || translations.en;

  // Show a loading screen while Firebase Authentication is initializing.
  // This prevents UI flashes or errors before the user's auth status is known.
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        Loading application...
      </div>
    );
  }

  // If the user is not logged in (user object is null after loading), render the AuthPage.
  // This acts as the unauthenticated entry point.
  if (!user) {
    return <AuthPage />;
  }

  // If the user is logged in, render the main application layout with routing.
  return (
    // BrowserRouter wraps the entire application to enable client-side routing.
    <BrowserRouter>
      <div className="min-h-screen bg-white text-black dark:bg-gray-900 dark:text-white flex flex-col">
        {/* Header component: Displays app title, dark mode toggle, language selector, and logout button. */}
        <Header
          darkMode={darkMode}
          setDarkMode={setDarkMode}
          lang={lang}
          setLang={setLang}
          t={t}
          // Pass the logout function from useAuth directly to the Header component.
          setToken={() => logout()}
        />

        {/* Main content area: Uses React Router's Routes component to define application routes. */}
        <div className="flex-grow">
          <Routes>
            {/* Root route: Displays the Dashboard page, protected by ProtectedRoute. */}
            <Route path="/" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />

            {/* Tournament-specific pages: These routes use a dynamic :id parameter to fetch tournament data. */}
            {/* Each is protected, ensuring only authenticated users can access them. */}
            <Route path="/tournament/:id" element={<ProtectedRoute><TournamentPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/fixtures" element={<ProtectedRoute><FixturesPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/leaderboard" element={<ProtectedRoute><LeaderboardPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/knockout" element={<ProtectedRoute><KnockoutPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/ai-prediction" element={<ProtectedRoute><AIPredictionPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/stats" element={<ProtectedRoute><StatsPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/players" element={<ProtectedRoute><PlayerPage /></ProtectedRoute>} />

            {/* Fallback route: If no other route matches, it redirects to the Dashboard. */}
            {/* This is also protected. */}
            <Route path="*" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />
          </Routes>
        </div>
      </div>
    </BrowserRouter>
  );
}

--- END FILE: src\App.jsx ---

--- START FILE: src\firebase.js ---

import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
import { getAuth } from "firebase/auth"; // Only getAuth is needed here for export

// Firebase configuration.
// It prioritizes the __firebase_config global variable provided by the Canvas environment.
// If __firebase_config is not defined (e.g., in a local development setup),
// it falls back to environment variables loaded via import.meta.env.
const firebaseConfig = typeof __firebase_config !== 'undefined'
  ? JSON.parse(__firebase_config) // Parse the stringified config from the Canvas environment
  : {
      apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
      authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
      projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
      storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
      appId: import.meta.env.VITE_FIREBASE_APP_ID,
    };

// Initialize the Firebase application with the provided configuration.
const app = initializeApp(firebaseConfig);

// Get a reference to the Firestore database service.
// This is the primary way to interact with your Firestore data.
const db = getFirestore(app);

// Get a reference to the Firebase Authentication service.
// This is used for user authentication (sign-in, sign-up, etc.).
const auth = getAuth(app);

// Export the initialized Firebase app, Firestore database, and Authentication instances.
// These can then be imported and used in other parts of your React application.
export { db, app, auth };


--- END FILE: src\firebase.js ---

--- START FILE: src\index.css ---

/* index.css */
/* Tailwind CSS imports */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom scrollbar styles for a cleaner look */
/* These styles apply to Webkit browsers (Chrome, Safari, Edge) */
::-webkit-scrollbar {
  width: 8px; /* Width of the vertical scrollbar */
  height: 8px; /* Height of the horizontal scrollbar */
}

::-webkit-scrollbar-track {
  background: #f1f1f1; /* Light background for the scrollbar track in light mode */
  border-radius: 10px; /* Rounded corners for the track */
}

/* Dark mode specific scrollbar track color */
html.dark ::-webkit-scrollbar-track {
  background: #333; /* Darker background for the track in dark mode */
}

::-webkit-scrollbar-thumb {
  background: #888; /* Gray thumb (the draggable part) in light mode */
  border-radius: 10px; /* Rounded corners for the thumb */
}

/* Dark mode specific scrollbar thumb color */
html.dark ::-webkit-scrollbar-thumb {
  background: #555; /* Darker thumb in dark mode */
}

::-webkit-scrollbar-thumb:hover {
  background: #555; /* Darker gray on hover for the thumb in light mode */
}

/* Dark mode specific scrollbar thumb hover color */
html.dark ::-webkit-scrollbar-thumb:hover {
  background: #777; /* Lighter gray on hover for the thumb in dark mode */
}

/* Ensure font consistency across the application */
/* Using 'Inter' font as per project instructions. Falls back to generic sans-serif. */
body {
  font-family: 'Inter', sans-serif;
}

/* Base styles for dark mode transition, applied to the html and body elements */
/* This creates a smooth visual transition when toggling dark/light mode. */
html {
  /* Define CSS variables for global text and background colors based on mode */
  --text-color: #1f2937; /* Default text color for light mode */
  --background-color: #ffffff; /* Default background color for light mode */
  transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
}

html.dark {
  --text-color: #f3f4f6; /* Text color for dark mode */
  --background-color: #1a202c; /* Background color for dark mode (e.g., gray-900) */
}

body {
  background-color: var(--background-color);
  color: var(--text-color);
}


--- END FILE: src\index.css ---

--- START FILE: src\main.jsx ---

import React from 'react';
import ReactDOM from 'react-dom/client'; // Correct import for React 18+
import App from './App.jsx'; // Main application component
import './index.css'; // Global CSS imports, including TailwindCSS

// Get the root DOM element where the React application will be mounted.
const rootElement = document.getElementById('root');

// Create a React root. This is the new API for React 18+ concurrent mode.
const root = ReactDOM.createRoot(rootElement);

// Display a loading message immediately before the React app fully mounts.
// This provides a user-friendly experience while initial assets and authentication state are determined.
// This is done by directly manipulating the innerHTML of the root element.
// Note: While this works, typically a dedicated loading component within App.jsx
// or a splash screen managed by a loading state in App.jsx is more React-idiomatic.
if (rootElement) { // Ensure rootElement exists before modifying it
  rootElement.innerHTML = '<div style="min-height: 100vh; display: flex; align-items: center; justify-content: center; background-color: #f3f4f6; color: #1f2937;">Loading application...</div>';
}

// Render the main App component into the React root.
// <React.StrictMode> is a tool for highlighting potential problems in an application.
// It does not render any visible UI. It activates additional checks and warnings for its descendants.
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Any initial Firebase auth setup or error handling (like config issues)
// is now handled internally by the useAuth hook within App.jsx and its child components.
// The previous comment "// import { initializeAuth } from './firebase.js';" is correctly commented out
// as explicit initialization of auth from here is no longer needed with the current setup.


--- END FILE: src\main.jsx ---

--- START FILE: src\components\Header.jsx ---

import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth'; // Import useAuth hook
import { RiMenu3Line, RiCloseLine } from 'react-icons/ri'; // Import menu icons

export default function Header({ darkMode, setDarkMode, lang, setLang, t }) {
  const { user, logout } = useAuth(); // Get user and logout from useAuth
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false); // State for mobile menu visibility

  const handleLogout = async () => {
    try {
      await logout();
    } catch (error) {
      console.error("Failed to log out:", error);
    }
  };

  const toggleMobileMenu = () => {
    setIsMobileMenuOpen(!isMobileMenuOpen);
  };

  return (
    <header className="bg-red-600 text-white p-4 shadow-md flex justify-between items-center relative">
      {/* Tournament Title/Link */}
      <Link to="/" className="text-xl font-bold tracking-wide z-20" onClick={() => setIsMobileMenuOpen(false)}>
        {t.title}
      </Link>

      {/* Hamburger/Close Icon for Mobile */}
      <div className="md:hidden z-20">
        <button
          onClick={toggleMobileMenu}
          className="p-2 rounded-md hover:bg-red-700 transition-colors focus:outline-none focus:ring-2 focus:ring-white"
          aria-label={isMobileMenuOpen ? "Close menu" : "Open menu"}
        >
          {isMobileMenuOpen ? (
            <RiCloseLine className="h-6 w-6" />
          ) : (
            <RiMenu3Line className="h-6 w-6" />
          )}
        </button>
      </div>

      {/* Navigation and Controls - Desktop */}
      <div className="hidden md:flex items-center space-x-4">
        {/* Language Switcher */}
        <div className="relative">
          <select
            value={lang}
            onChange={(e) => setLang(e.target.value)}
            className="bg-red-700 text-white p-2 rounded-md appearance-none pr-8 focus:outline-none focus:ring-2 focus:ring-white"
            aria-label="Select Language"
          >
            <option value="en">English</option>
            <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
            <option value="bn">‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
          </select>
          <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-white">
            <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
              <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
            </svg>
          </div>
        </div>

        {/* Dark Mode Toggle */}
        <button
          onClick={() => setDarkMode(!darkMode)}
          className="p-2 rounded-md hover:bg-red-700 transition-colors"
          aria-label={darkMode ? t.light : t.dark}
        >
          {darkMode ? '‚òÄÔ∏è' : 'üåô'}
        </button>

        {/* Logout Button */}
        {user && (
          <button
            onClick={handleLogout}
            className="bg-red-700 hover:bg-red-800 text-white font-semibold py-2 px-4 rounded-md transition-colors"
          >
            {t.logout}
          </button>
        )}
      </div>

      {/* Mobile Menu Overlay */}
      {isMobileMenuOpen && (
        <div className="md:hidden absolute top-0 left-0 w-full h-screen bg-red-600 z-10 flex flex-col items-center justify-center space-y-6 pt-16 pb-8">
          {/* Language Switcher */}
          <div className="relative w-48"> {/* Fixed width for mobile select */}
            <select
              value={lang}
              onChange={(e) => setLang(e.target.value)}
              className="bg-red-700 text-white p-3 rounded-md appearance-none pr-8 w-full focus:outline-none focus:ring-2 focus:ring-white text-lg"
              aria-label="Select Language"
            >
              <option value="en">English</option>
              <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
              <option value="bn">‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
            </select>
            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-white">
              <svg className="fill-current h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
              </svg>
            </div>
          </div>

          {/* Dark Mode Toggle */}
          <button
            onClick={() => { setDarkMode(!darkMode); setIsMobileMenuOpen(false); }}
            className="p-3 rounded-md hover:bg-red-700 transition-colors text-xl w-48"
            aria-label={darkMode ? t.light : t.dark}
          >
            {darkMode ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode'}
          </button>

          {/* Logout Button */}
          {user && (
            <button
              onClick={() => { handleLogout(); setIsMobileMenuOpen(false); }}
              className="bg-red-700 hover:bg-red-800 text-white font-semibold py-3 px-6 rounded-md transition-colors text-lg w-48"
            >
              {t.logout}
            </button>
          )}
        </div>
      )}
    </header>
  );
}

--- END FILE: src\components\Header.jsx ---

--- START FILE: src\components\LanguageSwitcher.jsx ---

// üìÅ src/components/LanguageSwitcher.jsx
import React from 'react';

export default function LanguageSwitcher({ lang, setLang }) {
  return (
    <select
      value={lang} // Controlled component: value is determined by the `lang` prop
      onChange={(e) => {
        setLang(e.target.value); // Update the language state
        localStorage.setItem('lang', e.target.value); // Persist the selected language in local storage
      }}
      className="border px-2 py-1 rounded bg-white dark:bg-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
      aria-label="Select application language" // Added for improved accessibility
    >
      {/* Language Options with Emojis */}
      <option value="en">üá¨üáß English</option>
      <option value="hi">üáÆüá≥ ‡§π‡§ø‡§Ç‡§¶‡•Ä</option>
      <option value="bn">üáßüá© ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
    </select>
  );
}

--- END FILE: src\components\LanguageSwitcher.jsx ---

--- START FILE: src\components\Modal.jsx ---

import React from 'react';

export default function Modal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  children, // For custom content
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  showConfirmButton = true,
}) {
  if (!isOpen) return null;

  return (
    // Overlay: Fixed position, full screen, semi-transparent black background, high z-index (z-50)
    // This div captures clicks outside the modal content to close it (if onClose is provided and appropriate)
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      {/* Modal Content Container:
          - bg-white dark:bg-gray-800: Background colors for light/dark modes.
          - p-6 md:p-8: Responsive padding.
          - rounded-lg: Rounded corners.
          - shadow-xl: Large shadow for depth.
          - w-full: Takes full width on small screens.
          - max-w-sm md:max-w-md: Responsive max-width.
          - max-h-[90vh] overflow-y-auto: Ensures modal content is scrollable if it exceeds viewport height.
          - text-center: Centers text horizontally.
          - relative z-50: Sets a new stacking context for its children and ensures it's on top.
      */}
      <div className="bg-white dark:bg-gray-800 p-6 md:p-8 rounded-lg shadow-xl w-full max-w-sm md:max-w-md max-h-[90vh] overflow-y-auto text-center relative z-50">
        <h3 className="text-xl md:text-2xl font-bold mb-4 text-gray-900 dark:text-white">{title || 'Attention'}</h3>
        {message && <p className="text-lg mb-4 text-gray-700 dark:text-gray-300">{message}</p>}

        {/* This is the placeholder for custom content, such as the score input fields.
            The 'children' prop renders whatever JSX is passed into the <Modal> component from its parent.
        */}
        {children}

        <div className="flex flex-col sm:flex-row justify-center gap-4 mt-6">
          {showConfirmButton && (
            <button
              onClick={onConfirm} // This triggers the confirmation logic (e.g., score update)
              className="bg-red-600 text-white px-6 py-2 rounded-md hover:bg-red-700 transition-colors font-semibold w-full sm:w-auto"
            >
              {confirmText}
            </button>
          )}
          <button
            onClick={onClose} // This triggers the modal to close
            className="bg-gray-400 text-white px-6 py-2 rounded-md hover:bg-gray-500 transition-colors font-semibold w-full sm:w-auto"
          >
            {cancelText}
          </button>
        </div>
      </div>
    </div>
  );
}

--- END FILE: src\components\Modal.jsx ---

--- START FILE: src\components\ProtectedRoute.jsx ---

import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth'; // Import useAuth hook

export default function ProtectedRoute({ children }) {
  const { user, loading } = useAuth(); // Destructure user and loading from useAuth

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-lg font-semibold animate-pulse">Checking authentication...</p>
      </div>
    );
  }

  // If user is not logged in, redirect to the login page
  if (!user) {
    return <Navigate to="/login" replace />; // Redirects to /login
  }

  // If user is logged in, render the children components
  return children;
}

--- END FILE: src\components\ProtectedRoute.jsx ---

--- START FILE: src\components\ScoreInputModalContent.jsx ---

import React, { useState, useEffect, useImperativeHandle, forwardRef } from 'react';

// Wrap the component with forwardRef
// The 'ref' parameter here is CRUCIAL for the parent component's ref to work
const ScoreInputModalContent = forwardRef(function ScoreInputModalContent(
  { fixture, initialScoreA, initialScoreB }, // Props (first argument)
  ref // The ref from the parent (second argument)
) {
  const [localTempScoreA, setLocalTempScoreA] = useState('');
  const [localTempScoreB, setLocalTempScoreB] = useState('');

  useEffect(() => {
    // This effect ensures initial values are set when props change (e.g., modal opens for a new fixture)
    setLocalTempScoreA(initialScoreA !== undefined && initialScoreA !== null ? String(initialScoreA) : '');
    setLocalTempScoreB(initialScoreB !== undefined && initialScoreB !== null ? String(initialScoreB) : '');
  }, [initialScoreA, initialScoreB]);

  // useImperativeHandle allows the parent to call methods on this child component via the ref
  useImperativeHandle(ref, () => ({
    getScoreA: () => localTempScoreA, // Expose a method to get the current state of score A
    getScoreB: () => localTempScoreB, // Expose a method to get the current state of score B
  }));

  // Handle changes in input fields
  const handleScoreAChange = (e) => {
    const value = e.target.value;
    // Allow only digits
    if (/^\d*$/.test(value)) {
      setLocalTempScoreA(value);
    }
  };

  const handleScoreBChange = (e) => {
    const value = e.target.value;
    // Allow only digits
    if (/^\d*$/.test(value)) {
      setLocalTempScoreB(value);
    }
  };

  return (
    // Added responsive padding: p-4 for small screens, md:p-6 for medium and larger
    <div className="p-4 md:p-6">
      {/* Changed to flex-col on small screens, sm:flex-row for horizontal on small-medium and up */}
      {/* Increased gap for better spacing, adjusted mb-6 to mb-8 */}
      <div className="flex flex-col sm:flex-row justify-around items-center gap-6 sm:gap-4 mb-8">
        <div className="text-center w-full sm:w-auto"> {/* Make div take full width on small screens */}
          <label htmlFor="scoreA" className="block text-sm sm:text-base font-medium text-gray-700 dark:text-gray-300 mb-2">
            {fixture.teamA} Score
          </label>
          <input
            id="scoreA"
            type="number"
            value={localTempScoreA}
            onChange={handleScoreAChange}
            // Adjusted width to w-full on small screens, w-28 on sm and up
            className="w-full sm:w-28 px-3 py-2 border border-gray-300 rounded-md text-center text-xl sm:text-lg font-semibold
                       dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            inputMode="numeric"
            pattern="[0-9]*"
          />
        </div>

        {/* Adjusted font size for separator */}
        <span className="text-3xl sm:text-2xl font-bold text-gray-900 dark:text-white my-4 sm:my-0">-</span>

        <div className="text-center w-full sm:w-auto"> {/* Make div take full width on small screens */}
          <label htmlFor="scoreB" className="block text-sm sm:text-base font-medium text-gray-700 dark:text-gray-300 mb-2">
            {fixture.teamB} Score
          </label>
          <input
            id="scoreB"
            type="number"
            value={localTempScoreB}
            onChange={handleScoreBChange}
            // Adjusted width to w-full on small screens, w-28 on sm and up
            className="w-full sm:w-28 px-3 py-2 border border-gray-300 rounded-md text-center text-xl sm:text-lg font-semibold
                       dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            inputMode="numeric"
            pattern="[0-9]*"
          />
        </div>
      </div>
    </div>
  );
});

export default ScoreInputModalContent;

--- END FILE: src\components\ScoreInputModalContent.jsx ---

--- START FILE: src\hooks\useAuth.js ---

import { useState, useEffect } from 'react';
import { auth, db } from '../firebase'; // Import auth and db from firebase.js
import {
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  GoogleAuthProvider, // Import GoogleAuthProvider
  signInWithPopup,    // Import signInWithPopup
  sendPasswordResetEmail // Import sendPasswordResetEmail
} from 'firebase/auth';
import { doc, setDoc } from 'firebase/firestore'; // For creating/updating user profiles in Firestore

/**
 * Custom React Hook for Firebase Authentication and User Profile Management.
 * Provides user authentication state, loading status, errors, and authentication functions.
 * @returns {{
 * user: import('firebase/auth').User | null,
 * loading: boolean,
 * error: Error | null,
 * register: (email: string, password: string) => Promise<import('firebase/auth').User>,
 * login: (email: string, password: string) => Promise<import('firebase/auth').User>,
 * loginWithGoogle: () => Promise<import('firebase/auth').User>, // New function
 * resetPassword: (email: string) => Promise<void>,             // New function
 * logout: () => Promise<void>
 * }}
 */
export const useAuth = () => {
  const [user, setUser] = useState(null); // Stores the Firebase User object when signed in
  const [loading, setLoading] = useState(true); // Indicates if the initial authentication state check is ongoing
  const [error, setError] = useState(null); // Stores any authentication-related errors

  /**
   * Effect hook to listen for changes in Firebase Authentication state.
   * This runs once on component mount and cleans up the listener on unmount.
   */
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        // User is signed in. Set the user state.
        setUser(firebaseUser);
        console.log("Firebase Auth State Changed: User signed in:", firebaseUser.uid);

        // Ensure a user document exists in Firestore for this user's UID.
        const userDocRef = doc(db, 'users', firebaseUser.uid);
        try {
          await setDoc(userDocRef, {
            email: firebaseUser.email,
            createdAt: firebaseUser.metadata?.creationTime,
            lastSignInTime: firebaseUser.metadata?.lastSignInTime,
            displayName: firebaseUser.displayName || 'Anonymous User',
          }, { merge: true });
          console.log("User profile ensured in Firestore for:", firebaseUser.uid);
        } catch (firestoreError) {
          console.error("Error ensuring user profile in Firestore:", firestoreError);
        }

      } else {
        // User is signed out (or initially not signed in). Clear the user state.
        setUser(null);
        console.log("Firebase Auth State Changed: User signed out.");
      }
      setLoading(false); // Authentication state check is complete, set loading to false.
    }, (authError) => {
      // Error occurred during authentication state change observation.
      console.error("Firebase Auth Listener Error:", authError);
      setError(authError); // Set error state
      setLoading(false); // Auth check is complete
    });

    // Cleanup function: Unsubscribe from the auth state listener when the component unmounts.
    return () => unsubscribe();
  }, []);

  /**
   * Registers a new user with email and password.
   * @param {string} email - The user's email address.
   * @param {string} password - The user's password.
   * @returns {Promise<import('firebase/auth').User>} A promise that resolves with the Firebase User object.
   * @throws {Error} Throws a Firebase Auth error if registration fails.
   */
  const register = async (email, password) => {
    setLoading(true);
    setError(null);
    try {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      console.log("User registered:", userCredential.user.uid);
      return userCredential.user;
    } catch (authError) {
      console.error("Registration error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  /**
   * Logs in an existing user with email and password.
   * @param {string} email - The user's email address.
   * @param {string} password - The user's password.
   * @returns {Promise<import('firebase/auth').User>} A promise that resolves with the Firebase User object.
   * @throws {Error} Throws a Firebase Auth error if login fails.
   */
  const login = async (email, password) => {
    setLoading(true);
    setError(null);
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      console.log("User logged in:", userCredential.user.uid);
      return userCredential.user;
    } catch (authError) {
      console.error("Login error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  /**
   * Logs in a user using Google authentication.
   * @returns {Promise<import('firebase/auth').User>} A promise that resolves with the Firebase User object.
   * @throws {Error} Throws a Firebase Auth error if login fails.
   */
  const loginWithGoogle = async () => {
    setLoading(true);
    setError(null);
    try {
      const provider = new GoogleAuthProvider();
      const userCredential = await signInWithPopup(auth, provider);
      console.log("User logged in with Google:", userCredential.user.uid);
      return userCredential.user;
    } catch (authError) {
      console.error("Google login error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  /**
   * Sends a password reset email to the specified email address.
   * @param {string} email - The user's email address.
   * @returns {Promise<void>} A promise that resolves when the email is sent.
   * @throws {Error} Throws a Firebase Auth error if sending fails.
   */
  const resetPassword = async (email) => {
    setLoading(true);
    setError(null);
    try {
      await sendPasswordResetEmail(auth, email);
      console.log("Password reset email sent to:", email);
    } catch (authError) {
      console.error("Password reset error:", authError);
      setError(authError);
      throw authError;
    } finally {
      setLoading(false);
    }
  };


  /**
   * Logs out the current user.
   * @returns {Promise<void>} A promise that resolves when the user is signed out.
   * @throws {Error} Throws a Firebase Auth error if logout fails.
   */
  const logout = async () => {
    setLoading(true);
    setError(null);
    try {
      await signOut(auth);
      console.log("User logged out.");
    } catch (authError) {
      console.error("Logout error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  // Return the user, loading state, error, and authentication functions for consumption by components.
  return { user, loading, error, register, login, loginWithGoogle, resetPassword, logout };
};

--- END FILE: src\hooks\useAuth.js ---

--- START FILE: src\hooks\useTournaments.js ---

import { useState, useEffect } from 'react';
import { collection, addDoc, onSnapshot, query, orderBy, where, serverTimestamp } from 'firebase/firestore';
import { db, auth } from '../firebase'; // Import auth from firebase.js

export const useTournaments = () => {
  const [tournaments, setTournaments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [userId, setUserId] = useState(null); // State to store the current user's ID

  // Listen for Firebase Auth state changes to get the user ID
  useEffect(() => {
    const unsubscribeAuth = auth.onAuthStateChanged(user => {
      if (user) {
        setUserId(user.uid);
      } else {
        setUserId(null); // Clear userId if user logs out
        setTournaments([]); // Clear tournaments if no user
        setLoading(false); // Stop loading if no user to fetch for
      }
    });
    return () => unsubscribeAuth();
  }, []); // Empty dependency array: runs once on mount, cleans up on unmount

  // Real-time listener for tournaments, now filtered by userId
  useEffect(() => {
    if (!userId) { // Only fetch if a userId is available
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Query tournaments where 'userId' field matches the current user's UID
      const tournamentsCollectionRef = collection(db, 'tournaments');
      const q = query(
        tournamentsCollectionRef,
        where('userId', '==', userId), // Filter by the current user's ID
        orderBy('createdAt', 'desc')
      );

      const unsubscribe = onSnapshot(q, (snapshot) => {
        const list = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setTournaments(list);
        setLoading(false);
      }, (err) => {
        console.error('Error fetching real-time tournaments for user:', userId, err);
        setError('Failed to load your tournaments. Please try again.');
        setLoading(false);
      });

      return () => unsubscribe(); // Clean up the listener
    } catch (err) {
      console.error("Error setting up tournaments listener:", err);
      setError("Failed to set up tournaments listener.");
      setLoading(false);
    }
  }, [userId]); // Re-run effect when userId changes

  // Function to create a new tournament, now requiring userId
  const createTournament = async (tournamentData) => {
    if (!userId) {
      // It's good to provide a more specific error or handle this in the UI
      console.error('Attempted to create tournament without authenticated user.');
      throw new Error('Authentication required to create a tournament.');
    }
    try {
      const docRef = await addDoc(collection(db, 'tournaments'), {
        ...tournamentData,
        userId: userId, // Associate tournament with the creator's ID
        createdAt: serverTimestamp(), // Use server timestamp for consistency
      });
      console.log("New tournament created with ID:", docRef.id);
      return docRef.id;
    } catch (err) {
      console.error('Error creating tournament:', err);
      throw new Error('Failed to create tournament.'); // Re-throw a generic error for the calling component
    }
  };

  return { tournaments, loading, error, createTournament };
};


--- END FILE: src\hooks\useTournaments.js ---

--- START FILE: src\pages\AIPredictionPage.jsx ---

import React, { useEffect, useState } from 'react';
import { db } from '../firebase';
import { collection, getDocs, doc, getDoc } from 'firebase/firestore';
import { useParams } from 'react-router-dom';

export default function AIPredictionPage() {
  const { id: tournamentId } = useParams();
  const [fixtures, setFixtures] = useState([]);
  const [selectedMatch, setSelectedMatch] = useState(null);
  const [result, setResult] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isPredicting, setIsPredicting] = useState(false);
  const [tournamentName, setTournamentName] = useState('');

  useEffect(() => {
    const fetchTournamentAndFixtures = async () => {
      setLoading(true);
      setError(null);
      try {
        if (!tournamentId) {
          setError("Tournament ID is missing.");
          setLoading(false);
          return;
        }

        // Fetch tournament name
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentDocSnap = await getDoc(tournamentDocRef);
        if (tournamentDocSnap.exists()) {
          setTournamentName(tournamentDocSnap.data().name);
        } else {
          setError("Tournament not found.");
          setLoading(false);
          return;
        }

        // Fetch fixtures
        const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
        const snapshot = await getDocs(fixturesCollectionRef);
        const data = snapshot.docs
          .map(doc => ({ id: doc.id, ...doc.data() }))
          .filter(fixture => fixture.status !== 'completed'); // Only show uncompleted matches
        setFixtures(data);
      } catch (err) {
        console.error('Error fetching data:', err);
        setError('Failed to load data. Please try again.');
      } finally {
        setLoading(false);
      }
    };
    fetchTournamentAndFixtures();
  }, [tournamentId]);

  const handlePredict = async () => {
    if (!selectedMatch) {
      setResult('Please select a match before predicting.');
      return;
    }
    setIsPredicting(true);
    setResult(null); // Clear previous results

    try {
      // IMPORTANT SECURITY NOTE:
      // NEVER expose your API_KEY directly in client-side code in a production application.
      // This is for demonstration purposes only.
      // In a real application, you should proxy this request through a secure backend server
      // (e.g., a Firebase Function or your own backend) to call the Generative AI API securely.
      // The API key should only be accessible on your backend.

      const API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
      if (!API_KEY) {
        throw new Error("Gemini API Key is not configured. Please check your .env file.");
      }

      const selectedFixture = fixtures.find(f => f.id === selectedMatch);
      if (!selectedFixture) {
        throw new Error("Selected fixture not found.");
      }

      const prompt = `Predict the winner or outcome of a football match between ${selectedFixture.teamA} and ${selectedFixture.teamB}.
      Consider general team strengths, current form (if known, otherwise assume average), and head-to-head records (if available, otherwise ignore).
      Provide a concise prediction.`;

      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error("API Error:", errorData);
        throw new Error(`Failed to get prediction: ${errorData.error.message || response.statusText}`);
      }

      const data = await response.json();
      const predictionText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No prediction could be generated.';
      setResult(predictionText);

    } catch (err) {
      console.error("Prediction error:", err);
      setResult(`Prediction failed: ${err.message}`);
      setError(err.message);
    } finally {
      setIsPredicting(false);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-lg font-semibold animate-pulse">Loading AI Prediction page...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white p-4">
        <p className="text-lg font-semibold text-red-500 text-center">Error: {error}</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
      <div className="p-4 sm:p-6 max-w-4xl mx-auto"> {/* Adjusted padding for responsiveness */}
        <h2 className="text-2xl sm:text-3xl font-extrabold mb-6 sm:mb-8 text-center text-red-600 dark:text-red-500">
          ‚ú® AI Match Prediction for {tournamentName}
        </h2>

        {fixtures.length === 0 ? (
          <p className="text-center text-gray-500 dark:text-gray-400 text-lg py-10">
            No upcoming fixtures to predict.
          </p>
        ) : (
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700">
            <p className="text-md sm:text-lg mb-4 text-gray-800 dark:text-gray-200">
              Select a match to get an AI-powered prediction:
            </p>

            <div className="flex flex-col sm:flex-row items-center gap-4 mb-6"> {/* Responsive layout for controls */}
              <select
                className="w-full sm:w-2/3 px-4 py-2 border border-gray-300 rounded-md bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white
                           focus:outline-none focus:ring-2 focus:ring-blue-500 text-base sm:text-lg"
                onChange={(e) => setSelectedMatch(e.target.value)}
                value={selectedMatch || ''}
              >
                <option value="">-- Select a Match --</option>
                {fixtures.map((fixture) => (
                  <option key={fixture.id} value={fixture.id}>
                    {fixture.teamA} vs {fixture.teamB} (
                    {new Date(fixture.timestamp?.toDate()).toLocaleDateString()})
                  </option>
                ))}
              </select>

              <button
                className={`w-full sm:w-1/3 px-4 py-2 rounded-md font-semibold text-lg transition-colors
                            ${selectedMatch && !isPredicting
                                ? 'bg-red-600 text-white hover:bg-red-700'
                                : 'bg-gray-300 text-gray-600 cursor-not-allowed dark:bg-gray-700 dark:text-gray-400'
                            }`}
                onClick={handlePredict}
                disabled={!selectedMatch || isPredicting}
              >
                {isPredicting ? 'Predicting...' : 'Predict Outcome'}
              </button>
            </div>

            {result && (
              <div className="mt-6 p-4 bg-blue-50 dark:bg-blue-900 border border-blue-200 dark:border-blue-700 rounded-md shadow-inner">
                <h3 className="text-lg sm:text-xl font-semibold text-blue-800 dark:text-blue-200 mb-2">Prediction:</h3>
                <p className="text-gray-700 dark:text-gray-300 text-base sm:text-lg">{result}</p>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

--- END FILE: src\pages\AIPredictionPage.jsx ---

--- START FILE: src\pages\AuthPage.jsx ---

import React, { useState, useEffect } from 'react';
import { useAuth } from '../hooks/useAuth';
import { FaEye, FaEyeSlash, FaGoogle } from 'react-icons/fa'; // Import icons
import { getPasswordStrength, getStrengthColor } from '../utils/passwordStrength'; // We'll create this utility

export default function AuthPage() {
  const { login, register, loginWithGoogle, resetPassword, loading, error } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isRegisterMode, setIsRegisterMode] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');
  const [successMessage, setSuccessMessage] = useState(''); // New state for success messages
  const [showPassword, setShowPassword] = useState(false); // State for password visibility
  const [passwordStrength, setPasswordStrength] = useState(0); // State for password strength (0-4)

  // Effect to listen to the global error from useAuth and display it
  useEffect(() => {
    if (error) {
      let friendlyError = 'An unexpected error occurred.';
      switch (error.code) {
        case 'auth/invalid-email':
          friendlyError = 'Invalid email address format.';
          break;
        case 'auth/user-disabled':
          friendlyError = 'This account has been disabled.';
          break;
        case 'auth/user-not-found':
        case 'auth/wrong-password':
          friendlyError = 'Invalid email or password.';
          break;
        case 'auth/email-already-in-use':
          friendlyError = 'This email is already registered. Try logging in.';
          break;
        case 'auth/weak-password':
          friendlyError = 'Password is too weak. It should be at least 6 characters.';
          break;
        case 'auth/network-request-failed':
          friendlyError = 'Network error. Please check your internet connection.';
          break;
        case 'auth/popup-closed-by-user': // For social login
          friendlyError = 'Login window closed. Please try again.';
          break;
        case 'auth/cancelled-popup-request': // For social login
          friendlyError = 'Another login attempt is in progress. Please wait or try again.';
          break;
        default:
          friendlyError = error.message;
      }
      setErrorMessage(friendlyError);
      setSuccessMessage(''); // Clear any success messages
    } else if (!loading) { // Clear errors when auth state is stable and no error
      setErrorMessage('');
    }
  }, [error, loading]);

  // Handle password change for strength indicator
  useEffect(() => {
    if (isRegisterMode) {
      setPasswordStrength(getPasswordStrength(password));
    } else {
      setPasswordStrength(0); // Reset strength when not in register mode
    }
  }, [password, isRegisterMode]);


  const handleSubmit = async (e) => {
    e.preventDefault();
    setErrorMessage('');
    setSuccessMessage('');

    try {
      if (isRegisterMode) {
        await register(email, password);
        setSuccessMessage('Registration successful! Please log in.');
        setIsRegisterMode(false); // Switch to login mode after successful registration
        setEmail(''); // Clear form fields
        setPassword('');
      } else {
        await login(email, password);
        // On successful login, useAuth hook's listener will update user state in App.jsx,
        // triggering navigation.
      }
    } catch (err) {
      // Error handled by useEffect listening to 'error' from useAuth
      console.error("Auth operation failed in AuthPage:", err);
    }
  };

  const handleGoogleLogin = async () => {
    setErrorMessage('');
    setSuccessMessage('');
    try {
      await loginWithGoogle();
      // On successful login, useAuth hook's listener will update user state in App.jsx,
      // triggering navigation.
    } catch (err) {
      // Error handled by useEffect listening to 'error' from useAuth
      console.error("Google login failed:", err);
    }
  };

  const handleForgotPassword = async () => {
    setErrorMessage('');
    setSuccessMessage('');
    if (!email) {
      setErrorMessage('Please enter your email to reset password.');
      return;
    }
    try {
      await resetPassword(email);
      setSuccessMessage('Password reset email sent! Check your inbox (and spam folder).');
      setEmail('');
    } catch (err) {
      console.error("Forgot password failed:", err);
      // Error handled by useEffect listening to 'error' from useAuth
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 px-4 py-8 relative overflow-hidden">
      {/* Background overlay for subtle texture/gradient matching the app's dark theme */}
      <div className="absolute inset-0 bg-gradient-to-br from-red-800 to-gray-900 opacity-20"></div>
      <div className="absolute inset-0 bg-pattern-dots opacity-5"></div> {/* Optional subtle pattern */}

      <div className="relative z-10 bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-md border border-red-700 backdrop-blur-sm bg-opacity-90 transition-all duration-300 hover:shadow-red-500/20">
        <div className="flex justify-center mb-6">
          {/* You can replace this with your actual logo component or image */}
          <img src="/logo.png" alt="Tournament Manager Logo" className="h-20 w-auto" onError={(e) => e.target.style.display = 'none'} />
          {/* Fallback text if image doesn't load or no logo is provided */}
          <h1 className="text-4xl font-extrabold text-red-500 hidden" style={{ display: 'none' }}>LTC</h1>
        </div>
        <h2 className="text-3xl font-extrabold mb-8 text-center text-white">
          {isRegisterMode ? 'üìù Create Account' : 'üîê Welcome Back!'}
        </h2>

        {/* Dynamic Message Area */}
        {errorMessage && (
          <div className="bg-red-900 text-red-200 p-3 rounded-md mb-4 text-center text-sm animate-fade-in-down border border-red-700">
            {errorMessage}
          </div>
        )}
        {successMessage && (
          <div className="bg-green-700 text-green-100 p-3 rounded-md mb-4 text-center text-sm animate-fade-in-down border border-green-500">
            {successMessage}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label htmlFor="email-address" className="sr-only">Email address</label>
            <input
              id="email-address"
              name="email"
              type="email"
              autoComplete="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Email address"
              className="w-full px-5 py-3 border border-gray-600 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-200"
              required
            />
          </div>
          <div className="mb-4 relative">
            <label htmlFor="password" className="sr-only">Password</label>
            <input
              id="password"
              name="password"
              type={showPassword ? 'text' : 'password'}
              autoComplete={isRegisterMode ? 'new-password' : 'current-password'}
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Password"
              className="w-full px-5 py-3 border border-gray-600 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-200 pr-12"
              required
            />
            <button
              type="button"
              onClick={() => setShowPassword(!showPassword)}
              className="absolute inset-y-0 right-0 pr-4 flex items-center text-gray-400 hover:text-white focus:outline-none transition-colors duration-200"
              aria-label={showPassword ? 'Hide password' : 'Show password'}
            >
              {showPassword ? <FaEyeSlash /> : <FaEye />}
            </button>
          </div>

          {isRegisterMode && password && (
            <div className="mb-4">
              <div className="text-sm font-medium text-gray-300 mb-1">
                Password Strength: <span className={`${getStrengthColor(passwordStrength)}`}>
                  {passwordStrength === 0 ? 'Too Short' : passwordStrength === 1 ? 'Weak' : passwordStrength === 2 ? 'Moderate' : passwordStrength === 3 ? 'Good' : 'Strong'}
                </span>
              </div>
              <div className="w-full bg-gray-600 rounded-full h-2">
                <div
                  className={`h-2 rounded-full transition-all duration-300`}
                  style={{
                    width: `${(passwordStrength / 4) * 100}%`,
                    backgroundColor: getStrengthColor(passwordStrength).replace('text-', 'bg-') // Map text color to background color
                  }}
                ></div>
              </div>
              <p className="text-xs text-gray-400 mt-1">
                {passwordStrength < 3 && 'Use 8+ characters, mixed case, numbers, and symbols for a stronger password.'}
              </p>
            </div>
          )}

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-red-600 text-white px-5 py-3 rounded-lg font-semibold text-lg hover:bg-red-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 active:scale-95"
          >
            {loading ? (isRegisterMode ? 'Registering...' : 'Logging In...') : isRegisterMode ? 'Register Account' : 'Login'}
          </button>
        </form>

        <div className="relative flex items-center justify-center my-6">
          <div className="flex-grow border-t border-gray-600"></div>
          <span className="flex-shrink mx-4 text-gray-500 text-sm">OR</span>
          <div className="flex-grow border-t border-gray-600"></div>
        </div>

        {/* Google Login Button */}
        <button
          onClick={handleGoogleLogin}
          disabled={loading}
          className="w-full flex items-center justify-center bg-gray-700 text-white px-5 py-3 rounded-lg font-semibold text-lg hover:bg-gray-600 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 active:scale-95"
        >
          <FaGoogle className="mr-3 text-xl" />
          {loading ? 'Signing In...' : 'Sign in with Google'}
        </button>

        <div className="flex justify-between items-center mt-6">
          <button
            onClick={() => setIsRegisterMode(!isRegisterMode)}
            className="text-red-400 hover:text-red-300 hover:underline text-sm transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 rounded-md p-1"
          >
            {isRegisterMode ? 'Already have an account? Login' : 'Need an account? Register'}
          </button>
          <button
            onClick={handleForgotPassword}
            className="text-gray-400 hover:text-gray-300 hover:underline text-sm transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500 rounded-md p-1"
          >
            Forgot Password?
          </button>
        </div>
      </div>
    </div>
  );
}

--- END FILE: src\pages\AuthPage.jsx ---

--- START FILE: src\pages\Dashboard.jsx ---

// src/pages/Dashboard.jsx
import React, { useState, useEffect } from 'react';
import { Link, useParams, useLocation } from 'react-router-dom';
import { db } from '../firebase';
import { collection, query, where, onSnapshot, addDoc, doc, deleteDoc, serverTimestamp, writeBatch, getDoc } from 'firebase/firestore';
import { useAuth } from '../hooks/useAuth';
import { useTournaments } from '../hooks/useTournaments'; // Import the custom hook
import Modal from '../components/Modal'; // Ensure Modal is imported

export default function Dashboard() {
  const { user, loading: authLoading } = useAuth();
  const { tournaments, loading, error, createTournament } = useTournaments(); // Use the custom hook
  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  const shareId = queryParams.get('shareId'); // Get shareId from URL

  const [isCreating, setIsCreating] = useState(false);
  const [newTournamentName, setNewTournamentName] = useState('');
  const [newTournamentType, setNewTournamentType] = useState('League');
  const [createError, setCreateError] = useState(null);

  // Modal State for custom actions like delete confirmation or info messages
  const [modalOpen, setModalOpen] = useState(false);
  const [modalTitle, setModalTitle] = useState(''); // Added title for Modal component
  const [modalMessage, setModalMessage] = useState('');
  const [modalConfirmAction, setModalConfirmAction] = useState(null);
  // Removed modalInputRequired, modalInputLabel, modalInputValue, modalCustomContent
  // as the generic Modal component handles its children dynamically for input/custom content.

  // State to manage shared view access
  const [isViewOnly, setIsViewOnly] = useState(false);
  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);
  const [isOwner, setIsOwner] = useState(false);

  useEffect(() => {
    if (shareId) {
      setIsViewOnly(true);
      // Fetch tournament owner ID if in shared view
      const fetchOwner = async () => {
        try {
          const tournamentRef = doc(db, 'tournaments', shareId);
          const tournamentSnap = await getDoc(tournamentRef);
          if (tournamentSnap.exists()) {
            setTournamentOwnerId(tournamentSnap.data().userId);
          } else {
            console.error('Tournament not found for shareId:', shareId);
            // Optionally, redirect to a not-found page or show an error
          }
        } catch (err) {
          console.error('Error fetching tournament owner:', err);
        }
      };
      fetchOwner();
    } else {
      setIsViewOnly(false);
      setTournamentOwnerId(null);
    }
  }, [shareId]);

  useEffect(() => {
    // Determine if the current user is the owner of the tournament (if in shared view)
    if (isViewOnly && user && tournamentOwnerId) {
      setIsOwner(user.uid === tournamentOwnerId);
    } else if (!isViewOnly && user) {
      // If not in view-only mode, the user is always the owner of their own dashboard
      setIsOwner(true);
    } else {
      setIsOwner(false);
    }
  }, [isViewOnly, user, tournamentOwnerId]);

  // Handler for opening the custom modal
  const openCustomModal = (title, message, onConfirm = null) => {
    setModalTitle(title); // Set the modal title
    setModalMessage(message);
    setModalConfirmAction(() => onConfirm); // Use a function to set state with a function
    setModalOpen(true);
  };

  // Handler for closing the custom modal
  const closeCustomModal = () => {
    setModalOpen(false);
    setModalTitle(''); // Clear modal title
    setModalMessage('');
    setModalConfirmAction(null);
  };

  const handleModalConfirm = () => {
    if (modalConfirmAction) {
      modalConfirmAction();
    }
    closeCustomModal();
  };

  const handleModalCancel = () => {
    closeCustomModal();
  };

  const handleCreateTournament = async (e) => {
    e.preventDefault();
    setCreateError(null);
    if (!newTournamentName.trim()) {
      setCreateError("Tournament name cannot be empty.");
      return;
    }
    try {
      await createTournament({
        name: newTournamentName,
        type: newTournamentType,
      });
      setNewTournamentName('');
      setNewTournamentType('League');
      setIsCreating(false);
    } catch (err) {
      setCreateError(err.message || "Failed to create tournament.");
    }
  };

  const handleDeleteTournament = (tournamentId, tournamentName) => {
    // Only allow deletion if not in view-only mode AND the user is the owner
    if (isViewOnly || !isOwner) {
      openCustomModal('Access Denied', 'You do not have permission to delete tournaments in view-only mode.', null);
      return;
    }

    openCustomModal(
      'Confirm Deletion',
      `Are you sure you want to delete the tournament "${tournamentName}"? This action cannot be undone.`,
      async () => {
        try {
          const tournamentRef = doc(db, 'tournaments', tournamentId);
          await deleteDoc(tournamentRef);
          // Also delete all subcollections (fixtures, teams, leaderboard entries, players, knockout matches, match stats)
          // This requires fetching all documents in each subcollection and deleting them in a batch.
          // Due to Firestore limitations on batch writes (max 500 operations), this might need to be paginated for very large tournaments.
          // For simplicity, we'll demonstrate a basic deletion for common subcollections.
          // In a production app, consider Cloud Functions for recursive deletes.

          const subcollections = ['fixtures', 'teams', 'leaderboard', 'players', 'knockoutMatches', 'match_stats'];
          for (const subcollectionName of subcollections) {
            const subcollectionRef = collection(db, `tournaments/${tournamentId}/${subcollectionName}`);
            const q = query(subcollectionRef);
            const snapshot = await getDocs(q);
            const batch = writeBatch(db);
            snapshot.docs.forEach(doc => {
              batch.delete(doc.ref);
            });
            if (snapshot.docs.length > 0) {
              await batch.commit();
              console.log(`Deleted ${snapshot.docs.length} documents from ${subcollectionName}`);
            }
          }

          openCustomModal('Success', `Tournament "${tournamentName}" and all its data deleted successfully!`, null);
        } catch (err) {
          console.error('Error deleting tournament:', err);
          openCustomModal('Error', 'Failed to delete tournament. Please try again.', null);
        }
      }
    );
  };

  const copyShareLink = () => {
    const shareLink = `${window.location.origin}/?shareId=${user.uid}`;
    navigator.clipboard.writeText(shareLink)
      .then(() => {
        openCustomModal('Link Copied!', 'The shareable link to your dashboard has been copied to your clipboard.', null);
      })
      .catch((err) => {
        console.error('Failed to copy link:', err);
        openCustomModal('Error', 'Failed to copy link. Please try manually.', null);
      });
  };

  // Conditional rendering for loading and error states
  if (authLoading || loading) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[calc(100vh-4rem)] bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-xl font-semibold">Loading dashboard...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[calc(100vh-4rem)] bg-gray-100 dark:bg-gray-900 text-red-500">
        <p className="text-xl font-semibold">Error: {error.message || "Failed to load tournaments."}</p>
      </div>
    );
  }

  return (
    <div className="min-h-[calc(100vh-4rem)] bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white p-6"> {/* Responsive padding and background */}
      <div className="max-w-6xl mx-auto"> {/* Max width and auto margins for centering on large screens */}
        <h2 className="text-3xl font-bold mb-6 text-center">Your Tournaments</h2>

        {/* Share Dashboard Section - only visible if user is logged in and not in view-only mode */}
        {user && !isViewOnly && (
          <div className="bg-blue-100 dark:bg-blue-900 p-4 rounded-lg shadow-md mb-6 text-center">
            <p className="text-blue-800 dark:text-blue-200 mb-3">
              Share your dashboard with others! They will be able to view your tournaments.
            </p>
            <button
              onClick={copyShareLink}
              className="bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors duration-200"
            >
              Copy Shareable Link
            </button>
          </div>
        )}

        {/* Create Tournament Section - only show if not view-only AND owner */}
        {!isViewOnly && isOwner && (
          <div className="mb-6 text-center">
            <button
              onClick={() => setIsCreating(!isCreating)}
              className="bg-red-600 text-white font-bold py-3 px-6 rounded-md shadow-lg hover:bg-red-700 transition-colors duration-200 uppercase tracking-wide transform hover:scale-105"
            >
              {isCreating ? 'Cancel Creation' : 'Create New Tournament'}
            </button>
          </div>
        )}

        {isCreating && (
          <div className="max-w-md mx-auto bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md mb-8"> {/* Responsive form container */}
            <h3 className="text-xl font-bold mb-4 text-center">‚ûï New Tournament Details</h3>
            <form onSubmit={handleCreateTournament} className="space-y-4">
              <div>
                <label htmlFor="tournamentName" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Tournament Name
                </label>
                <input
                  type="text"
                  id="tournamentName"
                  value={newTournamentName}
                  onChange={(e) => setNewTournamentName(e.target.value)}
                  className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white" // w-full for responsive input width
                  placeholder="e.g., Summer League 2024"
                  required
                />
              </div>
              <div>
                <label htmlFor="tournamentType" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Tournament Type
                </label>
                <select
                  id="tournamentType"
                  value={newTournamentType}
                  onChange={(e) => setNewTournamentType(e.target.value)}
                  className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white" // w-full for responsive select width
                >
                  <option value="League">League</option>
                  {/* Removed 'Knockout' option */}
                  <option value="Multi-Phase">Multi-Phase Tournament</option>
                </select>
              </div>
              {createError && <p className="text-red-500 text-sm text-center">{createError}</p>}
              <button
                type="submit"
                className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors font-semibold"
              >
                Create Tournament
              </button>
            </form>
          </div>
        )}

        {/* Displaying Tournaments Section (Now always visible below action buttons/form) */}
        <div className="w-full max-w-4xl mx-auto"> {/* Max width and auto margins for centering */}
          <h3 className="text-xl font-bold mb-4 text-center mt-8">My Tournaments</h3>
          {tournaments.length === 0 ? (
            <p className="text-gray-500 text-center">
              {isViewOnly ? "This user has no tournaments yet." : "No tournaments found yet. Create one!"}
            </p>
          ) : (
            <ul className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"> {/* Responsive grid for tournament cards */}
              {tournaments.map(t => (
                <li key={t.id} className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border border-gray-200 dark:border-gray-700 flex flex-col justify-between items-center text-center transition-transform transform hover:scale-[1.02]">
                  <h4 className="font-semibold text-lg mb-1">{t.name}</h4>
                  <p className="text-sm text-gray-500 dark:text-gray-400 mb-2">{t.type}</p>
                  {t.createdAt && t.createdAt.seconds && (
                    <p className="text-xs text-gray-400 dark:text-gray-500 mb-3">
                      Created on: {new Date(t.createdAt.seconds * 1000).toLocaleDateString()}
                    </p>
                  )}
                  <div className="flex gap-2 mt-2"> {/* Container for buttons */}
                    <Link
                      to={`/tournament/${t.id}${shareId ? `?shareId=${shareId}` : ''}`}
                      className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors duration-200 text-sm"
                    >
                      Open Tournament
                    </Link>
                    {!isViewOnly && isOwner && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation(); // Prevent Link from triggering
                          handleDeleteTournament(t.id, t.name);
                        }}
                        className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600 transition-colors duration-200 text-sm"
                      >
                        Delete
                      </button>
                    )}
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>

        {/* Custom Modal Component (using the shared Modal) */}
        <Modal
          isOpen={modalOpen}
          onClose={handleModalCancel}
          onConfirm={handleModalConfirm}
          title={modalTitle}
          message={modalMessage}
          showConfirmButton={modalConfirmAction !== null}
        />
      </div>
    </div>
  );
}


--- END FILE: src\pages\Dashboard.jsx ---

--- START FILE: src\pages\FixturesPage.jsx ---

// üìÅ src/pages/FixturesPage.jsx
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  collection,
  query,
  orderBy,
  onSnapshot,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  writeBatch,
  getDocs,
  serverTimestamp,
  getDoc, // Added getDoc
  where, // Added where for filtering by group
} from 'firebase/firestore';
import { db } from '../firebase';
import { useAuth } from '../hooks/useAuth';
import Modal from '../components/Modal';
import ScoreInputModalContent from '../components/ScoreInputModalContent';

export default function FixturesPage() {
  const { id: tournamentId } = useParams();

  // All hooks must be declared at the top level, unconditionally
  const [fixtures, setFixtures] = useState([]);
  const [teams, setTeams] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isAddingFixture, setIsAddingFixture] = useState(false);
  const [newFixture, setNewFixture] = useState({
    teamA: '',
    teamB: '',
    date: '', // Storing as YYYY-MM-DD string
    timestamp: null, // Firestore Timestamp object for ordering
    status: 'scheduled',
    scoreA: 0,
    scoreB: 0,
    weekNumber: 0, // Default to 0 for manually added fixtures
    groupId: '', // New field for group ID
  });
  const [fixtureError, setFixtureError] = useState('');
  const [tournamentDetails, setTournamentDetails] = useState(null);
  const { user } = useAuth();
  const [isViewOnly, setIsViewOnly] = useState(false); // State to check if it's a shared view
  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);

  // State for Custom Modal
  const [customModalOpen, setCustomModalOpen] = useState(false);
  const [customModalTitle, setCustomModalTitle] = useState('');
  const [customModalMessage, setCustomModalMessage] = useState('');
  const [customModalOnConfirm, setCustomModalOnConfirm] = useState(null);
  const [customModalShowConfirm, setCustomModalShowConfirm] = useState(true);

  // State for Score Input Modal
  const [scoreModalOpen, setScoreModalOpen] = useState(false);
  const [editingFixture, setEditingFixture] = useState(null);
  const scoreInputRef = useRef(null); // Ref for ScoreInputModalContent

  // Helper to open the custom modal
  const openCustomModal = useCallback((title, message, onConfirm = null, showConfirm = true) => {
    setCustomModalTitle(title);
    setCustomModalMessage(message);
    setCustomModalOnConfirm(() => onConfirm); // Use a function to set state with a function
    setCustomModalShowConfirm(showConfirm);
    setCustomModalOpen(true);
  }, []);

  // Helper to close the custom modal
  const closeCustomModal = useCallback(() => {
    setCustomModalOpen(false);
    setCustomModalTitle('');
    setCustomModalMessage('');
    setCustomModalOnConfirm(null);
    setCustomModalShowConfirm(true);
  }, []);

  // Helper function to shuffle an array (Fisher-Yates)
  const shuffleArray = useCallback((array) => {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
  }, []);

  // Fetch tournament details and set view-only mode
  useEffect(() => {
    if (!tournamentId) return;

    const tournamentRef = doc(db, 'tournaments', tournamentId);
    const unsubscribe = onSnapshot(
      tournamentRef,
      (docSnap) => {
        if (docSnap.exists()) {
          const data = docSnap.data();
          setTournamentDetails(data);
          setTournamentOwnerId(data.userId);
          // Determine if it's a view-only link (assuming shareId is in URL)
          const urlParams = new URLSearchParams(window.location.search);
          const shareIdParam = urlParams.get('shareId');
          // If shareId is present, OR if user is not logged in AND tournament is public
          const currentIsViewOnly = (!!shareIdParam) || (!user && (data.isPublic || false));
          setIsViewOnly(currentIsViewOnly);
        } else {
          setError('Tournament not found.');
          setLoading(false);
        }
      },
      (err) => {
        console.error('Error fetching tournament details:', err);
        setError('Failed to load tournament details.');
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, [tournamentId, user]); // Added user to dependencies

  // Listen to Teams and Fixtures collections
  useEffect(() => {
    if (!tournamentId) return;

    // Teams subscription
    const teamsCollectionRef = collection(db, `tournaments/${tournamentId}/teams`);
    const unsubscribeTeams = onSnapshot(
      query(teamsCollectionRef, orderBy('name', 'asc')),
      (snapshot) => {
        setTeams(snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() })));
      },
      (err) => {
        console.error('Error fetching real-time teams:', err);
        if (!isViewOnly) { // Only show error to owner/editor
          setError('Failed to load teams.');
        }
      }
    );

    // Fixtures subscription
    const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
    const unsubscribeFixtures = onSnapshot(
      query(fixturesCollectionRef, orderBy('timestamp', 'asc')), // Order by timestamp
      (snapshot) => {
        const fetchedFixtures = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
          // Convert Firestore Timestamp to Date string for input[type="date"]
          date: doc.data().timestamp ? new Date(doc.data().timestamp.toDate()).toISOString().split('T')[0] : '',
        }));
        setFixtures(fetchedFixtures);
        setLoading(false);
      },
      (err) => {
        console.error('Error fetching real-time fixtures:', err);
        if (!isViewOnly) { // Only show error to owner/editor
          setError('Failed to load fixtures.');
        }
        setLoading(false);
      }
    );

    return () => {
      unsubscribeTeams();
      unsubscribeFixtures();
    };
  }, [tournamentId, isViewOnly]);

  // Generate Round Robin Fixtures (Modified to accept team objects and group ID)
  const generateRoundRobinFixtures = useCallback((teamsToSchedule, isHomeAndAway, groupId = '') => {
    const numTeams = teamsToSchedule.length;
    if (numTeams < 2) return [];

    let teamsForScheduling = [...teamsToSchedule];
    // If odd number of teams, add a 'BYE' team
    if (numTeams % 2 !== 0) {
      teamsForScheduling.push({ name: 'BYE', id: 'BYE' }); // Use object for BYE for consistency
    }

    const n = teamsForScheduling.length;
    const roundsNeeded = n - 1; // Number of rounds in a single round-robin

    let allLogicalRounds = [];

    for (let roundNum = 0; roundNum < roundsNeeded; roundNum++) {
      let currentRoundFixtures = [];
      // Pair the first team with the last rotating team
      const fixedTeam = teamsForScheduling[0];
      const rotatingTeamOppositeFixed = teamsForScheduling[(roundNum + (n - 1)) % (n - 1) + 1] || teamsForScheduling[n - 1]; // Robust indexing

      if (fixedTeam.name !== 'BYE' && rotatingTeamOppositeFixed.name !== 'BYE') {
        if (roundNum % 2 === 0) {
          currentRoundFixtures.push({ teamA: fixedTeam.name, teamB: rotatingTeamOppositeFixed.name });
        } else {
          currentRoundFixtures.push({ teamA: rotatingTeamOppositeFixed.name, teamB: fixedTeam.name });
        }
      }

      // Pair the remaining teams
      for (let i = 1; i < n / 2; i++) {
        const team1 = teamsForScheduling[(roundNum + i) % (n - 1) + 1];
        const team2 = teamsForScheduling[(roundNum + n - 1 - i) % (n - 1) + 1];

        if (team1.name !== 'BYE' && team2.name !== 'BYE') {
          if (i % 2 === 0) {
            currentRoundFixtures.push({ teamA: team1.name, teamB: team2.name });
          } else {
            currentRoundFixtures.push({ teamA: team2.name, teamB: team1.name });
          }
        }
      }
      shuffleArray(currentRoundFixtures); // Shuffle fixtures within each round
      allLogicalRounds.push(currentRoundFixtures);
    }

    let finalFixturesForDb = [];
    if (isHomeAndAway) {
      let returnRounds = [];
      allLogicalRounds.forEach(round => {
        let returnRound = [];
        round.forEach(fixture => {
          returnRound.push({ teamA: fixture.teamB, teamB: fixture.teamA });
        });
        returnRounds.push(returnRound);
      });
      allLogicalRounds = [...allLogicalRounds, ...returnRounds];
    }

    allLogicalRounds.forEach((roundFixtures, index) => {
      const weekNumber = index + 1; // Start week numbers from 1
      roundFixtures.forEach(fixture => {
        finalFixturesForDb.push({
          ...fixture,
          weekNumber: weekNumber,
          groupId: groupId, // Assign fixture to its group
        });
      });
    });

    return finalFixturesForDb;
  }, [shuffleArray]);

  const handleGenerateFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to generate fixtures in view-only mode.', null, false);
      return;
    }

    if (teams.length < 2) {
      openCustomModal('Info', 'You need at least two teams to generate fixtures!', null, false);
      return;
    }

    if (!tournamentDetails) {
      openCustomModal('Error', 'Tournament details not loaded. Cannot generate fixtures.', null, false);
      return;
    }

    const currentFixtureOption = tournamentDetails.fixtureOption || 'Single Matches';
    const isHomeAndAway = currentFixtureOption === 'Home and Away Matches';

    let allGeneratedFixtures = [];
    let currentDate = new Date();
    currentDate.setHours(12, 0, 0, 0); // Normalize to midday to avoid timezone issues

    if (tournamentDetails.type === 'Multi-Phase' && tournamentDetails.groups && tournamentDetails.groups.length > 0) {
      // Generate fixtures for each group
      for (const groupName of tournamentDetails.groups) {
        const teamsInGroup = teams.filter(team => team.group === groupName);
        if (teamsInGroup.length < 2) {
          console.warn(`Skipping fixture generation for group "${groupName}": Not enough teams.`);
          continue;
        }
        const groupFixtures = generateRoundRobinFixtures(teamsInGroup, isHomeAndAway, groupName);

        allGeneratedFixtures.push(...groupFixtures);
      }
    } else {
      // Existing logic for League type, or Multi-Phase without groups defined
      const teamObjects = teams.map(t => ({ name: t.name, id: t.id })); // Pass full team objects
      const generatedFixturesWithWeekNumbers = generateRoundRobinFixtures(teamObjects, isHomeAndAway, ''); // No group ID for non-grouped
      allGeneratedFixtures.push(...generatedFixturesWithWeekNumbers);
    }

    // Sort all fixtures by week number for consistent date assignment
    allGeneratedFixtures.sort((a, b) => a.weekNumber - b.weekNumber);

    const finalFixturesToSave = [];
    let currentWeek = 0;
    allGeneratedFixtures.forEach(fixture => {
      // Advance date only when moving to a new week
      if (fixture.weekNumber > currentWeek) {
        if (currentWeek > 0) { // Don't advance for the first week
          currentDate.setDate(currentDate.getDate() + 7); // Advance by a week for the next set of fixtures
        }
        currentWeek = fixture.weekNumber;
      }

      finalFixturesToSave.push({
        teamA: fixture.teamA,
        teamB: fixture.teamB,
        date: currentDate.toISOString().split('T')[0],
        timestamp: new Date(currentDate), // Store as Date object for Firestore
        status: 'scheduled',
        scoreA: 0,
        scoreB: 0,
        weekNumber: fixture.weekNumber,
        groupId: fixture.groupId || '', // Include groupId
      });
    });


    if (finalFixturesToSave.length === 0) {
      openCustomModal('Info', 'No fixtures could be generated. Check your team list, groups, and fixture options.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Fixture Generation',
      `This will delete ALL existing fixtures and generate ${finalFixturesToSave.length} new ones. Are you sure?`,
      async () => {
        const batch = writeBatch(db);
        const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);

        // Delete existing fixtures
        const existingFixturesSnapshot = await getDocs(fixturesCollectionRef);
        existingFixturesSnapshot.docs.forEach((doc) => {
          batch.delete(doc.ref);
        });

        // Add new fixtures
        finalFixturesToSave.forEach(fixture => {
          const newFixtureRef = doc(fixturesCollectionRef); // Let Firestore auto-generate ID
          batch.set(newFixtureRef, fixture);
        });

        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', `Successfully generated ${finalFixturesToSave.length} fixtures!`, null, false);
          // Optionally, trigger a leaderboard update here if it depends on fixtures
          // For now, assume leaderboard update is handled elsewhere or is reactive to fixture changes
        } catch (err) {
          console.error('Error generating fixtures:', err);
          openCustomModal('Error', 'Failed to generate fixtures. Please try again.');
        }
      }
    );
  };

  const handleAddFixture = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to add fixtures in view-only mode.', null, false);
      return;
    }

    setFixtureError('');
    if (!newFixture.teamA || !newFixture.teamB || !newFixture.date) {
      setFixtureError('Please select both teams and a date for the fixture.');
      return;
    }
    if (newFixture.teamA === newFixture.teamB) {
      setFixtureError('Teams cannot be the same.');
      return;
    }
    let fixtureGroup = '';
    // For multi-phase, ensure teams selected are from the same group if groups exist
    if (tournamentDetails?.type === 'Multi-Phase' && tournamentDetails.groups && tournamentDetails.groups.length > 0) {
        const teamAObj = teams.find(t => t.name === newFixture.teamA);
        const teamBObj = teams.find(t => t.name === newFixture.teamB);

        if (!teamAObj || !teamBObj || teamAObj.group !== teamBObj.group) {
            setFixtureError('For Multi-Phase tournaments, teams must be from the same group for custom fixtures.');
            return;
        }
        fixtureGroup = teamAObj.group; // Assign group ID to the fixture
    }


    try {
      const fixtureDate = new Date(newFixture.date);
      // Validate date object
      if (isNaN(fixtureDate.getTime())) {
        setFixtureError('Invalid date format.');
        return;
      }
      fixtureDate.setHours(12, 0, 0, 0); // Normalize date to midday UTC

      await addDoc(collection(db, `tournaments/${tournamentId}/fixtures`), {
        ...newFixture,
        timestamp: fixtureDate, // Store as Date object for Firestore
        scoreA: 0, // Default scores
        scoreB: 0,
        status: 'scheduled', // Default status
        weekNumber: 0, // Manually added fixtures default to week 0, can be updated later if needed
        groupId: fixtureGroup, // Store the group ID
      });
      setNewFixture({ teamA: '', teamB: '', date: '', timestamp: null, status: 'scheduled', scoreA: 0, scoreB: 0, groupId: '' }); // Reset form
      setFixtureError(''); // Clear any previous errors
      setIsAddingFixture(false); // Hide the form after adding
    } catch (err) {
      console.error('Error adding fixture:', err);
      setFixtureError('Failed to add fixture.');
    }
  };

  const handleDeleteFixture = async (fixtureId) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to delete fixtures in view-only mode.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Delete',
      'Are you sure you want to delete this fixture? This action cannot be undone.',
      async () => {
        try {
          await deleteDoc(doc(db, `tournaments/${tournamentId}/fixtures`, fixtureId));
          closeCustomModal();
          // Assume leaderboard updates reactively or a separate function triggers it
        } catch (err) {
          console.error('Error deleting fixture:', err);
          openCustomModal('Error', 'Failed to delete fixture. Please try again.');
        }
      }
    );
  };

  const handleClearAllFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to clear all fixtures in view-only mode.', null, false);
      return;
    }

    if (fixtures.length === 0) {
      openCustomModal('Info', 'No fixtures to clear.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Clear All Fixtures',
      'Are you sure you want to delete ALL fixtures? This will reset match data for the leaderboard.',
      async () => {
        const batch = writeBatch(db);
        fixtures.forEach(fixture => {
          const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, fixture.id);
          batch.delete(fixtureRef);
        });

        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', 'All fixtures cleared successfully!', null, false);
          // Assuming leaderboard updates reactively
        } catch (err) {
          console.error('Error clearing all fixtures:', err);
          openCustomModal('Error', 'Failed to clear all fixtures. Please try again.');
        }
      }
    );
  };

  const handleOpenScoreModal = (fixture) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to edit scores in view-only mode.', null, false);
      return;
    }
    setEditingFixture(fixture);
    setScoreModalOpen(true);
  };

  const handleCloseScoreModal = () => {
    setScoreModalOpen(false);
    setEditingFixture(null);
  };

  const handleUpdateScore = async () => {
    if (!editingFixture || !scoreInputRef.current) return;

    const scoreA = scoreInputRef.current.getScoreA();
    const scoreB = scoreInputRef.current.getScoreB();

    const parsedScoreA = parseInt(scoreA);
    const parsedScoreB = parseInt(scoreB);

    if (isNaN(parsedScoreA) || isNaN(parsedScoreB)) {
      openCustomModal('Invalid Input', 'Please enter valid numbers for scores.', null, false);
      return;
    }

    try {
      const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, editingFixture.id);
      await updateDoc(fixtureRef, {
        scoreA: parsedScoreA,
        scoreB: parsedScoreB,
        status: 'completed', // Mark as completed once score is updated
      });
      handleCloseScoreModal();
      openCustomModal('Success', 'Score updated successfully!', null, false);
      // Assuming leaderboard updates reactively
    } catch (err) {
      console.error('Error updating score:', err);
      openCustomModal('Error', 'Failed to update score. Please try again.', null, false);
    }
  };

  const groupedFixtures = useMemo(() => {
    const groupedByGroup = fixtures.reduce((acc, fixture) => {
      const group = fixture.groupId || 'Ungrouped'; // Use 'Ungrouped' for fixtures without a group
      if (!acc[group]) {
        acc[group] = {};
      }
      const week = fixture.weekNumber > 0 ? `Week ${fixture.weekNumber}` : 'Manual Fixtures';
      if (!acc[group][week]) {
        acc[group][week] = [];
      }
      acc[group][week].push(fixture);
      return acc;
    }, {});

    // Sort groups alphabetically, with 'Ungrouped' last
    const sortedGroupNames = Object.keys(groupedByGroup).sort((a, b) => {
      if (a === 'Ungrouped') return 1;
      if (b === 'Ungrouped') return -1;
      return a.localeCompare(b);
    });

    const finalGrouped = {};
    sortedGroupNames.forEach(groupName => {
      finalGrouped[groupName] = groupedByGroup[groupName];
      // Sort weeks within each group
      const sortedWeekNumbers = Object.keys(finalGrouped[groupName]).sort((a, b) => {
        if (a === 'Manual Fixtures') return 1;
        if (b === 'Manual Fixtures') return -1;
        return parseInt(a.replace('Week ', '')) - parseInt(b.replace('Week ', ''));
      });
      const sortedWeeksObj = {};
      sortedWeekNumbers.forEach(week => {
        sortedWeeksObj[week] = finalGrouped[groupName][week];
      });
      finalGrouped[groupName] = sortedWeeksObj;
    });

    return finalGrouped;
  }, [fixtures]);


  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        Loading fixtures...
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex justify-center items-center min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-red-500">Error: {error}</p>
      </div>
    );
  }

  return (
    <div className="flex flex-col min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className={`bg-red-600 text-white p-4 font-bold text-lg flex flex-wrap justify-around sm:flex-nowrap`}>
        <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors hidden md:block">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors hidden md:block">KNOCKOUT</Link>
        {/* Add responsive navigation for other pages if needed for small screens */}
      </div>

      <div className="p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full">
        <h2 className="text-2xl sm:text-3xl font-bold mb-6 text-center text-gray-800 dark:text-white">
          üìÖ Fixtures: {tournamentDetails?.name || 'Loading...'}
        </h2>

        {!isViewOnly && (
          <div className="flex flex-col sm:flex-row justify-center items-center gap-4 mb-6">
            <button
              onClick={handleGenerateFixtures}
              className="bg-green-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
            >
              Generate Fixtures
            </button>
            <button
              onClick={() => setIsAddingFixture(!isAddingFixture)}
              className="bg-blue-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
            >
              {isAddingFixture ? 'Hide Add Fixture Form' : '‚ûï Add New Fixture'}
            </button>
            <button
              onClick={handleClearAllFixtures}
              className="bg-red-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
            >
              Clear All Fixtures
            </button>
          </div>
        )}

        {isAddingFixture && !isViewOnly && (
          <div className="mb-8 p-6 bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700">
            <h3 className="text-xl font-bold mb-4 text-center">Add New Fixture</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">
              <div>
                <label htmlFor="teamA" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Team A</label>
                <select
                  id="teamA"
                  value={newFixture.teamA}
                  onChange={(e) => setNewFixture({ ...newFixture, teamA: e.target.value })}
                  className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="" disabled>Select Team A</option>
                  {teams.map((team) => (
                    <option key={team.id} value={team.name}>{team.name}</option>
                  ))}
                </select>
              </div>
              <div>
                <label htmlFor="teamB" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Team B</label>
                <select
                  id="teamB"
                  value={newFixture.teamB}
                  onChange={(e) => setNewFixture({ ...newFixture, teamB: e.target.value })}
                  className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="" disabled>Select Team B</option>
                  {teams.map((team) => (
                    <option key={team.id} value={team.name}>{team.name}</option>
                  ))}
                </select>
              </div>
              <div>
                <label htmlFor="date" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Date</label>
                <input
                  type="date"
                  id="date"
                  value={newFixture.date}
                  onChange={(e) => setNewFixture({ ...newFixture, date: e.target.value })}
                  className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>
            {fixtureError && <p className="text-red-500 text-center mb-4">{fixtureError}</p>}
            <button
              onClick={handleAddFixture}
              className="w-full bg-green-500 text-white px-6 py-3 rounded-lg shadow-md hover:bg-green-600 transition-colors duration-200 font-semibold text-base"
            >
              Add Fixture
            </button>
          </div>
        )}

        {fixtures.length === 0 ? (
          <p className="text-center text-gray-500 dark:text-gray-400 text-lg mt-8">No fixtures found. Generate or add some!</p>
        ) : (
          <div className="space-y-8 mt-8">
            {Object.keys(groupedFixtures).map(groupName => (
              <div key={groupName} className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl">
                <h3 className="text-xl sm:text-2xl font-bold mb-6 text-center text-gray-800 dark:text-white">
                  {groupName !== 'Ungrouped' ? `Group ${groupName}` : 'Ungrouped Fixtures'}
                </h3>
                {Object.keys(groupedFixtures[groupName]).map(week => (
                  <div key={`${groupName}-${week}`} className="mb-8">
                    <h4 className="text-lg sm:text-xl font-semibold mb-4 text-gray-700 dark:text-gray-300 text-center">{week}</h4>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                      {groupedFixtures[groupName][week].map((fixture) => (
                        <div
                          key={fixture.id}
                          className="bg-gray-50 dark:bg-gray-700 p-6 rounded-lg shadow-md flex flex-col justify-between transition-transform transform hover:scale-[1.02] border border-gray-200 dark:border-gray-600"
                        >
                          <div>
                            <p className="text-sm text-gray-500 dark:text-gray-300 mb-2">{fixture.date}</p>
                            <div className="flex justify-between items-center text-lg font-semibold mb-4">
                              <span>{fixture.teamA}</span>
                              <span className="mx-2">vs</span>
                              <span>{fixture.teamB}</span>
                            </div>
                            <div className="text-center text-2xl font-bold mb-4">
                              {fixture.status === 'completed' ? (
                                <span className="text-green-600 dark:text-green-400">
                                  {fixture.scoreA} - {fixture.scoreB}
                                </span>
                              ) : (
                                <span className="text-yellow-600 dark:text-yellow-400">
                                  Scheduled
                                </span>
                              )}
                            </div>
                          </div>
                          {!isViewOnly && (
                            <div className="flex flex-col sm:flex-row gap-3 mt-4">
                              <button
                                onClick={() => handleOpenScoreModal(fixture)}
                                className="flex-1 bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 transition-colors font-semibold"
                              >
                                Update Score
                              </button>
                              <button
                                onClick={() => handleDeleteFixture(fixture.id)}
                                className="flex-1 bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600 transition-colors font-semibold"
                              >
                                Delete
                              </button>
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Custom Modal */}
      <Modal
        isOpen={customModalOpen}
        onClose={closeCustomModal}
        onConfirm={customModalOnConfirm}
        title={customModalTitle}
        message={customModalMessage}
        showConfirmButton={customModalOnConfirm !== null && customModalShowConfirm}
        confirmText="Confirm"
        cancelText="Close"
      />

      {/* Score Input Modal */}
      {editingFixture && (
        <Modal
          isOpen={scoreModalOpen}
          onClose={handleCloseScoreModal}
          onConfirm={handleUpdateScore}
          title={`Update Score for ${editingFixture.teamA} vs ${editingFixture.teamB}`}
          confirmText="Save Score"
        >
          <ScoreInputModalContent
            ref={scoreInputRef}
            fixture={editingFixture}
            initialScoreA={editingFixture.scoreA}
            initialScoreB={editingFixture.scoreB}
          />
        </Modal>
      )}
    </div>
  );
}


--- END FILE: src\pages\FixturesPage.jsx ---

--- START FILE: src\pages\KnockoutPage.jsx ---

// src/pages/KnockoutPage.jsx
import React, { useEffect, useState, useCallback, useRef, useMemo } from 'react';
import { useParams, Link, useSearchParams } from 'react-router-dom';
import { db } from '../firebase';
import { doc, getDoc, collection, addDoc, query, orderBy, onSnapshot, updateDoc, deleteDoc, writeBatch, getDocs, where } from 'firebase/firestore';
import { useAuth } from '../hooks/useAuth'; // Assuming useAuth is in this path

// --- Helper Components (Defined within the same file for simplicity) ---

// Modal Component
const Modal = ({ isOpen, onClose, onConfirm, title, message, children, showConfirmButton }) => {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-11/12 max-w-lg mx-auto transform transition-all duration-300 scale-100 opacity-100">
                <div className="flex justify-between items-center border-b pb-3 mb-4 border-gray-200 dark:border-gray-700">
                    <h3 className="text-xl font-bold text-gray-900 dark:text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-semibold">&times;</button>
                </div>
                <div className="text-gray-700 dark:text-gray-300 mb-6">
                    {message && <p className="mb-4">{message}</p>}
                    {children}
                </div>
                <div className="flex justify-end gap-3">
                    <button
                        onClick={onClose}
                        className="px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
                    >
                        Cancel
                    </button>
                    {showConfirmButton && onConfirm && (
                        <button
                            onClick={onConfirm}
                            className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
                        >
                            Confirm
                        </button>
                    )}
                </div>
            </div>
        </div>
    );
};

// Score Input Modal Content Component
const ScoreInputModalContent = React.forwardRef(({ fixture, initialScoreA, initialScoreB }, ref) => {
    const [scoreA, setScoreA] = useState(initialScoreA ?? '');
    const [scoreB, setScoreB] = useState(initialScoreB ?? '');

    // Expose methods to parent component via ref
    React.useImperativeHandle(ref, () => ({
        getScoreA: () => scoreA,
        getScoreB: () => scoreB,
    }));

    return (
        <div className="flex flex-col gap-4 p-4">
            <div className="flex items-center justify-between gap-4">
                <span className="font-semibold text-lg text-gray-900 dark:text-white">{fixture.teamA}</span>
                <input
                    type="number"
                    value={scoreA}
                    onChange={(e) => setScoreA(e.target.value)}
                    className="w-20 p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 text-center text-lg"
                    min="0"
                />
            </div>
            <div className="flex items-center justify-between gap-4">
                <span className="font-semibold text-lg text-gray-900 dark:text-white">{fixture.teamB}</span>
                <input
                    type="number"
                    value={scoreB}
                    onChange={(e) => setScoreB(e.target.value)}
                    className="w-20 p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 text-center text-lg"
                    min="0"
                />
            </div>
        </div>
    );
});


// --- KnockoutPage Component ---
const KnockoutPage = () => { // Corrected syntax for component definition
    const { id: tournamentId } = useParams();
    const [searchParams] = useSearchParams();
    const shareId = searchParams.get('shareId'); // Get the shareId from the URL
    const { user, loading: authLoading } = useAuth(); // Corrected useAuth import
    const [tournamentName, setTournamentName] = useState('Loading...');
    const [matches, setMatches] = useState([]); // Renamed from 'rounds' to 'matches' for clarity
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [tournamentOwnerId, setTournamentOwnerId] = useState(null);
    const [tournamentDetails, setTournamentDetails] = useState(null); // New state for tournament details

    const [isAddingMatch, setIsAddingMatch] = useState(false);
    const [newMatch, setNewMatch] = useState({
        round: '',
        teamA: '',
        teamB: '',
        winner: null,
        scoreA: null, // Use null initially for scores
        scoreB: null,
        status: 'scheduled'
    });

    const [modalOpen, setModalOpen] = useState(false);
    const [modalTitle, setModalTitle] = useState('');
    const [modalMessage, setModalMessage] = useState('');
    const [modalShowConfirmButton, setModalShowConfirmButton] = useState(true); // Default to true
    const [modalContent, setModalContent] = useState(null);
    const [modalConfirmAction, setModalConfirmAction] = useState(null);
    const scoreInputRef = useRef(null);

    const [teams, setTeams] = useState([]); // New state to fetch all teams for selection

    // Refs for SVG drawing
    const matchRefs = useRef(new Map()); // Stores refs for each match box (key: match.id, value: DOM element)
    const svgContainerRef = useRef(null); // Ref for the div that wraps all round columns, for relative positioning
    const [svgLines, setSvgLines] = useState([]); // State to store SVG path data

    const openModal = useCallback((title, message, showConfirm, content = null, confirmAction = null) => {
        setModalTitle(title);
        setModalMessage(message);
        setModalShowConfirmButton(showConfirm);
        setModalContent(content);
        setModalConfirmAction(() => confirmAction); // <--- Set the confirm action here
        setModalOpen(true);
    }, []);

    const closeModal = useCallback(() => {
        setModalOpen(false);
        setModalTitle('');
        setModalMessage('');
        setModalShowConfirmButton(true);
        setModalContent(null);
        setModalConfirmAction(null); // Clear confirm action on close
    }, []);

    // Determine if the current user has view-only access
    const isViewOnly = useMemo(() => {
        // If shareId is present, OR if user is not logged in AND tournament is public
        return (!!shareId) || (!user && (tournamentDetails?.isPublic || false));
    }, [shareId, user, tournamentDetails]);


    useEffect(() => {
        const fetchData = async () => {
            if (authLoading) return; // Wait for Firebase auth to load

            if (!tournamentId) {
                setError("No tournament ID provided.");
                setLoading(false);
                return;
            }

            try {
                // Fetch tournament details to get name, owner ID, and type
                const tournamentDocRef = doc(db, 'tournaments', tournamentId);
                const tournamentSnap = await getDoc(tournamentDocRef);

                if (tournamentSnap.exists()) {
                    const data = tournamentSnap.data();
                    setTournamentName(data.name);
                    setTournamentOwnerId(data.userId);
                    setTournamentDetails(data); // Store full tournament details
                    // The isViewOnly state will be re-calculated by its useMemo based on tournamentDetails
                } else {
                    setError("Tournament not found.");
                    setLoading(false);
                    return;
                }

                // Set up real-time listener for knockout matches
                const matchesCollectionRef = collection(db, `tournaments/${tournamentId}/knockoutMatches`);
                // Order by round (e.g., "Quarter-Finals", "Semi-Finals") and then by teamA name for consistent display
                // Ensure 'roundOrder' is properly set in your matches, e.g., 0 for R32, 1 for R16, 2 for QF, 3 for SF, 4 for Final
                const q = query(matchesCollectionRef, orderBy('roundOrder', 'asc'), orderBy('teamA', 'asc')); 

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const fetchedMatches = snapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data(),
                        scoreA: doc.data().scoreA ?? null, // Ensure scores are null if not set
                        scoreB: doc.data().scoreB ?? null,
                    }));
                    setMatches(fetchedMatches);
                    setLoading(false);
                    setError(null); // Clear any previous errors if data loads successfully
                }, (err) => {
                    console.error('Real-time listener error for knockout matches:', err);
                    setError('Failed to load knockout matches. Please try again.');
                    setLoading(false);
                });

                // Set up real-time listener for teams to populate dropdowns
                const teamsCollectionRef = collection(db, `tournaments/${tournamentId}/teams`);
                const unsubscribeTeams = onSnapshot(query(teamsCollectionRef, orderBy('name', 'asc')), (snapshot) => {
                    setTeams(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                }, (err) => {
                    console.error('Real-time listener error for teams:', err);
                });

                return () => {
                    unsubscribe(); // Cleanup knockout matches listener
                    unsubscribeTeams(); // Cleanup teams listener
                };

            } catch (err) {
                console.error("Error fetching tournament data:", err);
                setError("Failed to load tournament data.");
                setLoading(false);
            }
        };

        fetchData();
    }, [tournamentId, user, authLoading, shareId, tournamentDetails?.isPublic]);


    // Utility to get round name and order based on the number of teams *in that round*
    // For example, 2 teams for Final, 4 for Semi-Finals (i.e., 2 matches), etc.
    const getRoundDetails = useCallback((numTeamsInRound) => {
        if (numTeamsInRound <= 0) return { name: 'Unknown', order: 99 };
        // The numTeamsInRound refers to the number of *teams* competing in that specific round.
        // e.g., for 8 teams total, it's Round of 8 (Quarter-Finals).
        // For 4 teams total, it's Round of 4 (Semi-Finals).
        // This makes it simpler for calculating the next round based on winners.
        switch (numTeamsInRound) {
            case 2: return { name: 'Final', order: 4 };
            case 4: return { name: 'Semi-Finals', order: 3 };
            case 8: return { name: 'Quarter-Finals', order: 2 };
            case 16: return { name: 'Round of 16', order: 1 };
            case 32: return { name: 'Round of 32', order: 0 };
            default: return { name: `Round of ${numTeamsInRound}`, order: 99 };
        }
    }, []);

    // Group matches by round for display
    const groupedRounds = useMemo(() => {
        return matches.reduce((acc, match) => {
            const roundName = match.round || 'Unnamed Round';
            if (!acc[roundName]) {
                acc[roundName] = [];
            }
            acc[roundName].push(match);
            return acc;
        }, {});
    }, [matches]);

    // Sort round names for consistent display order
    const sortedRoundNames = useMemo(() => {
        return Object.keys(groupedRounds).sort((a, b) => {
            // Find the order of the *current round* based on how many matches are in it.
            // The length of the array `groupedRounds[a]` gives the number of matches in that round.
            // Each match involves 2 teams, so `length * 2` gives the total teams that started that round.
            const orderA = getRoundDetails(groupedRounds[a].length * 2).order;
            const orderB = getRoundDetails(groupedRounds[b].length * 2).order;
            return orderA - orderB;
        });
    }, [groupedRounds, getRoundDetails]);

    // New function to automatically determine qualifying teams and generate the initial bracket
    const generateAutomaticInitialBracket = async () => {
        if (!tournamentDetails || isViewOnly || user?.uid !== tournamentOwnerId) {
            openModal('Access Denied', 'You do not have permission to generate brackets.', false);
            return;
        }

        if (tournamentDetails.type !== 'Multi-Phase') {
            openModal('Not a Multi-Phase Tournament', 'Automatic bracket generation is only available for Multi-Phase tournaments.', false);
            return;
        }
        
        const numQualifiersPerGroup = tournamentDetails.qualifiersPerGroup || 0;
        const definedGroups = tournamentDetails.groups || [];

        if (numQualifiersPerGroup <= 0) {
            openModal('Invalid Qualifiers Setting', 'Please set the "Teams to Qualify Per Group" in Tournament Settings to a number greater than 0.', false);
            return;
        }

        if (definedGroups.length === 0) {
            openModal('Missing Groups', 'No groups defined for this Multi-Phase tournament. Please define groups (e.g., Group A, Group B) in Tournament Settings first.', false);
            return;
        }

        const qualifiedTeamsFromGroups = [];
        let hasUncompletedGroupFixtures = false;

        for (const groupName of definedGroups) {
            // Fetch leaderboard data for this specific group
            const leaderboardQuery = query(
                collection(db, `tournaments/${tournamentId}/leaderboard`),
                where('group', '==', groupName), // Assuming leaderboard docs have a 'group' field
                orderBy('points', 'desc'),
                orderBy('goalDifference', 'desc'),
                orderBy('goalsFor', 'desc')
            );
            const leaderboardSnap = await getDocs(leaderboardQuery);
            const groupStandings = leaderboardSnap.docs.map(doc => doc.data());

            // Check if all fixtures for this group are completed
            const groupFixturesQuery = query(
                collection(db, `tournaments/${tournamentId}/fixtures`),
                where('groupId', '==', groupName)
            );
            const groupFixturesSnap = await getDocs(groupFixturesQuery);
            const allGroupFixtures = groupFixturesSnap.docs.map(doc => doc.data());
            const completedGroupFixtures = allGroupFixtures.filter(f => f.status === 'completed');

            if (completedGroupFixtures.length < allGroupFixtures.length) {
                hasUncompletedGroupFixtures = true;
                break; // Exit early if any group has uncompleted fixtures
            }


            // Take top N from each group
            const topTeamsInGroup = groupStandings.slice(0, numQualifiersPerGroup);
            if (topTeamsInGroup.length < numQualifiersPerGroup) {
                 openModal('Not Enough Qualified Teams', `Group "${groupName}" does not have enough teams or completed matches to qualify ${numQualifiersPerGroup} teams. Ensure all group matches are played and enough teams are present.`, false);
                 return;
            }
            qualifiedTeamsFromGroups.push(...topTeamsInGroup.map(team => ({ id: team.id, name: team.name })));
        }

        if (hasUncompletedGroupFixtures) {
            openModal('Uncompleted Group Fixtures', 'Some group stage matches are not yet completed. Please complete all group stage fixtures before generating the knockout bracket.', false);
            return;
        }


        if (qualifiedTeamsFromGroups.length < 2) {
            openModal('Not Enough Qualifiers', 'Not enough teams qualified from the group stage to generate a bracket. Ensure teams have completed matches in groups and your qualification settings are correct.', false);
            return;
        }

        const bracketSize = qualifiedTeamsFromGroups.length;
        if (![2, 4, 8, 16, 32].includes(bracketSize)) {
            openModal('Invalid Qualification Count', `The total number of qualified teams (${bracketSize}) is not a valid bracket size (2, 4, 8, 16, 32). Please adjust your "Teams to Qualify Per Group" setting or the number of groups to form a valid bracket.`, false);
            return;
        }

        const initialRoundDetails = getRoundDetails(bracketSize);
        // Check if knockout matches already exist (to prevent re-generating if not needed)
        const existingKnockoutMatchesQuery = query(collection(db, `tournaments/${tournamentId}/knockoutMatches`));
        const existingKnockoutMatchesSnap = await getDocs(existingKnockoutMatchesQuery);
        if (!existingKnockoutMatchesSnap.empty) {
            openModal('Bracket Already Exists', 'A knockout bracket already exists. If you wish to re-generate, please delete existing knockout matches manually first.', false);
            return;
        }


        openModal(
            'Confirm Automatic Bracket Generation',
            `This will generate a new ${bracketSize}-team knockout bracket starting with ${initialRoundDetails.name} based on the top ${numQualifiersPerGroup} teams from each group. Are you sure?`,
            true,
            null,
            async () => {
                try {
                    const batch = writeBatch(db);
                    const matchesCollectionRef = collection(db, `tournaments/${tournamentId}/knockoutMatches`);

                    // Shuffle teams to randomize initial pairings
                    const shuffledTeams = [...qualifiedTeamsFromGroups].sort(() => Math.random() - 0.5);

                    // Create initial round matches
                    for (let i = 0; i < shuffledTeams.length; i += 2) {
                        const newMatchRef = doc(matchesCollectionRef); // Let Firestore auto-generate ID
                        batch.set(newMatchRef, {
                            round: initialRoundDetails.name,
                            roundOrder: initialRoundDetails.order,
                            teamA: shuffledTeams[i].name,
                            teamB: shuffledTeams[i + 1].name,
                            winner: null,
                            scoreA: null,
                            scoreB: null,
                            status: 'scheduled'
                        });
                    }

                    await batch.commit();
                    closeModal();
                    openModal('Success', `Successfully generated ${bracketSize}-team knockout bracket automatically!`, false);
                } catch (err) {
                    console.error('Error generating automatic knockout bracket:', err);
                    openModal('Error', 'Failed to generate automatic knockout bracket. Please try again.', false);
                }
            }
        );
    };


    // Handle adding a new knockout match (for manual entry)
    const handleAddMatch = async () => {
        if (!tournamentDetails || isViewOnly || user?.uid !== tournamentOwnerId) {
            openModal('Access Denied', 'You do not have permission to add matches.', false);
            return;
        }
        if (!newMatch.round.trim() || !newMatch.teamA.trim() || !newMatch.teamB.trim()) {
            openModal('Validation Error', 'Please fill in all match details.', false);
            return;
        }
        // Assign a dummy round order for manual matches, or ask user for it
        // For simplicity, let's assign a very high order so they appear last or outside the main flow
        const manualRoundOrder = 100; 
        try {
            await addDoc(collection(db, `tournaments/${tournamentId}/knockoutMatches`), {
                ...newMatch,
                roundOrder: manualRoundOrder, 
                scoreA: null, 
                scoreB: null,
                status: 'scheduled'
            });
            setNewMatch({ round: '', teamA: '', teamB: '', winner: null, scoreA: null, scoreB: null, status: 'scheduled' });
            setIsAddingMatch(false); // Hide the form after successful addition
            openModal('Success', 'Match added successfully!', false);
        } catch (err) {
            console.error('Error adding match:', err);
            openModal('Error', 'Failed to add match. Please try again.', false);
        }
    };

    // Handle updating scores for an existing knockout match
    const handleUpdateScores = useCallback(async (matchToEdit) => {
        if (!tournamentDetails || isViewOnly || user?.uid !== tournamentOwnerId) {
            openModal('Access Denied', 'You do not have permission to update scores.', false);
            return;
        }

        const confirmAction = async () => {
            if (!scoreInputRef.current) {
                openModal('Error', 'Internal error: Cannot read scores. Please try again.', false);
                return;
            }
            const scoreA = scoreInputRef.current.getScoreA();
            const scoreB = scoreInputRef.current.getScoreB();

            const parsedScoreA = parseInt(scoreA);
            const parsedScoreB = parseInt(scoreB);

            if (isNaN(parsedScoreA) || isNaN(parsedScoreB)) {
                openModal('Invalid Input', 'Please enter valid numbers for scores.', true,
                    <ScoreInputModalContent
                        ref={scoreInputRef}
                        fixture={matchToEdit}
                        initialScoreA={scoreA} // Pass back current input values
                        initialScoreB={scoreB}
                    />,
                    () => confirmAction() // Pass confirmAction itself for re-attempt
                );
                return;
            }

            let winner = null;
            if (parsedScoreA > parsedScoreB) {
                winner = matchToEdit.teamA;
            } else if (parsedScoreB > parsedScoreA) {
                winner = matchToEdit.teamB;
            } else {
                winner = 'Draw'; // Or handle tie-breaker for knockouts
                openModal('Draw in Knockout', 'A draw is not typically allowed in knockout matches. Please ensure one team is declared a winner (e.g., via penalty shootout).', false);
                return;
            }

            try {
                const matchRef = doc(db, `tournaments/${tournamentId}/knockoutMatches`, matchToEdit.id);
                await updateDoc(matchRef, {
                    scoreA: parsedScoreA,
                    scoreB: parsedScoreB,
                    status: 'completed',
                    winner: winner
                });
                closeModal();
                openModal('Success', 'Score updated successfully!', false);
            } catch (err) {
                console.error('Error updating scores:', err);
                openModal('Error', 'Failed to update scores. Please try again.', true,
                    <ScoreInputModalContent
                        ref={scoreInputRef}
                        fixture={matchToEdit}
                        initialScoreA={scoreA}
                        initialScoreB={scoreB}
                    />,
                    () => confirmAction() // Pass confirmAction itself for re-attempt
                );
            }
        };

        openModal(
            'Update Match Scores',
            `Enter scores for ${matchToEdit.teamA} vs ${matchToEdit.teamB}:`,
            true, // showConfirmButton
            <ScoreInputModalContent
                ref={scoreInputRef}
                fixture={matchToEdit}
                initialScoreA={matchToEdit.scoreA}
                initialScoreB={matchToEdit.scoreB}
            />,
            confirmAction // <--- Pass the confirm action here
        );
    }, [isViewOnly, user, tournamentOwnerId, openModal, closeModal, tournamentId, tournamentDetails]);


    // Handle deleting a knockout match
    const handleDeleteMatch = async (matchId) => {
        if (!tournamentDetails || isViewOnly || user?.uid !== tournamentOwnerId) {
            openModal('Access Denied', 'You do not have permission to delete matches.', false);
            return;
        }

        const confirmDeleteAction = async () => {
            try {
                await deleteDoc(doc(db, `tournaments/${tournamentId}/knockoutMatches`, matchId));
                closeModal();
                openModal('Success', 'Match deleted successfully!', false);
            } catch (err) {
                console.error('Error deleting match:', err);
                openModal('Error', 'Failed to delete match. Please try again.', false);
            }
        };

        openModal('Confirm Delete', 'Are you sure you want to delete this match?', true, null, confirmDeleteAction);
    };

    // New: Seed Next Round Functionality
    const handleSeedNextRound = async () => {
        if (!tournamentDetails || isViewOnly || user?.uid !== tournamentOwnerId) {
            openModal('Access Denied', 'You do not have permission to seed the next round.', false);
            return;
        }

        // Find the latest completed round
        const completedMatches = matches.filter(m => m.status === 'completed' && m.winner !== null && m.winner !== 'Draw');
        if (completedMatches.length === 0) {
            openModal('No Completed Matches', 'No matches have been completed to seed the next round. Complete matches in the current round first.', false);
            return;
        }

        // Group completed matches by round to find the latest round
        const completedMatchesByRound = completedMatches.reduce((acc, match) => {
            if (!acc[match.roundOrder]) {
                acc[match.roundOrder] = [];
            }
            acc[match.roundOrder].push(match);
            return acc;
        }, {});

        const sortedCompletedRoundOrders = Object.keys(completedMatchesByRound).map(Number).sort((a, b) => a - b);
        const latestCompletedRoundOrder = sortedCompletedRoundOrders[sortedCompletedRoundOrders.length - 1];
        const matchesInLatestRound = completedMatchesByRound[latestCompletedRoundOrder];

        if (matchesInLatestRound.length % 2 !== 0) {
            openModal('Invalid Round State', 'The number of winners in the last round is odd. Cannot seed next round. Ensure all matches in the current round have a winner and there is an even number of winners.', false);
            return;
        }

        const winners = matchesInLatestRound.map(m => m.winner).filter(Boolean);
        if (winners.length === 0) {
            openModal('No Winners', 'No winners found in the latest completed round to seed the next round.', false);
            return;
        }
        
        // Check if the next round already has matches for these winners.
        // This is important to prevent duplicate seeding.
        // Get details of the next round.
        const nextRoundOrder = latestCompletedRoundOrder + 1;
        const nextRoundDetails = getRoundDetails(winners.length); // Calculate based on winners count
        const nextRoundName = nextRoundDetails.name;

        // Check if matches for the next round (with current winners) already exist.
        const existingNextRoundMatchesQuery = query(
            collection(db, `tournaments/${tournamentId}/knockoutMatches`),
            where('roundOrder', '==', nextRoundOrder)
        );
        const existingNextRoundMatchesSnap = await getDocs(existingNextRoundMatchesQuery);
        if (!existingNextRoundMatchesSnap.empty) {
             openModal('Next Round Already Seeded', `Matches for the "${nextRoundName}" round already exist.`, false);
             return;
        }


        openModal(
            'Confirm Seed Next Round',
            `This will create new matches for the "${nextRoundName}" round based on winners from the previous round. Are you sure?`,
            true,
            null,
            async () => {
                try {
                    const batch = writeBatch(db);
                    const matchesCollectionRef = collection(db, `tournaments/${tournamentId}/knockoutMatches`);

                    const shuffledWinners = [...winners].sort(() => Math.random() - 0.5); // Randomize pairings for next round

                    for (let i = 0; i < shuffledWinners.length; i += 2) {
                        const newMatchRef = doc(matchesCollectionRef);
                        batch.set(newMatchRef, {
                            round: nextRoundName,
                            roundOrder: nextRoundOrder,
                            teamA: shuffledWinners[i],
                            teamB: shuffledWinners[i + 1],
                            winner: null,
                            scoreA: null,
                            scoreB: null,
                            status: 'scheduled'
                        });
                    }

                    await batch.commit();
                    closeModal();
                    openModal('Success', `Successfully seeded ${shuffledWinners.length / 2} matches for the ${nextRoundName} round!`, false);
                } catch (err) {
                    console.error('Error seeding next round:', err);
                    openModal('Error', 'Failed to seed next round. Please try again.', false);
                }
            }
        );
    };

    // Function to draw SVG lines that connect the bracket
    const drawBracketLines = useCallback(() => {
        const lines = [];
        if (!svgContainerRef.current) {
            setSvgLines([]); // Clear lines if container not ready
            return;
        }

        const containerRect = svgContainerRef.current.getBoundingClientRect();
        // Use container's position to make coordinates relative to the SVG.
        // The SVG is positioned absolutely inside svgContainerRef, so its top-left is (0,0) within that container.
        const offsetX = containerRect.left;
        const offsetY = containerRect.top;

        const getMatchRect = (id) => {
            const el = matchRefs.current.get(id);
            if (el) {
                const rect = el.getBoundingClientRect();
                return {
                    x: rect.left - offsetX,
                    y: rect.top - offsetY,
                    width: rect.width,
                    height: rect.height,
                    center_y: (rect.top - offsetY) + (rect.height / 2)
                };
            }
            return null;
        };

        // Constants for line drawing geometry
        // These values are tuned for the visual appearance in your screenshot
        const horizontalSegment1 = 20; // Length of the first horizontal line segment from match box
        // const horizontalSegment2 = 40; // Length of the horizontal line segment from vertical connector to next box (not directly used for fixed spacing in current drawing logic for next match)

        sortedRoundNames.forEach((roundName, roundIndex) => {
            const currentRoundMatches = groupedRounds[roundName];
            
            // Iterate over pairs of matches in the current round
            for (let i = 0; i < currentRoundMatches.length; i += 2) {
                const match1 = currentRoundMatches[i];
                const match2 = currentRoundMatches[i + 1]; // Can be undefined if odd number of matches

                const rect1 = getMatchRect(match1.id);
                const rect2 = match2 ? getMatchRect(match2.id) : null;

                // Only draw if at least the first match box is available
                if (!rect1) continue; 

                // Determine line color based on match status
                const areBothMatchesCompleted = match1.status === 'completed' && (!match2 || match2.status === 'completed');
                const lineStrokeColor = areBothMatchesCompleted
                                        ? '#22C55E' // Green-500 for completed bracket part
                                        : (document.documentElement.classList.contains('dark') ? '#4B5563' : '#9CA3AF'); // Gray-600 dark / Gray-400 light

                const startX = rect1.x + rect1.width; // Right edge of match1 (and match2 if it exists)
                const midY1 = rect1.center_y;          // Center Y of match1

                // X-coordinate where the vertical connector will be
                // It's usually halfway between the end of current box and start of next box's column,
                // but since the columns are dynamically positioned with flexbox, we can just use a fixed offset.
                const x_vertical_junction = startX + horizontalSegment1; 

                if (rect2) { // Standard pair of matches (like A vs B, C vs D in your image)
                    const midY2 = rect2.center_y;          // Center Y of match2

                    const winnerLineY = (midY1 + midY2) / 2; // Center Y for the line representing the winner

                    // Path 1: Horizontal line from match1 to vertical junction
                    lines.push({ 
                        d: `M ${startX} ${midY1} H ${x_vertical_junction}`, 
                        stroke: lineStrokeColor,
                    });

                    // Path 2: Horizontal line from match2 to vertical junction
                    lines.push({ 
                        d: `M ${startX} ${midY2} H ${x_vertical_junction}`, 
                        stroke: lineStrokeColor,
                    });
                    
                    // Path 3: Vertical line connecting the two horizontal lines
                    lines.push({ 
                        d: `M ${x_vertical_junction} ${midY1} V ${midY2}`, 
                        stroke: lineStrokeColor,
                    });

                    // Path 4: Line from the midpoint of the vertical connector, extending to the next round's match
                    // Only draw this if it's not the final round
                    if (roundIndex < sortedRoundNames.length - 1) {
                        const nextRoundName = sortedRoundNames[roundIndex + 1];
                        const nextRoundMatches = groupedRounds[nextRoundName];
                        const targetMatch = nextRoundMatches ? nextRoundMatches[Math.floor(i / 2)] : null; // The winner of this pair proceeds to this match

                        if (targetMatch) {
                            const targetRect = getMatchRect(targetMatch.id);
                            if (targetRect) {
                                const targetX = targetRect.x; // Left edge of the next match box
                                lines.push({ 
                                    d: `M ${x_vertical_junction} ${winnerLineY} H ${targetX}`, 
                                    stroke: lineStrokeColor,
                                });
                            }
                        } else {
                            // Fallback: if no target match (e.g., incomplete bracket or uneven matches), extend horizontally
                            // This scenario might happen if the bracket generation is incomplete or irregular.
                            lines.push({ 
                                d: `M ${x_vertical_junction} ${winnerLineY} H ${x_vertical_junction + horizontalSegment1}`, // extend a bit more
                                stroke: lineStrokeColor,
                            });
                        }
                    } else { // This is the final round, extend winner line
                        lines.push({ 
                            d: `M ${x_vertical_junction} ${winnerLineY} H ${x_vertical_junction + horizontalSegment1}`, 
                            stroke: lineStrokeColor,
                        });
                    }

                } else { // This case handles an unpaired match or the single final winner
                    // If it's the very last match in the whole bracket (the winner of the final)
                    if (roundIndex === sortedRoundNames.length - 1 && currentRoundMatches.length === 1) {
                         lines.push({ 
                            d: `M ${startX} ${midY1} H ${startX + horizontalSegment1}`, // Extend slightly to the right of the last box
                            stroke: lineStrokeColor,
                        });
                    } else {
                        // For any other unpaired match (shouldn't typically happen in a balanced bracket, but for robustness)
                        // Or if a match is standalone but not the final winner (e.g., 3rd place playoff)
                        lines.push({ 
                            d: `M ${startX} ${midY1} H ${x_vertical_junction + horizontalSegment1}`, 
                            stroke: lineStrokeColor,
                        });
                    }
                }
            }
        });
        setSvgLines(lines);
    }, [sortedRoundNames, groupedRounds]);

    // Effect to redraw lines on data change, window resize, or component updates
    useEffect(() => {
        // Debounce resize events for performance
        let resizeTimer;
        const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(drawBracketLines, 100); // 100ms debounce
        };
        
        window.addEventListener('resize', handleResize);

        // Also run once on mount and when relevant data changes
        // Use a small delay to ensure DOM elements (match boxes) have rendered and refs are populated
        // This is crucial for getBoundingClientRect to be accurate.
        const initialDrawTimer = setTimeout(drawBracketLines, 50); 

        return () => {
            clearTimeout(resizeTimer); // Clear any pending debounced calls on unmount
            clearTimeout(initialDrawTimer); // Clear initial draw timer too
            window.removeEventListener('resize', handleResize);
        };
    }, [matches, sortedRoundNames, groupedRounds, drawBracketLines]); // Depend on matches and memoized data for redraws


    const commonNavLinks = (
        <div className="bg-red-600 text-white p-4 font-bold text-lg flex flex-wrap justify-around sm:flex-nowrap">
            <Link to={isViewOnly ? `/tournament/${tournamentId}?shareId=${shareId}` : `/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">LEAGUE</Link>
            <Link to={isViewOnly ? `/tournament/${tournamentId}/fixtures?shareId=${shareId}` : `/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">FIXTURES</Link>
            <Link to={isViewOnly ? `/tournament/${tournamentId}/players?shareId=${shareId}` : `/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">TOP SCORERS</Link>
            <Link to={isViewOnly ? `/tournament/${tournamentId}/stats?shareId=${shareId}` : `/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">STATS</Link>
            <Link to={isViewOnly ? `/tournament/${tournamentId}/knockout?shareId=${shareId}` : `/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">KNOCKOUT</Link>
            <Link to={isViewOnly ? `/tournament/${tournamentId}/ai-prediction?shareId=${shareId}` : `/tournament/${tournamentId}/ai-prediction`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">AI PREDICTION</Link>
        </div>
    );

    // Group teams by their assigned group for display in the modal (though not used in this specific KnockoutPage UI)
    const groupedTeams = teams.reduce((acc, team) => {
        const group = team.group || 'Ungrouped';
        if (!acc[group]) {
            acc[group] = [];
        }
        acc[group].push(team);
        return acc;
    }, {});

    const sortedGroupNames = Object.keys(groupedTeams).sort((a, b) => {
        if (a === 'Ungrouped') return 1;
        if (b === 'Ungrouped') return -1;
        return a.localeCompare(b);
    });

    if (loading || authLoading) {
        return (
            <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
                {commonNavLinks}
                <div className="p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full">
                    <h2 className="text-xl sm:text-2xl font-bold mb-4 text-center">üèÜ Knockout Bracket ({tournamentName})</h2>
                    <p className="text-center text-gray-500 py-8">Loading knockout bracket...</p>
                </div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
                {commonNavLinks}
                <div className="p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full">
                    <h2 className="text-xl sm:text-2xl font-bold mb-4 text-center">üèÜ Knockout Bracket ({tournamentName})</h2>
                    <p className="text-center text-red-500 py-8">{error}</p>
                </div>
            </div>
        );
    }

    // Determine if the current user is the owner
    const isOwner = user && user.uid === tournamentOwnerId;

    return (
        <div className="flex flex-col min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
            {commonNavLinks}

            <div className="flex-grow p-4 sm:p-6 lg:p-8 w-full overflow-x-auto">
                <h2 className="text-2xl sm:text-3xl font-bold mb-6 text-center text-gray-900 dark:text-white">
                    üèÜ Knockout Bracket ({tournamentName})
                </h2>

                {/* Tournament Controls - only show if owner and not view only */}
                {!isViewOnly && isOwner && (
                    <div className="flex flex-col sm:flex-row justify-center items-center gap-4 mb-6">
                        {tournamentDetails && tournamentDetails.type === 'Multi-Phase' && (
                            <button
                                onClick={generateAutomaticInitialBracket} // Changed to new automatic function
                                className="bg-purple-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-purple-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
                            >
                                Generate Initial Bracket
                            </button>
                        )}
                        <button
                            onClick={handleSeedNextRound}
                            className="bg-green-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
                        >
                            Seed Next Round
                        </button>
                        <button
                            onClick={() => setIsAddingMatch(!isAddingMatch)}
                            className="bg-blue-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
                        >
                            {isAddingMatch ? 'Hide Add Match Form' : '‚ûï Add New Match'}
                        </button>
                    </div>
                )}


                {isAddingMatch && !isViewOnly && isOwner && (
                    <div className="mb-8 p-6 bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 max-w-2xl mx-auto">
                        <h3 className="text-xl font-bold mb-4 text-center text-gray-900 dark:text-white">Add New Knockout Match</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label htmlFor="roundName" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Round Name</label>
                                <input
                                    type="text"
                                    id="roundName"
                                    placeholder="e.g., Quarter-Finals"
                                    value={newMatch.round}
                                    onChange={e => setNewMatch({ ...newMatch, round: e.target.value })}
                                    className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                />
                            </div>
                            <div>
                                <label htmlFor="teamA" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Team A</label>
                                <input
                                    type="text"
                                    id="teamA"
                                    placeholder="Team A Name"
                                    value={newMatch.teamA}
                                    onChange={e => setNewMatch({ ...newMatch, teamA: e.target.value })}
                                    className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                />
                            </div>
                            <div>
                                <label htmlFor="teamB" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Team B</label>
                                <input
                                    type="text"
                                    id="teamB"
                                    placeholder="Team B Name"
                                    value={newMatch.teamB}
                                    onChange={e => setNewMatch({ ...newMatch, teamB: e.target.value })}
                                    className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                />
                            </div>
                            <div className="md:col-span-2 flex justify-center">
                                <button
                                    onClick={handleAddMatch}
                                    className="bg-green-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200 font-semibold text-base w-full max-w-xs"
                                >
                                    Create Match
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {matches.length === 0 ? (
                    <p className="text-center text-gray-500 dark:text-gray-400 text-lg py-10">
                        No knockout matches configured for this tournament yet.
                        {!isViewOnly && isOwner && " Use the 'Generate Initial Bracket' or 'Add New Match' button to create them."}
                    </p>
                ) : (
                    <div ref={svgContainerRef} className="relative flex justify-center flex-wrap md:flex-nowrap items-start w-full min-h-[400px]">
                        {/* SVG Overlay for drawing lines */}
                        <svg className="absolute inset-0 w-full h-full pointer-events-none z-0">
                            {svgLines.map((line, index) => (
                                <path 
                                    key={index} 
                                    d={line.d} 
                                    stroke={line.stroke} 
                                    strokeWidth="2" 
                                    fill="none" 
                                    strokeLinejoin="round" 
                                    strokeLinecap="round" 
                                />
                            ))}
                        </svg>

                        {sortedRoundNames.map((roundName, roundIndex) => (
                            <div key={roundName}
                                className={`
                                    round-column flex flex-col items-center flex-shrink-0
                                    min-w-[250px] md:min-w-[280px] lg:min-w-[320px]
                                    mx-2 md:mx-4
                                    py-4
                                `}
                            >
                                <h3 className="text-lg sm:text-xl font-semibold mb-6 text-gray-800 dark:text-gray-200 text-center sticky top-0 bg-inherit z-10 w-full py-2">
                                    {roundName}
                                </h3>
                                {/* Matches for this round */}
                                <div className="flex flex-col w-full">
                                    {groupedRounds[roundName].map((match, matchIndex) => (
                                        <div key={match.id} className="relative w-full mb-6"> {/* Increased mb for spacing between matches */}
                                            {/* Match Box */}
                                            <div
                                                ref={el => matchRefs.current.set(match.id, el)} // Store ref for SVG drawing
                                                className={`
                                                    match-box flex flex-col items-center text-center p-4 rounded-lg shadow-lg border-2
                                                    ${match.status === 'completed'
                                                        ? (match.winner && match.winner !== 'Draw' ? 'border-green-500 dark:border-green-500' : 'border-orange-500 dark:border-orange-500')
                                                        : 'border-gray-400 dark:border-gray-600'
                                                    }
                                                    bg-white dark:bg-gray-700 transition-colors duration-200 w-full relative z-10
                                                `}
                                            >
                                                <p className="font-bold text-gray-900 dark:text-white text-base sm:text-lg mb-1">{match.teamA}</p>
                                                <div className="w-full border-t border-gray-200 dark:border-gray-500 my-1"></div>
                                                <p className="font-bold text-gray-900 dark:text-white text-base sm:text-lg">{match.teamB}</p>
                                                
                                                {match.status === 'completed' && match.scoreA !== null && match.scoreB !== null ? (
                                                    <p className="mt-2 text-xl font-extrabold text-green-700 dark:text-green-300">
                                                        {match.scoreA} - {match.scoreB}
                                                    </p>
                                                ) : (
                                                    <p className="mt-2 text-base text-yellow-600 dark:text-yellow-400 font-medium">Scheduled</p>
                                                )}
                                                {match.winner && match.winner !== 'Draw' && (
                                                    <p className="mt-1 text-sm font-semibold text-blue-700 dark:text-blue-300">
                                                        Winner: {match.winner}
                                                        {roundIndex === sortedRoundNames.length -1 && (
                                                            <span className="ml-2 text-yellow-500 text-xl inline-block align-middle">üèÜ</span> // Trophy for the final winner
                                                        )}
                                                    </p>
                                                )}

                                                {!isViewOnly && isOwner && (
                                                    <div className="flex flex-col sm:flex-row gap-2 mt-3 w-full text-sm">
                                                        <button
                                                            onClick={() => handleUpdateScores(match)}
                                                            className="flex-1 bg-yellow-500 text-white px-2 py-1.5 rounded-md hover:bg-yellow-600 transition-colors"
                                                        >
                                                            Update
                                                        </button>
                                                        <button
                                                            onClick={() => handleDeleteMatch(match.id)}
                                                            className="flex-1 bg-red-500 text-white px-2 py-1.5 rounded-md hover:bg-red-600 transition-colors"
                                                        >
                                                            Delete
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>

            <Modal
                isOpen={modalOpen}
                onClose={closeModal}
                onConfirm={modalConfirmAction}
                title={modalTitle}
                message={modalMessage}
                showConfirmButton={modalShowConfirmButton}
            >
                {modalContent}
            </Modal>
        </div>
    );
}

export default KnockoutPage; // Ensure the main component is exported

--- END FILE: src\pages\KnockoutPage.jsx ---

--- START FILE: src\pages\LeaderboardPage.jsx ---

// src/pages/LeaderboardPage.jsx
import React, { useEffect, useState, useCallback } from 'react';
import { useParams, Link, useSearchParams } from 'react-router-dom';
import { db } from '../firebase';
import { collection, query, orderBy, onSnapshot, getDocs, doc, getDoc, writeBatch } from 'firebase/firestore';
import { useAuth } from '../hooks/useAuth';

export default function LeaderboardPage() {
  const { id: tournamentId } = useParams();
  const [searchParams] = useSearchParams();
  const shareId = searchParams.get('shareId');
  const { user, loading: authLoading } = useAuth();

  const [tournamentName, setTournamentName] = useState('Loading...');
  const [tournamentDetails, setTournamentDetails] = useState(null); // New state for tournament details
  const [leaderboardData, setLeaderboardData] = useState({}); // Changed to object to store data per group
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isViewOnly, setIsViewOnly] = useState(false);
  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);

  // Function to determine color for leaderboard rows
  const getRowColor = useCallback((index, teamRank, totalTeams) => {
    if (!tournamentDetails?.enableColors) return '';

    const promotion = parseInt(tournamentDetails.promotionSpots) || 0;
    const europe = parseInt(tournamentDetails.europeLeagueSpots) || 0;
    const relegation = parseInt(tournamentDetails.relegationSpots) || 0;

    // Promotion spots (top N)
    if (promotion > 0 && teamRank <= promotion) {
      return 'bg-green-100 dark:bg-green-900';
    }
    // Europe League spots (next N after promotion)
    if (europe > 0 && teamRank > promotion && teamRank <= (promotion + europe)) {
      return 'bg-blue-100 dark:bg-blue-900';
    }
    // Relegation spots (bottom N)
    if (relegation > 0 && teamRank > (totalTeams - relegation)) {
      return 'bg-red-100 dark:bg-red-900';
    }
    return '';
  }, [tournamentDetails]);

  // --- Effect to fetch Tournament Details and set view-only mode ---
  useEffect(() => {
    if (!tournamentId) {
      setError("No tournament ID provided.");
      setLoading(false);
      return;
    }

    const tournamentDocRef = doc(db, 'tournaments', tournamentId);
    const unsubscribeTournament = onSnapshot(tournamentDocRef, async (docSnap) => {
      if (docSnap.exists()) {
        const data = docSnap.data();
        setTournamentName(data.name);
        setTournamentDetails(data);
        setTournamentOwnerId(data.userId);

        const currentIsViewOnly = (!!shareId) || (!user && (data.isPublic || false));
        setIsViewOnly(currentIsViewOnly);
      } else {
        setError('Tournament not found.');
        setLoading(false);
      }
    }, (err) => {
      console.error('Error fetching tournament details:', err);
      setError('Failed to load tournament details.');
      setLoading(false);
    });

    return () => unsubscribeTournament();
  }, [tournamentId, shareId, user]);

  // --- Leaderboard Update Logic (now group-aware) ---
  const updateLeaderboard = useCallback(async () => {
    if (!tournamentId || !tournamentDetails || authLoading) {
      console.log('Skipping leaderboard update: Tournament data or auth loading.');
      return;
    }

    // Only allow owner to trigger updates, but viewers can see the result
    const canUpdate = user && user.uid === tournamentOwnerId;

    const teamsCollectionRef = collection(db, `tournaments/${tournamentId}/teams`);
    const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
    const leaderboardCollectionRef = collection(db, `tournaments/${tournamentId}/leaderboard`);

    try {
      const teamsSnapshot = await getDocs(teamsCollectionRef);
      const fixturesSnapshot = await getDocs(fixturesCollectionRef);

      const allTeams = teamsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      const allFixtures = fixturesSnapshot.docs.map(doc => doc.data());

      const pointsPerWin = tournamentDetails.pointsPerWin !== undefined ? tournamentDetails.pointsPerWin : 3;
      const pointsPerDraw = tournamentDetails.pointsPerDraw !== undefined ? tournamentDetails.pointsPerDraw : 1;

      const newLeaderboardData = {}; // Will hold stats grouped by groupName

      // Initialize team stats for all teams, grouped by their assigned group
      allTeams.forEach(team => {
        const group = team.group || 'Ungrouped'; // Default to 'Ungrouped' if no group assigned
        if (!newLeaderboardData[group]) {
          newLeaderboardData[group] = {};
        }
        newLeaderboardData[group][team.name] = {
          id: team.id,
          name: team.name,
          played: 0,
          wins: 0,
          draws: 0,
          losses: 0,
          goalsFor: 0,
          goalsAgainst: 0,
          goalDifference: 0,
          points: 0,
        };
      });

      // Process fixtures and update stats
      allFixtures.forEach(fixture => {
        if (fixture.status === 'completed') {
          const teamA = fixture.teamA;
          const teamB = fixture.teamB;
          const scoreA = Number(fixture.scoreA) || 0;
          const scoreB = Number(fixture.scoreB) || 0;
          const fixtureGroup = fixture.groupId || 'Ungrouped'; // Get group from fixture

          // Ensure teams exist in the current group's stats before updating
          if (newLeaderboardData[fixtureGroup] && newLeaderboardData[fixtureGroup][teamA]) {
            newLeaderboardData[fixtureGroup][teamA].played++;
            newLeaderboardData[fixtureGroup][teamA].goalsFor += scoreA;
            newLeaderboardData[fixtureGroup][teamA].goalsAgainst += scoreB;
          }
          if (newLeaderboardData[fixtureGroup] && newLeaderboardData[fixtureGroup][teamB]) {
            newLeaderboardData[fixtureGroup][teamB].played++;
            newLeaderboardData[fixtureGroup][teamB].goalsFor += scoreB;
            newLeaderboardData[fixtureGroup][teamB].goalsAgainst += scoreA;
          }

          if (scoreA > scoreB) {
            if (newLeaderboardData[fixtureGroup] && newLeaderboardData[fixtureGroup][teamA]) newLeaderboardData[fixtureGroup][teamA].wins++;
            if (newLeaderboardData[fixtureGroup] && newLeaderboardData[fixtureGroup][teamB]) newLeaderboardData[fixtureGroup][teamB].losses++;
          } else if (scoreB > scoreA) {
            if (newLeaderboardData[fixtureGroup] && newLeaderboardData[fixtureGroup][teamB]) newLeaderboardData[fixtureGroup][teamB].wins++;
            if (newLeaderboardData[fixtureGroup] && newLeaderboardData[fixtureGroup][teamA]) newLeaderboardData[fixtureGroup][teamA].losses++;
          } else { // Draw
            if (newLeaderboardData[fixtureGroup] && newLeaderboardData[fixtureGroup][teamA]) newLeaderboardData[fixtureGroup][teamA].draws++;
            if (newLeaderboardData[fixtureGroup] && newLeaderboardData[fixtureGroup][teamB]) newLeaderboardData[fixtureGroup][teamB].draws++;
          }
        }
      });

      const batch = writeBatch(db);
      const finalLeaderboardDisplay = {};

      // Calculate final points and sort teams within each group
      for (const groupName in newLeaderboardData) {
        const teamsInGroup = Object.values(newLeaderboardData[groupName]);
        teamsInGroup.forEach(stats => {
          stats.goalDifference = stats.goalsFor - stats.goalsAgainst;
          stats.points = (stats.wins * pointsPerWin) + (stats.draws * pointsPerDraw);

          // Only write to Firestore if the current user is the owner
          if (canUpdate) {
            const teamLeaderboardDocRef = doc(leaderboardCollectionRef, stats.id);
            batch.set(teamLeaderboardDocRef, stats, { merge: true });
          }
        });

        // Sort teams for display within this group
        teamsInGroup.sort((a, b) => {
          if (b.points !== a.points) return b.points - a.points;
          if (b.goalDifference !== a.goalDifference) return b.goalDifference - a.goalDifference;
          if (b.goalsFor !== a.goalsFor) return b.goalsFor - a.goalsFor;
          return a.name.localeCompare(b.name);
        });
        finalLeaderboardDisplay[groupName] = teamsInGroup;
      }

      // Commit batch if owner is updating
      if (canUpdate) {
        await batch.commit();
        console.log('Leaderboard updated successfully!');
      }

      setLeaderboardData(finalLeaderboardDisplay);
      setLoading(false);
      setError(null);
    } catch (err) {
      console.error('Error updating leaderboard:', err);
      setError('Failed to load leaderboard data.');
      setLoading(false);
    }
  }, [tournamentId, tournamentDetails, authLoading, user, tournamentOwnerId]);

  // Effect to trigger leaderboard update when tournament details or auth state changes
  // This ensures the leaderboard updates when the page loads and when relevant data changes.
  useEffect(() => {
    if (tournamentDetails && !authLoading) {
      updateLeaderboard();
    }
  }, [tournamentDetails, authLoading, updateLeaderboard]);


  const commonNavLinks = (
    <div className="bg-red-600 text-white p-4 font-bold text-lg flex flex-wrap justify-around sm:flex-nowrap">
      <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">LEAGUE</Link>
      <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">FIXTURES</Link>
      <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">TOP SCORERS</Link>
      <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">STATS</Link>
      <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">KNOCKOUT</Link>
      <Link to={`/tournament/${tournamentId}/ai-prediction`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">AI PREDICTION</Link>
    </div>
  );

  if (loading) {
    return (
      <div className="flex flex-col min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        {commonNavLinks}
        <div className="p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full">
          <h2 className="text-xl sm:text-2xl font-bold mb-4 text-center">üèÜ Leaderboard ({tournamentName})</h2>
          <p className="text-center text-gray-500 py-8">Loading leaderboard...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        {commonNavLinks}
        <div className="p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full">
          <h2 className="text-xl sm:text-2xl font-bold mb-4 text-center">üèÜ Leaderboard ({tournamentName})</h2>
          <p className="text-center text-red-500 py-8">{error}</p>
        </div>
      </div>
    );
  }

  const sortedGroupNames = Object.keys(leaderboardData).sort((a, b) => {
    if (a === 'Ungrouped') return 1;
    if (b === 'Ungrouped') return -1;
    return a.localeCompare(b);
  });

  return (
    <div className="flex flex-col min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
      {commonNavLinks}

      <div className="flex-grow p-4 sm:p-6 lg:p-8 w-full">
        <h2 className="text-2xl sm:text-3xl font-bold mb-6 text-center text-gray-800 dark:text-white">
          üèÜ Leaderboard: {tournamentName}
        </h2>

        {Object.keys(leaderboardData).length === 0 ? (
          <p className="text-center text-gray-500 dark:text-gray-400 text-lg mt-8">
            No leaderboard data available. Add teams and complete some fixtures!
          </p>
        ) : (
          <div className="space-y-10">
            {sortedGroupNames.map(groupName => (
              <div key={groupName} className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700">
                <h3 className="text-xl sm:text-2xl font-bold mb-6 text-center text-gray-800 dark:text-white">
                  {groupName !== 'Ungrouped' ? `Group ${groupName} Standings` : 'Overall Standings'}
                </h3>
                <div className="overflow-x-auto">
                  <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                    <thead className="bg-gray-50 dark:bg-gray-700">
                      <tr>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider rounded-tl-lg">Rank</th>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Team</th>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">P</th>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">W</th>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">D</th>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">L</th>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">GF</th>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">GA</th>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">GD</th>
                        <th className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider rounded-tr-lg">Pts</th>
                      </tr>
                    </thead>
                    <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                      {leaderboardData[groupName].map((team, index) => (
                        <tr key={team.id} className={`${getRowColor(index, index + 1, leaderboardData[groupName].length)} hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors`}>
                          <td className="px-3 py-4 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-white">{index + 1}</td>
                          <td className="px-3 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">{team.name}</td>
                          <td className="px-3 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-300">{team.played}</td>
                          <td className="px-3 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-300">{team.wins}</td>
                          <td className="px-3 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-300">{team.draws}</td>
                          <td className="px-3 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-300">{team.losses}</td>
                          <td className="px-3 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-300">{team.goalsFor}</td>
                          <td className="px-3 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-300">{team.goalsAgainst}</td>
                          <td className="px-3 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-300">{team.goalDifference}</td>
                          <td className="px-3 py-4 whitespace-nowrap text-sm font-bold text-gray-900 dark:text-white">{team.points}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}


--- END FILE: src\pages\LeaderboardPage.jsx ---

--- START FILE: src\pages\PlayerPage.jsx ---

import React, { useEffect, useState, useMemo, useCallback } from 'react';
import { db } from '../firebase';
import { collection, addDoc, onSnapshot, doc, deleteDoc, updateDoc, query, orderBy, getDoc, getDocs, writeBatch, where } from 'firebase/firestore';
import { useParams, Link } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';

// Custom Modal Component defined directly within this file for its specific use cases.
const Modal = ({ isOpen, message, confirmAction, cancelAction, inputRequired, inputLabel, inputValue, setInputValue }) => {
  if (!isOpen) return null;
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm text-center text-gray-900 dark:text-white">
        {message && <p className="text-lg font-semibold mb-4">{message}</p>}
        {inputRequired && (
          <div className="flex flex-col gap-2 mb-4">
            <input
              type="number"
              placeholder={inputLabel.trim()}
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              style={{ pointerEvents: 'auto', zIndex: 'auto' }}
            />
          </div>
        )}
        <div className="flex justify-center gap-4 mt-4">
          {confirmAction && (
            <button
              onClick={confirmAction}
              className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors"
            >
              Confirm
            </button>
          )}
          <button
            onClick={cancelAction}
            className="bg-gray-400 text-white px-4 py-2 rounded-md hover:bg-gray-500 transition-colors"
          >
            {confirmAction ? 'Cancel' : 'Close'}
          </button>
        </div>
      </div>
    </div>
  );
};

export default function PlayerPage() {
  const { id: tournamentId } = useParams();
  const { user, loading: authLoading } = useAuth();
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [loadingTournamentData, setLoadingTournamentData] = useState(true);
  const [error, setError] = useState(null);
  const [players, setPlayers] = useState([]);
  // matchStats is no longer needed as goals, assists, and MOTM are directly on player document
  // const [matchStats, setMatchStats] = useState([]);
  const [teams, setTeams] = useState([]);
  const [newPlayerName, setNewPlayerName] = useState('');
  const [newPlayerTeam, setNewPlayerTeam] = useState('');
  const [customNewTeamName, setCustomNewTeamName] = useState('');
  const [addPlayerError, setAddPlayerError] = useState('');
  const [showAddPlayerForm, setShowAddPlayerForm] = useState(false);

  // Custom Modal Component states (for this inline modal)
  const [modalOpen, setModalOpen] = useState(false);
  const [modalMessage, setModalMessage] = useState('');
  const [modalConfirmAction, setModalConfirmAction] = useState(null);
  const [modalInputRequired, setModalInputRequired] = useState(false);
  const [modalInputLabel, setModalInputLabel] = useState('');
  const [modalInputValue, setModalInputValue] = useState('');

  // ADDED: Sorting state for the player table
  const [sortConfig, setSortConfig] = useState({ key: 'totalGoals', direction: 'descending' });

  const openModal = useCallback((message, confirmAction = null, inputRequired = false, inputLabel = '', initialValue = '') => {
    setModalMessage(message);
    setModalConfirmAction(() => confirmAction);
    setModalInputRequired(inputRequired);
    setModalInputLabel(inputLabel);
    setModalInputValue(initialValue);
    setModalOpen(true);
  }, []);

  const handleModalConfirm = useCallback(() => {
    if (modalConfirmAction) {
      if (modalInputRequired) {
        modalConfirmAction(modalInputValue);
      } else {
        modalConfirmAction();
      }
    }
    setModalOpen(false);
    setModalInputValue('');
    setModalConfirmAction(null);
  }, [modalConfirmAction, modalInputRequired, modalInputValue]);

  const handleModalCancel = useCallback(() => {
    setModalOpen(false);
    setModalInputValue('');
    setModalConfirmAction(null);
  }, []);

  useEffect(() => {
    if (authLoading) {
      setLoadingTournamentData(true);
      return;
    }
    if (!user) {
      setError("You must be logged in to view tournament details.");
      setLoadingTournamentData(false);
      return;
    }
    if (!tournamentId) {
      setError("No tournament ID provided in the URL.");
      setLoadingTournamentData(false);
      return;
    }

    setLoadingTournamentData(true);
    setError(null);

    const fetchTournamentName = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);
        if (tournamentSnap.exists()) {
          const data = tournamentSnap.data();
          if (data.userId === user.uid) {
            setTournamentName(data.name);
          } else {
            setTournamentName('Access Denied');
            setError('You do not have permission to access this tournament.');
          }
        } else {
          setTournamentName('Tournament Not Found');
          setError('The requested tournament does not exist.');
        }
        setLoadingTournamentData(false);
      } catch (err) {
        console.error('Error fetching tournament name:', err);
        setTournamentName('Error');
        setError('Failed to load tournament details.');
        setLoadingTournamentData(false);
      }
    };

    fetchTournamentName();
  }, [tournamentId, user, authLoading]);

  useEffect(() => {
    if (authLoading || !user || !tournamentId || error) return;

    const playersCollectionRef = collection(db, `tournaments/${tournamentId}/players`);
    // Listen for changes to players, including their 'goals', 'assists', and 'manOfTheMatchCount' fields
    const unsubscribePlayers = onSnapshot(playersCollectionRef, (snapshot) => {
      const fetchedPlayers = snapshot.docs.map(doc => ({
        id: doc.id,
        // Ensure goals, assists, and manOfTheMatchCount are initialized to 0 if not present
        goals: doc.data().goals || 0,
        assists: doc.data().assists || 0,
        manOfTheMatchCount: doc.data().manOfTheMatchCount || 0,
        ...doc.data()
      }));
      setPlayers(fetchedPlayers);

      const uniqueTeams = [...new Set(fetchedPlayers.map(player => player.team))].sort((a, b) => a.localeCompare(b));
      setTeams(uniqueTeams);

      if (showAddPlayerForm && newPlayerTeam === '' && uniqueTeams.length > 0) {
        setNewPlayerTeam(uniqueTeams[0]);
      } else if (showAddPlayerForm && newPlayerTeam === '' && uniqueTeams.length === 0) {
        setNewPlayerTeam('_new_team_');
      }
    }, (err) => {
      console.error('Error fetching real-time players:', err);
      setError('Failed to load players. Please try again.');
    });

    // Removed fetchMatchStats as goals, assists, and manOfTheMatchCount are now directly on player document
    // and updated via direct editing on this page. If fixture-derived stats are needed elsewhere,
    // they should be fetched/calculated in a component that specifically deals with fixtures.

    return () => {
      unsubscribePlayers();
    };
  }, [tournamentId, user, authLoading, error, showAddPlayerForm, newPlayerTeam]); // Depend on showAddPlayerForm and newPlayerTeam to re-evaluate default team selection

  // Combine players with their total goals, assists, and man of the match counts
  const playersWithStats = useMemo(() => {
    return players.map(player => ({
      ...player,
      // totalGoals now directly comes from player.goals
      totalGoals: player.goals,
      // totalAssists now directly comes from player.assists
      totalAssists: player.assists,
      // manOfTheMatchCount now directly comes from player.manOfTheMatchCount
      manOfTheMatchCount: player.manOfTheMatchCount
    }));
  }, [players]); // Depend only on players as stats are now directly on player objects

  // Sort players based on sortConfig
  const sortedPlayers = useMemo(() => {
    let sortablePlayers = [...playersWithStats];
    if (sortConfig.key) {
      sortablePlayers.sort((a, b) => {
        const aValue = a[sortConfig.key];
        const bValue = b[sortConfig.key];

        if (typeof aValue === 'string' && typeof bValue === 'string') {
          return sortConfig.direction === 'ascending' ?
            aValue.localeCompare(bValue) :
            bValue.localeCompare(aValue);
        } else {
          // Handle undefined values by treating them as 0 for numerical sorting
          const numA = aValue === undefined ? 0 : aValue;
          const numB = bValue === undefined ? 0 : bValue;
          return sortConfig.direction === 'ascending' ?
            numA - numB :
            numB - numA;
        }
      });
    }
    return sortablePlayers;
  }, [playersWithStats, sortConfig]);

  const requestSort = useCallback((key) => {
    let direction = 'ascending';
    if (sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  }, [sortConfig]);

  const getSortIndicator = (key) => {
    if (sortConfig.key === key) {
      return sortConfig.direction === 'ascending' ? ' üîº' : ' üîΩ';
    }
    return '';
  };

  const handleAddPlayer = async (e) => {
    e.preventDefault();
    setAddPlayerError('');

    if (!newPlayerName.trim()) {
      setAddPlayerError('Player name cannot be empty.');
      return;
    }

    let teamToAdd = newPlayerTeam;
    if (newPlayerTeam === '_new_team_') {
      if (!customNewTeamName.trim()) {
        setAddPlayerError('New team name cannot be empty.');
        return;
      }
      teamToAdd = customNewTeamName.trim();
    }

    try {
      // Check if a player with the same name and team already exists
      const q = query(
        collection(db, `tournaments/${tournamentId}/players`),
        where('name', '==', newPlayerName.trim()),
        where('team', '==', teamToAdd)
      );
      const querySnapshot = await getDocs(q);
      if (!querySnapshot.empty) {
        setAddPlayerError(`Player '${newPlayerName.trim()}' already exists in team '${teamToAdd}'.`);
        return;
      }

      await addDoc(collection(db, `tournaments/${tournamentId}/players`), {
        name: newPlayerName.trim(),
        team: teamToAdd,
        goals: 0, // Initialize goals for the player
        assists: 0, // Initialize assists for the player
        manOfTheMatchCount: 0 // Initialize man of the match count
      });
      setNewPlayerName('');
      setCustomNewTeamName('');
      setNewPlayerTeam(teams.length > 0 ? teams[0] : '_new_team_');
      setShowAddPlayerForm(false); // Hide form after successful addition
    } catch (err) {
      console.error('Error adding player:', err);
      setAddPlayerError('Failed to add player. Please try again.');
    }
  };

  const handleEditGoals = useCallback((player) => {
    openModal(
      `Set goals for ${player.name}:`,
      (value) => updatePlayerStat(player.id, 'goals', parseInt(value) || 0),
      true,
      'Goals',
      String(player.totalGoals)
    );
  }, [openModal]);

  const handleEditAssists = useCallback((player) => {
    openModal(
      `Set assists for ${player.name}:`,
      (value) => updatePlayerStat(player.id, 'assists', parseInt(value) || 0),
      true,
      'Assists',
      String(player.totalAssists)
    );
  }, [openModal]);

  const handleEditMOTM = useCallback((player) => {
    openModal(
      `Set Man of the Match count for ${player.name}:`,
      (value) => updatePlayerStat(player.id, 'manOfTheMatchCount', parseInt(value) || 0),
      true,
      'MOTM Count',
      String(player.manOfTheMatchCount)
    );
  }, [openModal]);

  // Generic function to update any player stat (goals, assists, manOfTheMatchCount)
  const updatePlayerStat = async (playerId, field, value) => {
    try {
      const playerRef = doc(db, `tournaments/${tournamentId}/players`, playerId);
      await updateDoc(playerRef, { [field]: value });
    } catch (err) {
      console.error(`Error updating player ${field}:`, err);
      openModal(`Failed to update ${field}. Please try again.`);
    }
  };

  const handleDeletePlayer = useCallback((playerId, playerName) => {
    openModal(
      `Are you sure you want to delete ${playerName}? This action cannot be undone.`,
      async () => {
        try {
          const playerRef = doc(db, `tournaments/${tournamentId}/players`, playerId);
          await deleteDoc(playerRef);

          // No longer need to update fixtures for goals/assists as they are on player doc.
          // Still need to clear manOfTheMatchPlayerId from fixtures if the deleted player was MOTM.
          const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
          const q = query(fixturesCollectionRef,
            where('manOfTheMatchPlayerId', '==', playerId)
          );
          const fixturesSnap = await getDocs(q);
          const batch = writeBatch(db);

          fixturesSnap.forEach(fixtureDoc => {
            batch.update(fixtureDoc.ref, {
              manOfTheMatchPlayerId: null // Clear MOTM if the deleted player was it
            });
          });
          await batch.commit();

          openModal('Player deleted successfully!');
        } catch (err) {
          console.error('Error deleting player:', err);
          openModal('Failed to delete player. Please try again.');
        }
      }
    );
  }, [tournamentId, openModal]);

  if (loadingTournamentData || authLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-lg font-semibold animate-pulse">Loading player data...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gray-100 dark:bg-gray-900 text-red-500 p-4">
        <p className="text-xl font-bold mb-4">Error:</p>
        <p className="text-lg text-center">{error}</p>
        <Link to="/" className="mt-6 bg-red-600 text-white px-6 py-3 rounded-md hover:bg-red-700 transition-colors font-semibold">
          Go to Dashboard
        </Link>
      </div>
    );
  }

  return (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex flex-wrap justify-around font-bold text-base md:text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">PLAYERS</Link>
        <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">AI PREDICTION</Link>
      </div>

      <div className="p-4 sm:p-6 max-w-6xl mx-auto w-full">
        <h2 className="text-2xl sm:text-3xl font-bold mb-4 text-center">
          ‚öΩ Players in {tournamentName}
        </h2>

        {/* Add New Player Section */}
        <div className="mb-6 p-4 sm:p-6 bg-gray-50 dark:bg-gray-800 rounded-lg shadow-md border border-gray-200 dark:border-gray-700">
          <button
            onClick={() => setShowAddPlayerForm(!showAddPlayerForm)}
            className="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-md hover:bg-green-700 transition-colors duration-200 mb-4"
          >
            {showAddPlayerForm ? 'Hide Add Player Form' : 'Add New Player'}
          </button>

          {showAddPlayerForm && (
            <form onSubmit={handleAddPlayer} className="flex flex-col gap-4">
              <input
                type="text"
                placeholder="Player Name"
                value={newPlayerName}
                onChange={(e) => setNewPlayerName(e.target.value)}
                className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />

              <select
                value={newPlayerTeam}
                onChange={(e) => setNewPlayerTeam(e.target.value)}
                className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">Select Team</option>
                {teams.map((team, index) => (
                  <option key={index} value={team}>{team}</option>
                ))}
                <option value="_new_team_">Add New Team</option>
              </select>

              {newPlayerTeam === '_new_team_' && (
                <input
                  type="text"
                  placeholder="New Team Name"
                  value={customNewTeamName}
                  onChange={(e) => setCustomNewTeamName(e.target.value)}
                  className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              )}

              {addPlayerError && (
                <p className="text-red-500 text-sm mt-1">{addPlayerError}</p>
              )}

              <button
                type="submit"
                className="bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors duration-200"
              >
                Add Player
              </button>
            </form>
          )}
        </div>

        {/* Players List Table */}
        {players.length === 0 ? (
          <p className="text-gray-500 text-center py-4">No players added yet. Add some players!</p>
        ) : (
          <div className="overflow-x-auto rounded-lg shadow-lg border border-gray-300 dark:border-gray-600">
            <table className="min-w-full table-auto text-sm md:text-base">
              <thead>
                <tr className="bg-gray-100 dark:bg-gray-800 text-left">
                  <th className="px-3 py-2 border-b dark:border-gray-700 cursor-pointer" onClick={() => requestSort('name')}>
                    Player Name {getSortIndicator('name')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 cursor-pointer" onClick={() => requestSort('team')}>
                    Team {getSortIndicator('team')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 text-center cursor-pointer" onClick={() => requestSort('totalGoals')}>
                    Goals {getSortIndicator('totalGoals')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 text-center cursor-pointer" onClick={() => requestSort('totalAssists')}>
                    Assists {getSortIndicator('totalAssists')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 text-center cursor-pointer" onClick={() => requestSort('manOfTheMatchCount')}>
                    MOTM {getSortIndicator('manOfTheMatchCount')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 text-center">Actions</th>
                </tr>
              </thead>
              <tbody>
                {sortedPlayers.map(player => (
                  <tr key={player.id} className="border-b dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700">
                    <td className="px-3 py-2">{player.name}</td>
                    <td className="px-3 py-2">{player.team}</td>
                    <td className="px-3 py-2 text-center">{player.totalGoals}</td>
                    <td className="px-3 py-2 text-center">{player.totalAssists}</td>
                    <td className="px-3 py-2 text-center">{player.manOfTheMatchCount}</td>
                    <td className="px-3 py-2 flex flex-wrap justify-center gap-2">
                      <button
                        onClick={() => handleEditGoals(player)}
                        className="bg-yellow-500 text-white px-3 py-1 rounded-md hover:bg-yellow-600 transition-colors text-xs sm:text-sm"
                        title="Edit Goals"
                      >
                        Edit Goals
                      </button>
                      <button
                        onClick={() => handleEditAssists(player)}
                        className="bg-blue-500 text-white px-3 py-1 rounded-md hover:bg-blue-600 transition-colors text-xs sm:text-sm"
                        title="Edit Assists"
                      >
                        Edit Assists
                      </button>
                      <button
                        onClick={() => handleEditMOTM(player)}
                        className="bg-purple-500 text-white px-3 py-1 rounded-md hover:bg-purple-600 transition-colors text-xs sm:text-sm"
                        title="Edit Man of the Match Count"
                      >
                        Edit MOTM
                      </button>
                      <button
                        onClick={() => handleDeletePlayer(player.id, player.name)}
                        className="bg-red-500 text-white px-3 py-1 rounded-md hover:bg-red-600 transition-colors text-xs sm:text-sm"
                        title="Delete Player"
                      >
                        Delete
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>

      {/* Custom Modal */}
      <Modal
        isOpen={modalOpen}
        message={modalMessage}
        confirmAction={modalConfirmAction ? handleModalConfirm : null}
        cancelAction={handleModalCancel}
        inputRequired={modalInputRequired}
        inputLabel={modalInputLabel}
        inputValue={modalInputValue}
        setInputValue={setModalInputValue}
      />
    </div>
  );
}

--- END FILE: src\pages\PlayerPage.jsx ---

--- START FILE: src\pages\StatsPage.jsx ---

// src/pages/StatsPage.jsx

import React, { useEffect, useState, useMemo, useCallback } from 'react';
import { useParams, Link, useLocation } from 'react-router-dom';
import { db } from '../firebase';
import { collection, query, onSnapshot, doc, getDoc } from 'firebase/firestore';
import { useAuth } from '../hooks/useAuth';
import { Bar, Pie, Doughnut } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend,
  ArcElement,
} from 'chart.js';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend, ArcElement);

export default function StatsPage() {
  const { id: tournamentId } = useParams();
  const { user, loading: authLoading } = useAuth();
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [loadingTournamentData, setLoadingTournamentData] = useState(true);
  const [error, setError] = useState(null);
  const [fixtures, setFixtures] = useState([]);
  const [players, setPlayers] = useState([]);
  const [teams, setTeams] = useState([]); // State to hold unique team names

  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  const shareId = queryParams.get('shareId');

  // Determine if the page is in read-only mode
  const isViewOnly = useMemo(() => {
    if (shareId) return true;
    return false; // Not read-only if no shareId
  }, [shareId]);

  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);

  useEffect(() => {
    if (authLoading) {
      setLoadingTournamentData(true);
      return;
    }

    if (!user && !shareId) {
      setError("You must be logged in to view tournament details.");
      setLoadingTournamentData(false);
      return;
    }

    if (!tournamentId) {
      setError("No tournament ID provided in the URL.");
      setLoadingTournamentData(false);
      return;
    }

    setLoadingTournamentData(true);
    setError(null);

    const fetchTournamentData = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);

        if (tournamentSnap.exists()) {
          const data = tournamentSnap.data();
          setTournamentName(data.name);
          setTournamentOwnerId(data.userId);

          // If shareId is present, allow access
          if (shareId && data.shareId === shareId) {
            // Public view, no further permission check needed
          } else if (user && data.userId === user.uid) {
            // Owner access
          } else {
            // Neither shareId matches, nor is the user the owner
            setTournamentName('Access Denied');
            setError('You do not have permission to access this tournament.');
          }
        } else {
          setTournamentName('Tournament Not Found');
          setError('The requested tournament does not exist.');
        }
        setLoadingTournamentData(false);
      } catch (err) {
        console.error('Error fetching tournament data:', err);
        setTournamentName('Error');
        setError('Failed to load tournament details.');
        setLoadingTournamentData(false);
      }
    };
    fetchTournamentData();
  }, [tournamentId, user, authLoading, shareId]);


  useEffect(() => {
    if (loadingTournamentData || error || (!user && !shareId)) return;

    const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
    const unsubscribeFixtures = onSnapshot(fixturesCollectionRef, (snapshot) => {
      const fetchedFixtures = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setFixtures(fetchedFixtures);
    }, (err) => {
      console.error('Error fetching real-time fixtures:', err);
      setError('Failed to load fixtures. Please try again.');
    });

    const playersCollectionRef = collection(db, `tournaments/${tournamentId}/players`);
    const unsubscribePlayers = onSnapshot(playersCollectionRef, (snapshot) => {
      const fetchedPlayers = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setPlayers(fetchedPlayers);
      const uniqueTeams = [...new Set(fetchedPlayers.map(player => player.team))];
      setTeams(uniqueTeams);
    }, (err) => {
      console.error('Error fetching real-time players:', err);
      setError('Failed to load players. Please try again.');
    });

    return () => {
      unsubscribeFixtures();
      unsubscribePlayers();
    };
  }, [tournamentId, loadingTournamentData, error, user, shareId]);


  // Derived state for stats
  const {
    totalMatches,
    completedMatches,
    pendingMatches,
    goalsPerMatch,
    winsByTeam,
    teamGoals,
    matchOutcomes,
    playerGoals,
    manOfTheMatchCounts
  } = useMemo(() => {
    let total = 0;
    let completed = 0;
    let teamWins = {};
    let teamGoalsFor = {};
    let outcomes = { 'Win': 0, 'Draw': 0, 'Loss': 0 }; // Relative to team A in a fixture
    let pGoals = {};
    let motmCounts = {};

    fixtures.forEach(fixture => {
      total++;
      if (fixture.status === 'completed') {
        completed++;

        const scoreA = fixture.scoreA || 0;
        const scoreB = fixture.scoreB || 0;

        // Wins by Team
        if (scoreA > scoreB) {
          teamWins[fixture.teamA] = (teamWins[fixture.teamA] || 0) + 1;
          outcomes['Win']++;
        } else if (scoreB > scoreA) {
          teamWins[fixture.teamB] = (teamWins[fixture.teamB] || 0) + 1;
          outcomes['Loss']++;
        } else {
          outcomes['Draw']++;
        }

        // Team Goals
        teamGoalsFor[fixture.teamA] = (teamGoalsFor[fixture.teamA] || 0) + scoreA;
        teamGoalsFor[fixture.teamB] = (teamGoalsFor[fixture.teamB] || 0) + scoreB;

        // Player Goals (assuming goals structure is {playerId: count})
        if (fixture.goals) {
          for (const playerId in fixture.goals) {
            pGoals[players.find(p => p.id === playerId)?.name || playerId] = (pGoals[players.find(p => p.id === playerId)?.name || playerId] || 0) + fixture.goals[playerId];
          }
        }

        // Man of the Match
        if (fixture.manOfTheMatch) {
          motmCounts[players.find(p => p.id === fixture.manOfTheMatch)?.name || fixture.manOfTheMatch] = (motmCounts[players.find(p => p.id === fixture.manOfTheMatch)?.name || fixture.manOfTheMatch] || 0) + 1;
        }
      }
    });

    const pending = total - completed;
    const totalGoals = Object.values(teamGoalsFor).reduce((sum, current) => sum + current, 0);
    const avgGoalsPerMatch = completed > 0 ? (totalGoals / (completed * 2)) : 0; // Each fixture has 2 teams scoring

    return {
      totalMatches: total,
      completedMatches: completed,
      pendingMatches: pending,
      goalsPerMatch: avgGoalsPerMatch.toFixed(2),
      winsByTeam: teamWins,
      teamGoals: teamGoalsFor,
      matchOutcomes: outcomes,
      playerGoals: pGoals,
      manOfTheMatchCounts: motmCounts
    };
  }, [fixtures, players]); // Re-calculate if fixtures or players change

  // Chart data configurations
  const goalsPerTeamChartData = {
    labels: Object.keys(teamGoals),
    datasets: [{
      label: 'Goals Scored',
      data: Object.values(teamGoals),
      backgroundColor: 'rgba(75, 192, 192, 0.6)',
      borderColor: 'rgba(75, 192, 192, 1)',
      borderWidth: 1,
    }]
  };

  const matchOutcomesChartData = {
    labels: Object.keys(matchOutcomes),
    datasets: [{
      label: 'Match Outcomes',
      data: Object.values(matchOutcomes),
      backgroundColor: [
        'rgba(54, 162, 235, 0.6)', // Win
        'rgba(255, 206, 86, 0.6)', // Draw
        'rgba(255, 99, 132, 0.6)', // Loss
      ],
      borderColor: [
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(255, 99, 132, 1)',
      ],
      borderWidth: 1,
    }]
  };

  const topScorersChartData = {
    labels: Object.keys(playerGoals).sort((a, b) => playerGoals[b] - playerGoals[a]).slice(0, 5), // Top 5
    datasets: [{
      label: 'Goals',
      data: Object.values(playerGoals).sort((a, b) => b - a).slice(0, 5),
      backgroundColor: 'rgba(153, 102, 255, 0.6)',
      borderColor: 'rgba(153, 102, 255, 1)',
      borderWidth: 1,
    }]
  };

  const manOfTheMatchChartData = {
    labels: Object.keys(manOfTheMatchCounts).sort((a, b) => manOfTheMatchCounts[b] - manOfTheMatchCounts[a]).slice(0, 5), // Top 5
    datasets: [{
      label: 'Man of the Match Awards',
      data: Object.values(manOfTheMatchCounts).sort((a, b) => b - a).slice(0, 5),
      backgroundColor: 'rgba(255, 159, 64, 0.6)',
      borderColor: 'rgba(255, 159, 64, 1)',
      borderWidth: 1,
    }]
  };

  // Common Loading/Error/No Access UI
  const renderLoadingOrError = () => (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar - Always render for consistent layout */}
      <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">AI PREDICTION</Link>
      </div>
      <div className="flex-grow flex items-center justify-center p-4">
        {loadingTournamentData ? (
          <p className="text-lg font-semibold animate-pulse">Loading tournament data...</p>
        ) : error ? (
          <p className="text-red-500 text-lg font-semibold">{error}</p>
        ) : (
          <p className="text-gray-500 text-lg font-semibold">No data available or access denied.</p>
        )}
      </div>
    </div>
  );

  if (loadingTournamentData || error || (!user && !shareId)) {
    return renderLoadingOrError();
  }

  // Check if there are any completed fixtures to display stats for
  const hasCompletedFixtures = fixtures.some(f => f.status === 'completed');

  return (
    <div className="flex flex-col min-h-screen bg-gray-100 text-gray-900 dark:bg-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex flex-wrap justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">PLAYERS</Link> {/* Changed from TOP SCORERS to PLAYERS */}
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">AI PREDICTION</Link>
      </div>

      <div className="flex-grow p-4 md:p-6 lg:p-8 max-w-7xl mx-auto w-full">
        <h2 className="text-2xl md:text-3xl font-bold mb-6 text-center">üìä Tournament Stats ({tournamentName})</h2>

        {!hasCompletedFixtures ? (
          <p className="text-gray-500 text-center text-lg mt-8">No matches have been completed yet for this tournament. Complete some fixtures to see statistics!</p>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {/* General Stats Card */}
            <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md flex flex-col items-center justify-center">
              <h3 className="text-xl font-semibold mb-3">Overview</h3>
              <p className="text-lg">Total Matches: <span className="font-bold">{totalMatches}</span></p>
              <p className="text-lg">Completed Matches: <span className="font-bold text-green-600 dark:text-green-400">{completedMatches}</span></p>
              <p className="text-lg">Pending Matches: <span className="font-bold text-yellow-600 dark:text-yellow-400">{pendingMatches}</span></p>
              <p className="text-lg">Avg. Goals per Match: <span className="font-bold">{goalsPerMatch}</span></p>
            </div>

            {/* Goals Per Team Chart */}
            {Object.keys(teamGoals).length > 0 && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                <h3 className="text-xl font-semibold mb-4 text-center">Goals Scored Per Team</h3>
                <Bar data={goalsPerTeamChartData} options={{ responsive: true, maintainAspectRatio: true }} />
              </div>
            )}

            {/* Match Outcomes Chart */}
            {Object.values(matchOutcomes).some(count => count > 0) && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md flex flex-col items-center justify-center">
                <h3 className="text-xl font-semibold mb-4 text-center">Match Outcomes</h3>
                <div className="relative w-full max-w-xs aspect-square">
                  <Pie data={matchOutcomesChartData} options={{ responsive: true, maintainAspectRatio: false }} />
                </div>
              </div>
            )}

            {/* Top 5 Scorers Chart */}
            {Object.keys(playerGoals).length > 0 && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                <h3 className="text-xl font-semibold mb-4 text-center">Top 5 Scorers</h3>
                <Bar data={topScorersChartData} options={{ indexAxis: 'y', responsive: true, maintainAspectRatio: true }} />
              </div>
            )}

            {/* Top 5 Man of the Match Awards Chart */}
            {Object.keys(manOfTheMatchCounts).length > 0 && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                <h3 className="text-xl font-semibold mb-4 text-center">Top Man of the Match Awards</h3>
                <Doughnut data={manOfTheMatchChartData} options={{ responsive: true, maintainAspectRatio: true }} />
              </div>
            )}

            {/* Wins By Team List (if more than charts needed) */}
            {Object.keys(winsByTeam).length > 0 && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md col-span-1 md:col-span-2 lg:col-span-1">
                <h3 className="text-xl font-semibold mb-4 text-center">Wins by Team</h3>
                <ul className="space-y-2">
                  {Object.entries(winsByTeam)
                    .sort(([, winsA], [, winsB]) => winsB - winsA)
                    .map(([teamName, wins]) => (
                      <li key={teamName} className="flex justify-between items-center bg-gray-50 dark:bg-gray-700 p-3 rounded-md">
                        <span className="font-medium">{teamName}</span>
                        <span className="font-bold text-blue-600 dark:text-blue-400">{wins} Wins</span>
                      </li>
                    ))}
                </ul>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

--- END FILE: src\pages\StatsPage.jsx ---

--- START FILE: src\pages\TournamentPage.jsx ---

// src/pages/TournamentPage.jsx
import React, { useEffect, useState, useCallback, useRef } from 'react';
import { db } from '../firebase';
import {
  collection,
  addDoc,
  onSnapshot,
  doc,
  deleteDoc,
  updateDoc,
  query,
  orderBy,
  getDoc,
  writeBatch,
  getDocs,
  setDoc // Added setDoc for potential future use or consistency
} from 'firebase/firestore';
import { Link, useNavigate, useParams, useSearchParams } from 'react-router-dom'; // Added useSearchParams
import { useAuth } from '../hooks/useAuth';
import Modal from '../components/Modal';
import ScoreInputModalContent from '../components/ScoreInputModalContent';

export default function TournamentPage() {
  const { id: tournamentId } = useParams();
  const [searchParams] = useSearchParams(); // Hook to read URL query parameters
  const shareId = searchParams.get('shareId'); // Get the shareId from the URL
  const { user, loading: authLoading } = useAuth();
  const navigate = useNavigate();

  // State to determine if the page is in view-only mode
  // This will be true if shareId is present, or if user is null AND the tournament is public.
  const [isViewOnly, setIsViewOnly] = useState(false);
  // State to hold the actual owner ID for permission checks
  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);

  // Tournament Details State
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [tournamentDetails, setTournamentDetails] = useState(null);
  const [loadingTournamentData, setLoadingTournamentData] = useState(true);
  const [generalError, setGeneralError] = useState(null);

  // Team Management State
  const [teams, setTeams] = useState([]);
  const [newTeam, setNewTeam] = useState({ name: '', group: '' }); // Modified to include group
  const [teamError, setTeamError] = useState('');

  // Group Management State
  const [groups, setGroups] = useState([]); // New state for groups
  const [newGroupName, setNewGroupName] = useState(''); // New state for adding new group
  const [groupError, setGroupError] = useState(''); // New state for group errors

  // Fixture Management State
  const [fixtures, setFixtures] = useState([]);
  const [newFixture, setNewFixture] = useState({ teamA: '', teamB: '', date: '', timestamp: null, status: 'scheduled', scoreA: 0, scoreB: 0 });
  const [fixtureError, setFixtureError] = useState('');

  // Modal State (for the shared Modal component)
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalTitle, setModalTitle] = useState('');
  const [modalMessage, setModalMessage] = useState('');
  const [modalContent, setModalContent] = useState(null);
  const [modalConfirmAction, setModalConfirmAction] = useState(null);
  const [modalShowConfirmButton, setModalShowConfirmButton] = useState(true);

  // REF to access the ScoreInputModalContent component's methods (like getScoreA/B)
  const scoreInputRef = useRef(null);
  // State to hold the specific fixture being updated when the modal is open
  const [currentFixtureToUpdate, setCurrentFixtureToUpdate] = useState(null);

  // Tournament Configuration State
  const [enableColors, setEnableColors] = useState(false);
  const [promotionSpots, setPromotionSpots] = useState('');
  const [europeLeagueSpots, setEuropeLeagueSpots] = useState('');
  const [relegationSpots, setRelegationSpots] = useState('');
  const [fixtureOption, setFixtureOption] = useState('Single Matches');
  const [pointsPerWin, setPointsPerWin] = useState(3);
  const [pointsPerDraw, setPointsPerDraw] = useState(1);
  const [shareableLink, setShareableLink] = useState(''); // New state for the share link
  const [qualifiersPerGroup, setQualifiersPerGroup] = useState(''); // NEW STATE FOR QUALIFIERS PER GROUP

  // Helper function to open the custom modal (uses the shared Modal component)
  const openCustomModal = useCallback((title, message, confirmAction = null, showConfirm = true, content = null) => {
    setModalTitle(title);
    setModalMessage(message);
    setModalConfirmAction(() => confirmAction); // Use a function to set state with a function
    setModalShowConfirmButton(showConfirm);
    setModalContent(content);
    setIsModalOpen(true);
  }, []);
  const closeCustomModal = useCallback(() => {
    setIsModalOpen(false);
    setModalTitle('');
    setModalMessage('');
    setModalContent(null);
    setModalConfirmAction(null);
    setModalShowConfirmButton(true);
  }, []);

  // --- Effect to fetch Tournament Details ---
  useEffect(() => {
    // If auth is still loading, wait.
    if (authLoading) {
      setLoadingTournamentData(true);
      return;
    }

    if (!tournamentId) {
      setGeneralError("No tournament ID provided in the URL.");
      setLoadingTournamentData(false);
      return;
    }

    setLoadingTournamentData(true);
    setGeneralError(null);

    const fetchTournamentDetails = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);

        if (tournamentSnap.exists()) {
          const data = tournamentSnap.data();
          const ownerId = data.userId;
          const isPublicTournament = data.isPublic || false; // Check for isPublic flag

          setTournamentOwnerId(ownerId); // Store owner ID for later checks

          // Determine if it's view-only mode
          // It's view-only if a shareId is present, OR if the user is NOT logged in AND the tournament is public.
          const currentIsViewOnly = (!!shareId) || (!user && isPublicTournament);
          setIsViewOnly(currentIsViewOnly);


          // Permission Check:
          // If a user is logged in, they must be the owner to get full access.
          // If NO user is logged in, but a shareId is present AND the tournament is public, allow read-only.
          if (user && user.uid && ownerId === user.uid) {
            // Full access for the owner
            setTournamentName(data.name);
            setTournamentDetails(data);
            setEnableColors(data.enableColors || false);
            setPromotionSpots(data.promotionSpots !== undefined ? String(data.promotionSpots) : '');
            setEuropeLeagueSpots(data.europeLeagueSpots !== undefined ? String(data.europeLeagueSpots) : '');
            setRelegationSpots(data.relegationSpots !== undefined ? String(data.relegationSpots) : '');
            setFixtureOption(data.fixtureOption || 'Single Matches');
            setPointsPerWin(data.pointsPerWin !== undefined ? data.pointsPerWin : 3);
            setPointsPerDraw(data.pointsPerDraw !== undefined ? data.pointsPerDraw : 1);
            setGroups(data.groups || []); // Load groups
            setQualifiersPerGroup(data.qualifiersPerGroup !== undefined ? String(data.qualifiersPerGroup) : ''); // LOAD NEW STATE
            setShareableLink(`${window.location.origin}/tournament/${tournamentId}?shareId=${tournamentId}`); // Re-generate for owner to copy
          } else if (currentIsViewOnly) {
            // Read-only access for public viewers (via share link or unauthenticated to public tourney)
            setTournamentName(data.name);
            setTournamentDetails(data);
            setEnableColors(data.enableColors || false);
            setPromotionSpots(data.promotionSpots !== undefined ? String(data.promotionSpots) : '');
            setEuropeLeagueSpots(data.europeLeagueSpots !== undefined ? String(data.europeLeagueSpots) : '');
            setRelegationSpots(data.relegationSpots !== undefined ? String(data.relegationSpots) : '');
            setFixtureOption(data.fixtureOption || 'Single Matches');
            setPointsPerWin(data.pointsPerWin !== undefined ? data.pointsPerWin : 3);
            setPointsPerDraw(data.pointsPerDraw !== undefined ? data.pointsPerDraw : 1);
            setGroups(data.groups || []); // Load groups for view
            setQualifiersPerGroup(data.qualifiersPerGroup !== undefined ? String(data.qualifiersPerGroup) : ''); // LOAD NEW STATE
            setShareableLink(''); // No share link to show for viewers
            // No error, as this is expected behavior for view-only.
          } else {
            // User is logged in but not the owner, OR user is not logged in and tournament is not public.
            setTournamentName('Access Denied');
            setGeneralError('You do not have permission to access this tournament. Please log in with the correct account or use a valid share link.');
          }
        } else {
          setTournamentName('Tournament Not Found');
          setGeneralError('The requested tournament does not exist.');
        }
        setLoadingTournamentData(false);
      } catch (err) {
        console.error('Error fetching tournament details:', err);
        setTournamentName('Error');
        setGeneralError('Failed to load tournament details. Please try again.');
        setLoadingTournamentData(false);
      }
    };
    fetchTournamentDetails();
  }, [tournamentId, user, authLoading, shareId]); // Added shareId to dependencies

  // --- Effect to listen to Teams and Fixtures ---
  // These effects now listen regardless of `user` status, but the security rules will filter access.
  useEffect(() => {
    if (loadingTournamentData || generalError) {
      setTeams([]); // Clear teams if still loading or error
      return;
    }

    // Teams subscription
    const teamsCollectionRef = collection(db, `tournaments/${tournamentId}/teams`);
    const unsubscribeTeams = onSnapshot(query(teamsCollectionRef, orderBy('name', 'asc')), (snapshot) => {
      setTeams(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
    }, (err) => {
      console.error('Error fetching real-time teams:', err);
      // For view-only, just log the error, don't necessarily show it to the user.
      // For owner, you might want to show it.
      if (!isViewOnly) {
        setTeamError('Failed to load teams.');
      }
    });

    // Fixtures subscription
    const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
    const unsubscribeFixtures = onSnapshot(query(fixturesCollectionRef, orderBy('timestamp', 'asc')), (snapshot) => {
      setFixtures(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
    }, (err) => {
      console.error('Error fetching real-time fixtures:', err);
      if (!isViewOnly) {
        setFixtureError('Failed to load fixtures.');
      }
    });
    return () => {
      unsubscribeTeams();
      unsubscribeFixtures();
    };
  }, [tournamentId, loadingTournamentData, generalError, isViewOnly]); // Added isViewOnly to dependencies

  // --- Leaderboard Update Logic ---
  // This should ideally only be called by the owner or a backend function.
  // However, for simplicity, we'll keep it client-side but guard against view-only calls.
  const updateLeaderboard = useCallback(async () => {
    if (isViewOnly || !tournamentId || !tournamentDetails) {
      console.log('Skipping leaderboard update: View-only mode or tournament data missing.');
      return;
    }
    // Ensure the current user is the owner before attempting to write to the leaderboard
    if (user?.uid !== tournamentOwnerId) {
      console.warn('Attempted leaderboard update by non-owner in non-view-only mode. Aborting.');
      return;
    }

    const leaderboardRef = collection(db, `tournaments/${tournamentId}/leaderboard`);
    const teamsRef = collection(db, `tournaments/${tournamentId}/teams`);
    const fixturesRef = collection(db, `tournaments/${tournamentId}/fixtures`);

    try {
      const teamsSnapshot = await getDocs(teamsRef);
      const fixturesSnapshot = await getDocs(query(fixturesRef));

      const teamStats = {};
      teamsSnapshot.docs.forEach(teamDoc => {
        const teamName = teamDoc.data().name;
        teamStats[teamName] = {
          id: teamDoc.id,
          name: teamName,
          group: teamDoc.data().group || 'Ungrouped', // Include group here
          played: 0,
          wins: 0,
          draws: 0,
          losses: 0,
          goalsFor: 0,
          goalsAgainst: 0,
          goalDifference: 0,
          points: 0,
        };
      });

      fixturesSnapshot.docs.forEach(fixtureDoc => {
        const fixture = fixtureDoc.data();
        if (fixture.status === 'completed') {
          const teamA = fixture.teamA;
          const teamB = fixture.teamB;
          const scoreA = Number(fixture.scoreA) || 0;
          const scoreB = Number(fixture.scoreB) || 0;

          if (teamStats[teamA]) {
            teamStats[teamA].played++;
            teamStats[teamA].goalsFor += scoreA;
            teamStats[teamA].goalsAgainst += scoreB;
          }
          if (teamStats[teamB]) {
            teamStats[teamB].played++;
            teamStats[teamB].goalsFor += scoreB;
            teamStats[teamB].goalsAgainst += scoreA;
          }

          if (scoreA > scoreB) {
            if (teamStats[teamA]) teamStats[teamA].wins++;
            if (teamStats[teamB]) teamStats[teamB].losses++;
          } else if (scoreB > scoreA) {
            if (teamStats[teamB]) teamStats[teamB].wins++;
            if (teamStats[teamA]) teamStats[teamA].losses++;
          } else { // Draw
            if (teamStats[teamA]) teamStats[teamA].draws++;
            if (teamStats[teamB]) teamStats[teamB].draws++;
          }
        }
      });
      const currentPointsPerWin = tournamentDetails?.pointsPerWin || 3;
      const currentPointsPerDraw = tournamentDetails?.pointsPerDraw || 1;

      const batch = writeBatch(db);
      for (const teamName in teamStats) {
        const stats = teamStats[teamName];
        stats.goalDifference = stats.goalsFor - stats.goalsAgainst;
        stats.points = (stats.wins * currentPointsPerWin) + (stats.draws * currentPointsPerDraw);

        const teamLeaderboardDocRef = doc(leaderboardRef, stats.id);
        batch.set(teamLeaderboardDocRef, stats, { merge: true });
      }

      await batch.commit();
      console.log('Leaderboard updated successfully!');
    } catch (err) {
      console.error('Error updating leaderboard:', err);
    }
  }, [tournamentId, tournamentDetails, isViewOnly, user, tournamentOwnerId]); // Added user, tournamentOwnerId to dependencies

  // Effect to trigger leaderboard update when fixtures or tournamentDetails change
  useEffect(() => {
    // Only update leaderboard if not in view-only mode and is the owner
    if (!isViewOnly && user?.uid === tournamentOwnerId) {
      if (fixtures.length > 0 || (fixtures.length === 0 && !loadingTournamentData)) {
        updateLeaderboard();
      }
    }
  }, [fixtures, tournamentDetails, authLoading, user, updateLeaderboard, loadingTournamentData, isViewOnly, tournamentOwnerId]);

  // --- Group Management Handlers ---
  const handleAddGroup = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to add groups.', null, false);
      return;
    }
    setGroupError('');
    if (!newGroupName.trim()) {
      setGroupError('Group name cannot be empty.');
      return;
    }
    // Generate group names as A, B, C... based on the number of groups
    const numGroups = parseInt(newGroupName.trim());
    if (isNaN(numGroups) || numGroups <= 0) {
        setGroupError('Please enter a valid number of groups (e.g., 2, 4).');
        return;
    }
    
    let generatedGroupNames = [];
    for (let i = 0; i < numGroups; i++) {
        generatedGroupNames.push(`Group ${String.fromCharCode(65 + i)}`); // A, B, C, ...
    }

    if (generatedGroupNames.some(g => groups.includes(g))) {
        setGroupError('Some generated group names already exist. Clear existing groups first or reduce the number.');
        return;
    }

    try {
      const updatedGroups = [...groups, ...generatedGroupNames]; // Append newly generated groups
      const tournamentRef = doc(db, 'tournaments', tournamentId);
      await updateDoc(tournamentRef, { groups: updatedGroups });
      setGroups(updatedGroups);
      setNewGroupName('');
    } catch (err) {
      console.error('Error adding group:', err);
      setGroupError('Failed to add group. Please try again.');
    }
  };

  const handleDeleteGroup = async (groupToDelete) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to delete groups.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Delete Group',
      `Are you sure you want to delete group "${groupToDelete}"? Teams assigned to this group will no longer have a group.`,
      async () => {
        try {
          const updatedGroups = groups.filter(group => group !== groupToDelete);
          const tournamentRef = doc(db, 'tournaments', tournamentId);
          await updateDoc(tournamentRef, { groups: updatedGroups });
          setGroups(updatedGroups);

          // Optionally, update teams that were in this group to have no group
          const teamsInGroupQuery = query(collection(db, `tournaments/${tournamentId}/teams`), where('group', '==', groupToDelete));
          const teamsInGroupSnapshot = await getDocs(teamsInGroupQuery);
          const batch = writeBatch(db);
          teamsInGroupSnapshot.docs.forEach(teamDoc => {
            batch.update(teamDoc.ref, { group: '' });
          });
          await batch.commit();

          closeCustomModal();
        } catch (err) {
          console.error('Error deleting group:', err);
          openCustomModal('Error', 'Failed to delete group. Please try again.');
        }
      }
    );
  };

  // --- Team Management Handlers ---
  const handleAddTeam = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to add teams in view-only mode.', null, false);
      return;
    }
    setTeamError('');
    if (!newTeam.name.trim()) {
      setTeamError('Team name cannot be empty.');
      return;
    }
    if (teams.some(team => team.name.toLowerCase() === newTeam.name.trim().toLowerCase())) {
      setTeamError('A team with this name already exists.');
      return;
    }
    if (tournamentDetails?.type === 'Multi-Phase' && !newTeam.group && groups.length > 0) {
        // Only enforce group selection if it's multi-phase AND groups have been defined
        setTeamError('For Multi-Phase tournaments with defined groups, a team must be assigned to a group.');
        return;
    }
    try {
      await addDoc(collection(db, `tournaments/${tournamentId}/teams`), { name: newTeam.name.trim(), group: newTeam.group });
      setNewTeam({ name: '', group: newTeam.group }); // Keep selected group for next add
    } catch (err) {
      console.error('Error adding team:', err);
      setTeamError('Failed to add team. Make sure the tournament ID is valid and you have permission.');
    }
  };
  const handleDeleteTeam = async (teamId) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to delete teams in view-only mode.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Delete',
      'Are you sure you want to delete this team? This action cannot be undone.',
      async () => {
        try {
          await deleteDoc(doc(db, `tournaments/${tournamentId}/teams`, teamId));
          closeCustomModal();
          updateLeaderboard();
        } catch (err) {
          console.error('Error deleting team:', err);
          openCustomModal('Error', 'Failed to delete team. Please try again.');
        }
      }
    );
  };

  const handleClearAllTeams = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to clear all teams in view-only mode.', null, false);
      return;
    }
    if (teams.length === 0) {
      openCustomModal('Info', 'No teams to clear.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Clear All Teams',
      'Are you sure you want to delete ALL teams? This will also affect past match records.',
      async () => {
        const batch = writeBatch(db);
        teams.forEach(team => {
          const teamRef = doc(db, `tournaments/${tournamentId}/teams`, team.id);
          batch.delete(teamRef);
        });
        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', 'All teams cleared successfully.', null, false);
          updateLeaderboard();
        } catch (err) {
          console.error('Error clearing teams:', err);
          openCustomModal('Error', 'Failed to clear all teams. Please try again.');
        }
      }
    );
  };

  // --- Randomly Assign Teams to Groups Handler ---
  const handleRandomlyAssignTeamsToGroups = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to assign teams to groups.', null, false);
      return;
    }
    if (tournamentDetails?.type !== 'Multi-Phase') {
      openCustomModal('Info', 'This feature is only available for Multi-Phase Tournaments.', null, false);
      return;
    }
    if (groups.length === 0) {
      openCustomModal('Info', 'Please define some groups first (e.g., Group A, Group B).', null, false);
      return;
    }
    if (teams.length === 0) {
      openCustomModal('Info', 'Please add some teams first.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Random Group Assignment',
      'This will randomly assign all existing teams to your defined groups. Existing group assignments will be overwritten. Are you sure?',
      async () => {
        try {
          const shuffledTeams = [...teams].sort(() => Math.random() - 0.5); // Shuffle teams
          const batch = writeBatch(db);
          let groupIndex = 0;

          shuffledTeams.forEach(team => {
            const assignedGroup = groups[groupIndex % groups.length];
            const teamRef = doc(db, `tournaments/${tournamentId}/teams`, team.id);
            batch.update(teamRef, { group: assignedGroup });
            groupIndex++;
          });

          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', 'Teams randomly assigned to groups successfully!', null, false);
        } catch (err) {
          console.error('Error assigning teams to groups:', err);
          openCustomModal('Error', 'Failed to assign teams to groups. Please try again.', null, false);
        }
      }
    );
  };


  // --- Tournament Settings Handlers ---
  const handleSaveTournamentSettings = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to save settings in view-only mode.', null, false);
      return;
    }
    try {
      const tournamentRef = doc(db, 'tournaments', tournamentId);
      await updateDoc(tournamentRef, {
        enableColors: enableColors,
        promotionSpots: parseInt(promotionSpots) || 0,
        europeLeagueSpots: parseInt(europeLeagueSpots) || 0,
        relegationSpots: parseInt(relegationSpots) || 0,
        fixtureOption: fixtureOption,
        pointsPerWin: parseInt(pointsPerWin) || 3,
        pointsPerDraw: parseInt(pointsPerDraw) || 1,
        groups: groups, // Save groups to tournament document
        qualifiersPerGroup: parseInt(qualifiersPerGroup) || 0, // SAVE NEW SETTING
      });
      openCustomModal('Success', 'Tournament settings saved successfully!', null, false);
      setTournamentDetails(prev => ({
        ...prev,
        enableColors: enableColors,
        promotionSpots: parseInt(promotionSpots) || 0,
        europeLeagueSpots: parseInt(europeLeagueSpots) || 0,
        relegationSpots: parseInt(relegationSpots) || 0,
        fixtureOption: fixtureOption,
        pointsPerWin: parseInt(pointsPerWin) || 3,
        pointsPerDraw: parseInt(pointsPerDraw) || 1,
        groups: groups, // Update local state for consistency
        qualifiersPerGroup: parseInt(qualifiersPerGroup) || 0, // Update local state for consistency
      }));
    } catch (err) {
      console.error('Error saving tournament configuration:', err);
      openCustomModal('Error', 'Failed to save tournament configuration. Please try again.');
    }
  };

  // New handler to toggle tournament public status and generate link
  const handleTogglePublicStatus = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to change public status.', null, false);
      return;
    }

    const currentPublicStatus = tournamentDetails?.isPublic || false;
    const newPublicStatus = !currentPublicStatus;
    openCustomModal(
      'Confirm Public Status Change',
      `Are you sure you want to ${newPublicStatus ? 'make this tournament PUBLIC' : 'make this tournament PRIVATE'}?`,
      async () => {
        try {
          const tournamentRef = doc(db, 'tournaments', tournamentId);
          await updateDoc(tournamentRef, { isPublic: newPublicStatus });
          setTournamentDetails(prev => ({ ...prev, isPublic: newPublicStatus }));

          if (newPublicStatus) {
            const link = `${window.location.origin}/tournament/${tournamentId}?shareId=${tournamentId}`;
            setShareableLink(link);
            openCustomModal('Success', `Tournament is now public! Share this link: ${link}`, null, false);
          } else {
            setShareableLink('');
            openCustomModal('Success', 'Tournament is now private.', null, false);
          }
          closeCustomModal();
        } catch (err) {
          console.error('Error updating public status:', err);
          openCustomModal('Error', 'Failed to update public status. Please try again.');
        }
      }
    );
  };

  // Helper to copy share link to clipboard
  const copyShareLink = useCallback(() => {
    if (shareableLink) {
      navigator.clipboard.writeText(shareableLink)
        .then(() => openCustomModal('Link Copied!', 'The shareable link has been copied to your clipboard.', null, false))
        .catch(err => openCustomModal('Error', 'Failed to copy link. Please copy it manually.', null, false));
    }
  }, [shareableLink, openCustomModal]);

  // New helper function to shuffle an array
  const shuffleArray = useCallback((array) => {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex], array[currentIndex]];
    }
    return array;
  }, []);

  // Modified generateRoundRobinFixtures function
  const generateRoundRobinFixtures = useCallback((teamNames, isHomeAndAway) => {
    const numTeams = teamNames.length;
    if (numTeams < 2) return [];

    let teamsForScheduling = [...teamNames];
    if (numTeams % 2 !== 0) {
      teamsForScheduling.push('BYE');
    }

    const n = teamsForScheduling.length;
    const roundsNeeded = n - 1;

    let allLogicalRounds = [];

    for (let roundNum = 0; roundNum < roundsNeeded; roundNum++) {
      let currentRoundFixtures = [];

      const fixedTeam = teamsForScheduling[0];

      const rotatingTeamOppositeFixed = teamsForScheduling[(roundNum + (n - 1)) % (n - 1) + 1] || teamsForScheduling[n - 1]; // Corrected indexing for robustness
      if (fixedTeam !== 'BYE' && rotatingTeamOppositeFixed !== 'BYE') {
        if (roundNum % 2 === 0) {
          currentRoundFixtures.push({ teamA: fixedTeam, teamB: rotatingTeamOppositeFixed });
        } else {
          currentRoundFixtures.push({ teamA: rotatingTeamOppositeFixed, teamB: fixedTeam });
        }
      }

      for (let i = 1; i < n / 2; i++) {
        const team1 = teamsForScheduling[(roundNum + i) % (n - 1) + 1];
        const team2 = teamsForScheduling[(roundNum + n - 1 - i) % (n - 1) + 1];
        if (team1 !== 'BYE' && team2 !== 'BYE') {
          if (i % 2 === 0) {
            currentRoundFixtures.push({ teamA: team1, teamB: team2 });
          } else {
            currentRoundFixtures.push({ teamA: team2, teamB: team1 });
          }
        }
      }
      shuffleArray(currentRoundFixtures);
      allLogicalRounds.push(currentRoundFixtures);
    }

    let finalFixturesForDb = [];

    if (isHomeAndAway) {
      let returnRounds = [];
      allLogicalRounds.forEach(round => {
        let returnRound = [];
        round.forEach(fixture => {
          returnRound.push({ teamA: fixture.teamB, teamB: fixture.teamA });
        });
        returnRounds.push(returnRound);
      });
      allLogicalRounds = [...allLogicalRounds, ...returnRounds];
    }

    allLogicalRounds.forEach((roundFixtures, index) => {
      const weekNumber = index + 1;
      roundFixtures.forEach(fixture => {
        finalFixturesForDb.push({
          ...fixture,
          weekNumber: weekNumber,
        });
      });
    });
    return finalFixturesForDb;
  }, [shuffleArray]);

  const handleGenerateFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to generate fixtures in view-only mode.', null, false);
      return;
    }
    if (teams.length < 2) {
      openCustomModal('Info', 'You need at least two teams to generate fixtures!', null, false);
      return;
    }
    if (!tournamentDetails) {
      openCustomModal('Error', 'Tournament details not loaded. Cannot generate fixtures.', null, false);
      return;
    }

    const currentFixtureOption = tournamentDetails.fixtureOption || 'Single Matches';
    const teamNames = teams.map(t => t.name);
    const generatedFixturesWithWeekNumbers = generateRoundRobinFixtures(teamNames, currentFixtureOption === 'Home and Away Matches');

    let currentDate = new Date();
    currentDate.setHours(12, 0, 0, 0);
    const finalFixturesToSave = [];
    const groupedByWeek = generatedFixturesWithWeekNumbers.reduce((acc, fixture) => {
      const weekNum = fixture.weekNumber;
      if (!acc[weekNum]) {
        acc[weekNum] = [];
      }
      acc[weekNum].push(fixture);
      return acc;
    }, {});
    const sortedWeekNumbers = Object.keys(groupedByWeek).sort((a, b) => parseInt(a) - parseInt(b));

    sortedWeekNumbers.forEach(weekNum => {
      const fixturesInThisWeek = groupedByWeek[weekNum];
      fixturesInThisWeek.forEach(fixture => {
        finalFixturesToSave.push({
          teamA: fixture.teamA,
          teamB: fixture.teamB,
          date: currentDate.toISOString().split('T')[0],
          timestamp: new Date(currentDate),
          status: 'scheduled',
          scoreA: 0,
          scoreB: 0,
          weekNumber: parseInt(weekNum),
        });
      });
      currentDate.setDate(currentDate.getDate() + 7);
    });

    if (finalFixturesToSave.length === 0) {
      openCustomModal('Info', 'No fixtures could be generated. Check your team list and fixture options.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Fixture Generation',
      `This will delete ALL existing fixtures and generate ${finalFixturesToSave.length} new ones based on '${currentFixtureOption}'. Are you sure?`,
      async () => {
        const batch = writeBatch(db);
        const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);

        const existingFixturesSnapshot = await getDocs(fixturesCollectionRef);
        existingFixturesSnapshot.docs.forEach((doc) => {
          batch.delete(doc.ref);
        });

        finalFixturesToSave.forEach(fixture => {
          const newFixtureRef = doc(fixturesCollectionRef);
          batch.set(newFixtureRef, fixture);
        });

        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', `Successfully generated ${finalFixturesToSave.length} fixtures!`, null, false);
          updateLeaderboard();
        } catch (err) {
          console.error('Error generating fixtures:', err);
          openCustomModal('Error', 'Failed to generate fixtures. Please try again.');
        }
      }
    );
  };
  const handleAddFixture = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to add fixtures in view-only mode.', null, false);
      return;
    }
    setFixtureError('');
    if (!newFixture.teamA || !newFixture.teamB || !newFixture.date) {
      setFixtureError('Please select both teams and a date for the fixture.');
      return;
    }
    if (newFixture.teamA === newFixture.teamB) {
      setFixtureError('Teams cannot be the same.');
      return;
    }
    try {
      const fixtureDate = new Date(newFixture.date);
      if (isNaN(fixtureDate.getTime())) {
        setFixtureError('Invalid date format.');
        return;
      }
      fixtureDate.setHours(12, 0, 0, 0);
      await addDoc(collection(db, `tournaments/${tournamentId}/fixtures`), {
        ...newFixture,
        timestamp: fixtureDate,
        scoreA: 0,
        scoreB: 0,
        status: 'scheduled',
        weekNumber: 0,
      });
      setNewFixture({ teamA: '', teamB: '', date: '', timestamp: null, status: 'scheduled', scoreA: 0, scoreB: 0 });
    } catch (err) {
      console.error('Error adding fixture:', err);
      setFixtureError('Failed to add fixture.');
    }
  };
  const handleDeleteFixture = async (fixtureId) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to delete fixtures in view-only mode.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Delete',
      'Are you sure you want to delete this fixture? This action cannot be undone.',
      async () => {
        try {
          await deleteDoc(doc(db, `tournaments/${tournamentId}/fixtures`, fixtureId));
          closeCustomModal();
          updateLeaderboard();
        } catch (err) {
          console.error('Error deleting fixture:', err);
          openCustomModal('Error', 'Failed to delete fixture. Please try again.');
        }
      }
    );
  };
  const handleClearAllFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to clear all fixtures in view-only mode.', null, false);
      return;
    }
    if (fixtures.length === 0) {
      openCustomModal('Info', 'No fixtures to clear.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Clear All Fixtures',
      'Are you sure you want to delete ALL fixtures? This will reset match data for the leaderboard.',
      async () => {
        const batch = writeBatch(db);
        fixtures.forEach(fixture => {
          const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, fixture.id);
          batch.delete(fixtureRef);
        });
        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', 'All fixtures cleared successfully.', null, false);
          updateLeaderboard();
        } catch (err) {
          console.error('Error clearing fixtures:', err);
          openCustomModal('Error', 'Failed to clear all fixtures. Please try again.');
        }
      }
    );
  };

  // UPDATED handleUpdateScores to use ScoreInputModalContent
  const handleUpdateScores = useCallback(async (fixtureId, currentScoreA, currentScoreB) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to update scores in view-only mode.', null, false);
      return;
    }
    const fixtureToUpdate = fixtures.find(f => f.id === fixtureId);
    if (!fixtureToUpdate) {
      console.warn(`Fixture with ID ${fixtureId} not found.`);
      return;
    }
    setCurrentFixtureToUpdate(fixtureToUpdate);
    const confirmAction = async () => {
      if (!scoreInputRef.current) {
        console.error("scoreInputRef.current is null. ScoreInputModalContent might not be mounted or ref not attached.");
        openCustomModal('Error', 'Internal error: Cannot read scores. Please try again.', null, false);
        return;
      }
      const parsedScoreA = parseInt(scoreInputRef.current.getScoreA());
      const parsedScoreB = parseInt(scoreInputRef.current.getScoreB());

      if (isNaN(parsedScoreA) || isNaN(parsedScoreB)) {
        openCustomModal('Invalid Input', 'Please enter valid numbers for scores.', null, false, (
          <ScoreInputModalContent
            ref={scoreInputRef}
            fixture={fixtureToUpdate}
            initialScoreA={scoreInputRef.current.getScoreA()}
            initialScoreB={scoreInputRef.current.getScoreB()}
          />
        ));
        return;
      }

      try {
        const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, fixtureId);
        await updateDoc(fixtureRef, {
          scoreA: parsedScoreA,
          scoreB: parsedScoreB,
          status: 'completed'
        });
        closeCustomModal();
        updateLeaderboard();
      } catch (err) {
        console.error('Error updating scores:', err);
        openCustomModal('Error', 'Failed to update scores. Please try again.', null, false, (
          <ScoreInputModalContent
            ref={scoreInputRef}
            fixture={fixtureToUpdate}
            initialScoreA={scoreInputRef.current.getScoreA()}
            initialScoreB={scoreInputRef.current.getScoreB()}
          />
        ));
      }
    };

    openCustomModal(
      'Update Match Scores',
      `Enter scores for ${fixtureToUpdate.teamA} vs ${fixtureToUpdate.teamB}:`,
      confirmAction,
      true,
      <ScoreInputModalContent
        ref={scoreInputRef}
        fixture={fixtureToUpdate}
        initialScoreA={currentScoreA}
        initialScoreB={currentScoreB}
      />
    );
  }, [fixtures, tournamentId, openCustomModal, closeCustomModal, updateLeaderboard, isViewOnly, user, tournamentOwnerId]);


  // Common Loading/Error/No Access UI
  const renderLoadingOrError = () => (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar - Always render for consistent layout */}
      <div className="bg-red-600 text-white p-4 flex flex-wrap justify-center sm:justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">AI PREDICTION</Link>
      </div>

      <div className="p-4 sm:p-6 md:p-8 max-w-4xl mx-auto w-full">
        <h2 className="text-2xl sm:text-3xl font-bold mb-4 text-center">‚ú® {tournamentName} Details</h2>
        {generalError ?
          (
            <p className="text-red-500 text-center py-8">{generalError}</p>
          ) : (
            <p className="text-center text-gray-500 py-8">Loading tournament data...</p>
          )}
      </div>
    </div>
  );

  if (loadingTournamentData || authLoading || generalError) {
    return renderLoadingOrError();
  }

  // Determine if the current user is the owner
  const isOwner = user && user.uid === tournamentOwnerId;

  // Render content based on view-only mode
  console.log('TournamentPage rendering. isViewOnly:', isViewOnly, 'isOwner:', isOwner); // Debugging line


  return (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex flex-wrap justify-center sm:justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">AI PREDICTION</Link>
      </div>

      {/* Main Content Area */}
      <div className="flex-grow p-4 sm:p-6 md:p-8 max-w-7xl mx-auto w-full">
        <h1 className="text-3xl sm:text-4xl font-extrabold text-center mb-6 sm:mb-8 text-red-600 dark:text-red-400">
          {tournamentName}
        </h1>

        {isViewOnly && (
          <p className="text-center text-sm sm:text-base text-blue-500 mb-6 font-semibold bg-blue-100 dark:bg-blue-900 p-3 rounded-md">
            You are in view-only mode for this tournament. Some features are disabled.
          </p>
        )}

        {/* Tournament Owner Controls (Conditionally Rendered) */}
        {(!isViewOnly && isOwner) && (
          <div className="bg-gray-100 dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl sm:text-2xl font-bold mb-4 text-gray-800 dark:text-white">Tournament Controls</h2>

            {/* Public/Private Toggle */}
            <div className="mb-4 flex flex-col sm:flex-row sm:items-center sm:justify-between">
              <label htmlFor="publicToggle" className="block text-gray-700 dark:text-gray-300 font-semibold mb-2 sm:mb-0">
                Tournament Status:
              </label>
              <div className="flex items-center">
                <span className={`mr-2 font-medium ${tournamentDetails?.isPublic ? 'text-green-600' : 'text-gray-500'}`}>
                  {tournamentDetails?.isPublic ? 'PUBLIC' : 'PRIVATE'}
                </span>
                <button
                  onClick={handleTogglePublicStatus}
                  className={`px-4 py-2 rounded-md text-sm font-semibold transition-colors duration-200
                  ${tournamentDetails?.isPublic
                      ? 'bg-orange-500 hover:bg-orange-600 text-white'
                      : 'bg-green-500 hover:bg-green-600 text-white'
                    } w-full sm:w-auto`}
                >
                  {tournamentDetails?.isPublic ? 'Make Private' : 'Make Public'}
                </button>
              </div>
            </div>

            {/* Shareable Link */}
            {shareableLink && (
              <div className="mb-4">
                <label className="block text-gray-700 dark:text-gray-300 font-semibold mb-2">Shareable Link:</label>
                <div className="flex flex-col sm:flex-row items-center">
                  <input
                    type="text"
                    readOnly
                    value={shareableLink}
                    className="flex-grow p-2 border border-gray-300 rounded-md bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white mb-2 sm:mb-0 sm:mr-2 w-full"
                    onClick={(e) => e.target.select()} // Select all text on click
                  />
                  <button
                    onClick={copyShareLink}
                    className="bg-blue-500 text-white px-4 py-2 rounded-md text-sm hover:bg-blue-600 transition-colors font-semibold w-full sm:w-auto"
                  >
                    Copy Link
                  </button>
                </div>
              </div>
            )}

            {/* Tournament Configuration */}
            <h3 className="text-lg sm:text-xl font-bold mt-6 mb-3 text-gray-700 dark:text-gray-200">Configuration Settings</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
              <div>
                <label htmlFor="fixtureOption" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Fixture Type:</label>
                <select
                  id="fixtureOption"
                  value={fixtureOption}
                  onChange={(e) => setFixtureOption(e.target.value)}
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                >
                  <option value="Single Matches">Single Matches</option>
                  <option value="Home and Away Matches">Home and Away Matches</option>
                </select>
              </div>
              <div className="flex items-center">
                <input
                  type="checkbox"
                  id="enableColors"
                  checked={enableColors}
                  onChange={(e) => setEnableColors(e.target.checked)}
                  className="mr-2 h-4 w-4 text-red-600 focus:ring-red-500 border-gray-300 rounded"
                />
                <label htmlFor="enableColors" className="text-sm font-medium text-gray-700 dark:text-gray-300">Enable Leaderboard Colors</label>
              </div>
              <div>
                <label htmlFor="promotionSpots" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Promotion Spots (Top N):</label>
                <input
                  type="number"
                  id="promotionSpots"
                  value={promotionSpots}
                  onChange={(e) => setPromotionSpots(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              <div>
                <label htmlFor="europeLeagueSpots" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Europe League Spots (Next N):</label>
                <input
                  type="number"
                  id="europeLeagueSpots"
                  value={europeLeagueSpots}
                  onChange={(e) => setEuropeLeagueSpots(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              <div>
                <label htmlFor="relegationSpots" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Relegation Spots (Bottom N):</label>
                <input
                  type="number"
                  id="relegationSpots"
                  value={relegationSpots}
                  onChange={(e) => setRelegationSpots(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              <div>
                <label htmlFor="pointsPerWin" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Points per Win:</label>
                <input
                  type="number"
                  id="pointsPerWin"
                  value={pointsPerWin}
                  onChange={(e) => setPointsPerWin(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              <div>
                <label htmlFor="pointsPerDraw" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Points per Draw:</label>
                <input
                  type="number"
                  id="pointsPerDraw"
                  value={pointsPerDraw}
                  onChange={(e) => setPointsPerDraw(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              {/* NEW INPUT: Teams to Qualify Per Group */}
              {tournamentDetails?.type === 'Multi-Phase' && (
                <div>
                    <label htmlFor="qualifiersPerGroup" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Teams to Qualify Per Group:</label>
                    <input
                        type="number"
                        id="qualifiersPerGroup"
                        value={qualifiersPerGroup}
                        onChange={(e) => setQualifiersPerGroup(e.target.value)}
                        min="0"
                        className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                    />
                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                        For Multi-Phase tournaments: Number of teams advancing from each group to the knockout stage.
                    </p>
                </div>
              )}
            </div>
            <button
              onClick={handleSaveTournamentSettings}
              className="bg-green-500 text-white font-bold py-2 px-6 rounded-md hover:bg-green-600 transition-colors duration-200 uppercase tracking-wide w-full md:w-auto"
            >
              Save Settings
            </button>
          </div>
        )}

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Teams Section */}
          <div className="lg:col-span-1 bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md">
            <h2 className="text-xl sm:text-2xl font-bold mb-4 text-gray-800 dark:text-white">Teams ({teams.length})</h2>
            {teamError && <p className="text-red-500 mb-4">{teamError}</p>}
            {(!isViewOnly && isOwner) && (
              <div className="mb-6">
                {tournamentDetails?.type === 'Multi-Phase' && (
                    <div className="mb-4">
                        <h3 className="text-lg font-bold mb-2 text-gray-800 dark:text-white">Group Management</h3>
                        <div className="flex mb-2">
                            <input
                                type="text"
                                placeholder="Number of groups (e.g., 2, 4)"
                                value={newGroupName}
                                onChange={(e) => setNewGroupName(e.target.value)}
                                className="flex-grow p-2 border border-gray-300 rounded-l-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                            />
                            <button
                                onClick={handleAddGroup}
                                className="bg-blue-500 text-white px-4 py-2 rounded-r-md hover:bg-blue-600 transition-colors"
                            >
                                Add Groups
                            </button>
                        </div>
                        {groupError && <p className="text-red-500 text-sm mb-2">{groupError}</p>}
                        {groups.length > 0 && (
                            <div className="border border-gray-300 dark:border-gray-600 rounded-md p-2 max-h-32 overflow-y-auto mb-4">
                                <p className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Existing Groups:</p>
                                {groups.map((group, index) => (
                                    <div key={index} className="flex justify-between items-center bg-gray-100 dark:bg-gray-700 p-2 rounded-md mb-1">
                                        <span className="text-gray-900 dark:text-white">{group}</span>
                                        <button
                                            onClick={() => handleDeleteGroup(group)}
                                            className="text-red-500 hover:text-red-700 text-sm"
                                        >
                                            Delete
                                        </button>
                                    </div>
                                ))}
                            </div>
                        )}
                        <button
                            onClick={handleRandomlyAssignTeamsToGroups}
                            className="bg-indigo-600 text-white px-4 py-2 rounded-md text-sm hover:bg-indigo-700 transition-colors font-semibold w-full"
                        >
                            Randomly Assign Teams to Groups
                        </button>
                    </div>
                )}

                <input
                  type="text"
                  placeholder="New team name"
                  value={newTeam.name}
                  onChange={(e) => setNewTeam({ ...newTeam, name: e.target.value })}
                  className="w-full p-2 border border-gray-300 rounded-md mb-2 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
                {tournamentDetails?.type === 'Multi-Phase' && groups.length > 0 && (
                    <select
                        value={newTeam.group}
                        onChange={(e) => setNewTeam({ ...newTeam, group: e.target.value })}
                        className="w-full p-2 border border-gray-300 rounded-md mb-2 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                    >
                        <option value="">Select Group</option>
                        {groups.map((group, index) => (
                            <option key={index} value={group}>{group}</option>
                        ))}
                    </select>
                )}
                <button
                  onClick={handleAddTeam}
                  className="bg-blue-500 text-white px-4 py-2 rounded-md text-sm hover:bg-blue-600 transition-colors font-semibold w-full"
                >
                  Add Team
                </button>
              </div>
            )}
            {teams.length === 0 ? (
              <p className="text-gray-500 dark:text-gray-400">No teams added yet.</p>
            ) : (
              <div className="overflow-x-auto">
                <ul className="divide-y divide-gray-200 dark:divide-gray-700">
                  {teams.map((team) => (
                    <li key={team.id} className="py-3 flex flex-col sm:flex-row justify-between items-center">
                      <span className="font-semibold text-gray-900 dark:text-white text-base sm:text-lg mb-2 sm:mb-0">
                        {team.name}
                        {team.group && <span className="ml-2 text-gray-500 dark:text-gray-400 text-sm">({team.group})</span>}
                      </span>
                      {(!isViewOnly && isOwner) && (
                        <button
                          onClick={() => handleDeleteTeam(team.id)}
                          className="bg-red-500 text-white px-3 py-1 rounded-md text-sm hover:bg-red-600 transition-colors font-semibold w-full sm:w-auto"
                        >
                          Delete
                        </button>
                      )}
                    </li>
                  ))}
                </ul>
              </div>
            )}
            {(!isViewOnly && isOwner) && (
              <button
                onClick={handleClearAllTeams}
                className="bg-red-500 text-white font-bold py-2 px-6 rounded-md hover:bg-red-600 transition-colors duration-200 uppercase tracking-wide mt-6 w-full"
              >
                Clear All Teams
              </button>
            )}
          </div>

          {/* Fixtures Section */}
          <div className="lg:col-span-2 bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md">
            <h2 className="text-xl sm:text-2xl font-bold mb-4 text-gray-800 dark:text-white">Fixtures ({fixtures.length})</h2>
            {fixtureError && <p className="text-red-500 mb-4">{fixtureError}</p>}

            {(!isViewOnly && isOwner) && (
              <>
                <div className="mb-6 grid grid-cols-1 md:grid-cols-3 gap-4">
                  <select
                    value={newFixture.teamA}
                    onChange={(e) => setNewFixture({ ...newFixture, teamA: e.target.value })}
                    className="p-2 border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white w-full"
                  >
                    <option value="">Select Team A</option>
                    {teams.map(team => (
                      <option key={team.id} value={team.name}>{team.name}</option>
                    ))}
                  </select>
                  <select
                    value={newFixture.teamB}
                    onChange={(e) => setNewFixture({ ...newFixture, teamB: e.target.value })}
                    className="p-2 border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white w-full"
                  >
                    <option value="">Select Team B</option>
                    {teams.map(team => (
                      <option key={team.id} value={team.name}>{team.name}</option>
                    ))}
                  </select>
                  <input
                    type="date"
                    value={newFixture.date}
                    onChange={(e) => setNewFixture({ ...newFixture, date: e.target.value })}
                    className="p-2 border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white w-full"
                  />
                </div>
                <div className="flex flex-col sm:flex-row gap-4 mb-6">
                  <button
                    onClick={handleAddFixture}
                    className="bg-green-500 text-white px-4 py-2 rounded-md text-sm hover:bg-green-600 transition-colors font-semibold w-full sm:flex-1"
                  >
                    Add Custom Fixture
                  </button>
                  <button
                    onClick={handleGenerateFixtures}
                    className="bg-purple-500 text-white px-4 py-2 rounded-md text-sm hover:bg-purple-600 transition-colors font-semibold w-full sm:flex-1"
                  >
                    Generate Round-Robin Fixtures
                  </button>
                </div>
              </>
            )}

            {fixtures.length === 0 ? (
              <p className="text-gray-500 dark:text-gray-400">No fixtures scheduled yet.</p>
            ) : (
              <div className="overflow-x-auto">
                <ul className="divide-y divide-gray-200 dark:divide-gray-700">
                  {fixtures.map((fixture) => (
                    <li key={fixture.id} className="py-3 flex flex-col sm:flex-row justify-between items-center">
                      <div className="flex-1 mb-2 sm:mb-0 sm:mr-4">
                        <span className="font-semibold text-gray-900 dark:text-white text-base sm:text-lg">
                          {fixture.teamA} vs {fixture.teamB}
                        </span>
                        <p className="text-gray-600 dark:text-gray-400 text-sm">
                          {fixture.date} - Status:
                          <span className={`ml-1 font-medium ${fixture.status === 'completed' ? 'text-green-500' : 'text-yellow-500'}`}>
                            {fixture.status.toUpperCase()}
                          </span>
                          {fixture.status === 'completed' && (
                            <span className="ml-2 text-gray-700 dark:text-gray-300">
                              ({fixture.scoreA} - {fixture.scoreB})
                            </span>
                          )}
                        </p>
                      </div>
                      {(!isViewOnly && isOwner) && (
                        <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
                          <button
                            onClick={() => handleUpdateScores(fixture.id, fixture.scoreA, fixture.scoreB)}
                            className="bg-indigo-500 text-white px-4 py-2 rounded-md text-sm hover:bg-indigo-600 transition-colors font-semibold"
                          >
                            Update Score
                          </button>
                          <button
                            onClick={() => handleDeleteFixture(fixture.id)}
                            className="bg-red-500 text-white px-4 py-2 rounded-md text-sm hover:bg-red-600 transition-colors font-semibold"
                          >
                            Delete
                          </button>
                        </div>
                      )}
                    </li>
                  ))}
                </ul>
              </div>
            )}
            {(!isViewOnly && isOwner) && ( // Only show this button if not view-only AND owner
              <button
                onClick={handleClearAllFixtures}
                className="bg-red-500 text-white font-bold py-2 px-6 rounded-md hover:bg-red-600 transition-colors duration-200 uppercase tracking-wide mt-6 w-full"
              >
                Clear All Fixtures
              </button>
            )}
          </div>
        </div>
      </div>

      {/* Reusable Modal Component (from ../components/Modal.jsx) */}
      <Modal
        isOpen={isModalOpen}
        onClose={closeCustomModal}
        onConfirm={modalConfirmAction}
        title={modalTitle}
        message={modalMessage}
        showConfirmButton={modalShowConfirmButton}
      >
        {/* Render custom content (e.e., score input fields) inside the modal */}
        {modalContent}
      </Modal>
    </div>
  );
}


--- END FILE: src\pages\TournamentPage.jsx ---

--- START FILE: src\utils\passwordStrength.js ---

// src/utils/passwordStrength.js

export const getPasswordStrength = (password) => {
    let strength = 0;

    // Check for length
    if (password.length >= 8) {
        strength++;
    }

    // Check for uppercase and lowercase characters
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) {
        strength++;
    }

    // Check for numbers
    if (/\d/.test(password)) {
        strength++;
    }

    // Check for special characters
    if (/[^a-zA-Z0-9]/.test(password)) {
        strength++;
    }

    // Cap strength at 4
    return Math.min(strength, 4);
};

export const getStrengthColor = (strength) => {
    switch (strength) {
        case 0:
            return 'text-gray-400'; // Too Short / No Input
        case 1:
            return 'text-red-500'; // Weak
        case 2:
            return 'text-orange-500'; // Moderate
        case 3:
            return 'text-yellow-500'; // Good
        case 4:
            return 'text-green-500'; // Strong
        default:
            return 'text-gray-400';
    }
};

--- END FILE: src\utils\passwordStrength.js ---

-------------------------------------------------------------------------------------------------

tell me how to do the following here?

the knockout bracket to look exactly like any professional tournament knockout bracket.
after registering teams, i want them to show in the top scorers section where a new player is being added, for selecting his team.
.