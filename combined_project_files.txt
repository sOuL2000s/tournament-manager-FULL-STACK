
--- START FILE: .gitignore ---

# ‚öôÔ∏è Node.js
node_modules/
dist/
.vite/
.env

# ‚öôÔ∏è Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ‚öôÔ∏è IDEs and editors
.vscode/
.idea/
*.sublime-project
*.sublime-workspace

# ‚öôÔ∏è System files
.DS_Store
Thumbs.db

# ‚öôÔ∏è Firebase emulators & CLI cache (if using locally)
.firebase/
.firebaserc
.firebase-debug.log


--- END FILE: .gitignore ---

--- START FILE: combined.py ---

import os

def combine_files_to_single_file(root_dir, output_filename="combined_project_files.txt"):
    """
    Combines the content of all files in a directory into a single file,
    excluding 'node_modules' directories and 'package-lock.json' files.

    Args:
        root_dir (str): The root directory of the project.
        output_filename (str): The name of the output file.
    """
    combined_content = []
    excluded_dirs = ['node_modules', '.git', '.vscode', '.idea', 'dist', 'build']
    excluded_files = ['package-lock.json', 'yarn.lock', 'bun.lockb', '.env'] # Added .env as it might contain sensitive info

    print(f"Starting to combine files from: {root_dir}")
    print(f"Excluding directories: {excluded_dirs}")
    print(f"Excluding files: {excluded_files}")

    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Modify dirnames in-place to skip excluded directories
        dirnames[:] = [d for d in dirnames if d not in excluded_dirs]

        for filename in filenames:
            if filename in excluded_files:
                print(f"Skipping excluded file: {os.path.join(dirpath, filename)}")
                continue

            file_path = os.path.join(dirpath, filename)
            # Make path relative to root_dir for the header
            relative_file_path = os.path.relpath(file_path, root_dir)

            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                combined_content.append(f"\n--- START FILE: {relative_file_path} ---\n\n")
                combined_content.append(content)
                combined_content.append(f"\n\n--- END FILE: {relative_file_path} ---\n")
                print(f"Included file: {relative_file_path}")
            except UnicodeDecodeError:
                print(f"Skipping binary or undecodable file (UnicodeDecodeError): {relative_file_path}")
            except Exception as e:
                print(f"Error reading file {relative_file_path}: {e}")

    output_path = os.path.join(root_dir, output_filename)
    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("".join(combined_content))
        print(f"\nSuccessfully combined all files into: {output_path}")
    except Exception as e:
        print(f"Error writing output file {output_path}: {e}")

if __name__ == "__main__":
    # Get the current working directory where the script is run
    # This assumes you run the script from your project's root directory
    project_root = os.getcwd()
    combine_files_to_single_file(project_root)


--- END FILE: combined.py ---

--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#1f2937" /> <!-- Defines a theme color for the browser UI, useful for mobile browsers -->
    <title>Tournament Manager</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <!-- Link to the favicon for the browser tab -->
    
    <!-- Preconnect to Google Fonts domains for improved loading performance of fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Link to the 'Inter' font from Google Fonts. Loads weights 400, 500, 600, 700. -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <!-- 
    Apply base Tailwind CSS classes for background and text colors.
    'bg-gray-100' and 'text-gray-900' for light mode.
    'dark:bg-gray-900' and 'dark:text-white' for dark mode (controlled by 'dark' class on html element via JavaScript).
    'font-inter' class ensures the 'Inter' font is used throughout the body.
  -->
  <body class="bg-gray-100 text-gray-900 dark:bg-gray-900 dark:text-white font-inter">
    <div id="root"></div> <!-- This is the root element where your React application will be mounted by main.jsx -->
    <script type="module" src="/src/main.jsx"></script> <!-- This script tag is the entry point for your client-side React application -->
  </body>
</html>


--- END FILE: index.html ---

--- START FILE: package.json ---

{
  "name": "tournament-manager",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "chart.js": "^4.5.0",
    "firebase": "^10.12.0",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.1.0",
    "autoprefixer": "^10.4.19",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.1",
    "vite": "^5.2.8"
  }
}

--- END FILE: package.json ---

--- START FILE: postcss.config.js ---

// ‚úÖ postcss.config.js (CommonJS)
module.exports = {
  plugins: {
    tailwindcss: {}, // Plugin for processing Tailwind CSS
    autoprefixer: {}, // Plugin for adding vendor prefixes to CSS rules
  },
};


--- END FILE: postcss.config.js ---

--- START FILE: README.md ---

check out the website here: https://tournament-manager-website.netlify.app/


--- END FILE: README.md ---

--- START FILE: tailwind.config.js ---

/** @type {import('tailwindcss').Config} */
export default {
  // Configure files to scan for Tailwind classes.
  // These paths tell Tailwind CSS where to look for class names
  // to generate the final CSS bundle, optimizing its size.
  content: [
    "./index.html", // Include the main HTML file where global classes might be used.
    "./src/**/*.{js,ts,jsx,tsx}", // Include all JavaScript, TypeScript, and React files in the 'src' directory.
  ],

  // Enable dark mode based on the presence of a 'dark' class on the HTML element.
  // This allows you to toggle dark/light themes by adding/removing 'dark' class via JavaScript.
  darkMode: "class", // üåô Enable dark mode via class

  theme: {
    // Extend the default Tailwind CSS theme.
    // This allows you to add custom configurations without overriding Tailwind's defaults.
    extend: {
      // Define a custom color palette.
      // These colors can then be used as Tailwind classes (e.g., `bg-primary`, `text-secondary`).
      colors: {
        primary: "#1d4ed8",   // A shade of blue (e.g., for primary buttons, links) - corresponds to blue-700
        secondary: "#9333ea", // A shade of purple (e.g., for accents or secondary actions) - corresponds to purple-600
      },
      fontFamily: { // Define custom font family.
        // Add 'Inter' font, which should be imported from Google Fonts in index.html.
        // This allows you to use `font-inter` class in your components.
        inter: ['Inter', 'sans-serif'],
      },
    },
  },

  // Add any Tailwind CSS plugins here.
  // Plugins extend Tailwind's capabilities with new utilities or components.
  plugins: [],
};


--- END FILE: tailwind.config.js ---

--- START FILE: vite.config.js ---

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react'; // Vite plugin for React applications

export default defineConfig({
  // Define plugins for Vite. Plugins extend Vite's capabilities.
  // The 'react()' plugin is essential for React support, enabling JSX transformation, HMR, etc.
  plugins: [react()],

  // Configure the development server.
  server: {
    port: 5173 // Specify the port number on which the development server will run.
              // If this port is already in use, Vite will automatically try the next available port.
  },

  // Build configuration (optional, currently commented out in the provided code).
  // This section would define how Vite builds your application for production.
  // build: {
  //   sourcemap: true, // Enabling sourcemaps is useful for debugging production builds.
  // },

  // Further configurations could include:
  // - `resolve.alias`: For setting up path aliases (e.g., '@components' to 'src/components').
  // - `css.postcss`: If custom PostCSS processing is needed beyond the default setup.
  // - `optimizeDeps`: For fine-tuning dependency pre-bundling.
});


--- END FILE: vite.config.js ---

--- START FILE: src\App.jsx ---

import React, { useEffect, useState } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom'; // Removed Link as it's not used here

// Import Page Components
import Dashboard from './pages/Dashboard';
import TournamentPage from './pages/TournamentPage';
import FixturesPage from './pages/FixturesPage';
import LeaderboardPage from './pages/LeaderboardPage';
import AuthPage from './pages/AuthPage'; // Authentications page (login/signup)
import KnockoutPage from './pages/KnockoutPage';
import AIPredictionPage from './pages/AIPredictionPage';
import StatsPage from './pages/StatsPage';
import PlayerPage from './pages/PlayerPage';

// Import Reusable Components
import Header from './components/Header';
import ProtectedRoute from './components/ProtectedRoute'; // Component to protect routes requiring authentication

// Import Custom Hooks
import { useAuth } from './hooks/useAuth'; // Custom hook for authentication state management

export default function App() {
  // Destructure user, loading state, and logout function from the useAuth hook
  const { user, loading, logout } = useAuth();

  // State for dark mode preference, initialized from localStorage
  const [darkMode, setDarkMode] = useState(() => localStorage.getItem('dark') === 'true');

  // State for language preference, initialized from localStorage, defaults to 'en'
  const [lang, setLang] = useState(() => localStorage.getItem('lang') || 'en');

  // useEffect to apply or remove the 'dark' class from the HTML document element
  // and persist the preference in localStorage whenever darkMode state changes.
  useEffect(() => {
    if (darkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
    localStorage.setItem('dark', darkMode); // Persist dark mode setting
  }, [darkMode]);

  // useEffect to persist the language preference in localStorage whenever lang state changes.
  useEffect(() => {
    localStorage.setItem('lang', lang);
  }, [lang]);

  // Translations object for Internationalization (i18n)
  // Provides different language strings for UI elements.
  const translations = {
    en: { // English translations
      title: 'Tournament Manager',
      logout: 'Logout',
      light: 'Light Mode',
      dark: 'Dark Mode',
      dashboard: 'Dashboard',
    },
    hi: { // Hindi translations
      title: '‡§ü‡•Ç‡§∞‡•ç‡§®‡§æ‡§Æ‡•á‡§Ç‡§ü ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§®',
      logout: '‡§≤‡•â‡§ó ‡§Ü‡§â‡§ü',
      light: '‡§≤‡§æ‡§á‡§ü ‡§Æ‡•ã‡§°',
      dark: '‡§°‡§æ‡§∞‡•ç‡§ï ‡§Æ‡•ã‡§°',
      dashboard: '‡§°‡•à‡§∂‡§¨‡•ã‡§∞‡•ç‡§°',
    },
    bn: { // Bengali translations
      title: '‡¶ü‡ßÅ‡¶∞‡ßç‡¶®‡¶æ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú‡¶æ‡¶∞',
      logout: '‡¶≤‡¶ó ‡¶Ü‡¶â‡¶ü',
      light: '‡¶≤‡¶æ‡¶á‡¶ü ‡¶Æ‡ßã‡¶°',
      dark: '‡¶°‡¶æ‡¶∞‡ßç‡¶ï ‡¶Æ‡ßã‡¶°',
      dashboard: '‡¶°‡ßç‡¶Ø‡¶æ‡¶∂‡¶¨‡ßã‡¶∞‡ßç‡¶°',
    },
  };

  // Select the current translation based on the 'lang' state, falling back to English if not found.
  const t = translations[lang] || translations.en;

  // Show a loading screen while Firebase Authentication is initializing.
  // This prevents UI flashes or errors before the user's auth status is known.
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        Loading application...
      </div>
    );
  }

  // If the user is not logged in (user object is null after loading), render the AuthPage.
  // This acts as the unauthenticated entry point.
  if (!user) {
    return <AuthPage />;
  }

  // If the user is logged in, render the main application layout with routing.
  return (
    // BrowserRouter wraps the entire application to enable client-side routing.
    <BrowserRouter>
      <div className="min-h-screen bg-white text-black dark:bg-gray-900 dark:text-white flex flex-col">
        {/* Header component: Displays app title, dark mode toggle, language selector, and logout button. */}
        <Header
          darkMode={darkMode}
          setDarkMode={setDarkMode}
          lang={lang}
          setLang={setLang}
          t={t}
          // Pass the logout function from useAuth directly to the Header component.
          setToken={() => logout()}
        />

        {/* Main content area: Uses React Router's Routes component to define application routes. */}
        <div className="flex-grow">
          <Routes>
            {/* Root route: Displays the Dashboard page, protected by ProtectedRoute. */}
            <Route path="/" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />

            {/* Tournament-specific pages: These routes use a dynamic :id parameter to fetch tournament data. */}
            {/* Each is protected, ensuring only authenticated users can access them. */}
            <Route path="/tournament/:id" element={<ProtectedRoute><TournamentPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/fixtures" element={<ProtectedRoute><FixturesPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/leaderboard" element={<ProtectedRoute><LeaderboardPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/knockout" element={<ProtectedRoute><KnockoutPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/ai-prediction" element={<ProtectedRoute><AIPredictionPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/stats" element={<ProtectedRoute><StatsPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/players" element={<ProtectedRoute><PlayerPage /></ProtectedRoute>} />

            {/* Fallback route: If no other route matches, it redirects to the Dashboard. */}
            {/* This is also protected. */}
            <Route path="*" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />
          </Routes>
        </div>
      </div>
    </BrowserRouter>
  );
}

--- END FILE: src\App.jsx ---

--- START FILE: src\firebase.js ---

import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
import { getAuth } from "firebase/auth"; // Only getAuth is needed here for export

// Firebase configuration.
// It prioritizes the __firebase_config global variable provided by the Canvas environment.
// If __firebase_config is not defined (e.g., in a local development setup),
// it falls back to environment variables loaded via import.meta.env.
const firebaseConfig = typeof __firebase_config !== 'undefined'
  ? JSON.parse(__firebase_config) // Parse the stringified config from the Canvas environment
  : {
      apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
      authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
      projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
      storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
      appId: import.meta.env.VITE_FIREBASE_APP_ID,
    };

// Initialize the Firebase application with the provided configuration.
const app = initializeApp(firebaseConfig);

// Get a reference to the Firestore database service.
// This is the primary way to interact with your Firestore data.
const db = getFirestore(app);

// Get a reference to the Firebase Authentication service.
// This is used for user authentication (sign-in, sign-up, etc.).
const auth = getAuth(app);

// Export the initialized Firebase app, Firestore database, and Authentication instances.
// These can then be imported and used in other parts of your React application.
export { db, app, auth };


--- END FILE: src\firebase.js ---

--- START FILE: src\index.css ---

/* index.css */
/* Tailwind CSS imports */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom scrollbar styles for a cleaner look */
/* These styles apply to Webkit browsers (Chrome, Safari, Edge) */
::-webkit-scrollbar {
  width: 8px; /* Width of the vertical scrollbar */
  height: 8px; /* Height of the horizontal scrollbar */
}

::-webkit-scrollbar-track {
  background: #f1f1f1; /* Light background for the scrollbar track in light mode */
  border-radius: 10px; /* Rounded corners for the track */
}

/* Dark mode specific scrollbar track color */
html.dark ::-webkit-scrollbar-track {
  background: #333; /* Darker background for the track in dark mode */
}

::-webkit-scrollbar-thumb {
  background: #888; /* Gray thumb (the draggable part) in light mode */
  border-radius: 10px; /* Rounded corners for the thumb */
}

/* Dark mode specific scrollbar thumb color */
html.dark ::-webkit-scrollbar-thumb {
  background: #555; /* Darker thumb in dark mode */
}

::-webkit-scrollbar-thumb:hover {
  background: #555; /* Darker gray on hover for the thumb in light mode */
}

/* Dark mode specific scrollbar thumb hover color */
html.dark ::-webkit-scrollbar-thumb:hover {
  background: #777; /* Lighter gray on hover for the thumb in dark mode */
}

/* Ensure font consistency across the application */
/* Using 'Inter' font as per project instructions. Falls back to generic sans-serif. */
body {
  font-family: 'Inter', sans-serif;
}

/* Base styles for dark mode transition, applied to the html and body elements */
/* This creates a smooth visual transition when toggling dark/light mode. */
html {
  /* Define CSS variables for global text and background colors based on mode */
  --text-color: #1f2937; /* Default text color for light mode */
  --background-color: #ffffff; /* Default background color for light mode */
  transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
}

html.dark {
  --text-color: #f3f4f6; /* Text color for dark mode */
  --background-color: #1a202c; /* Background color for dark mode (e.g., gray-900) */
}

body {
  background-color: var(--background-color);
  color: var(--text-color);
}


--- END FILE: src\index.css ---

--- START FILE: src\main.jsx ---

import React from 'react';
import ReactDOM from 'react-dom/client'; // Correct import for React 18+
import App from './App.jsx'; // Main application component
import './index.css'; // Global CSS imports, including TailwindCSS

// Get the root DOM element where the React application will be mounted.
const rootElement = document.getElementById('root');

// Create a React root. This is the new API for React 18+ concurrent mode.
const root = ReactDOM.createRoot(rootElement);

// Display a loading message immediately before the React app fully mounts.
// This provides a user-friendly experience while initial assets and authentication state are determined.
// This is done by directly manipulating the innerHTML of the root element.
// Note: While this works, typically a dedicated loading component within App.jsx
// or a splash screen managed by a loading state in App.jsx is more React-idiomatic.
if (rootElement) { // Ensure rootElement exists before modifying it
  rootElement.innerHTML = '<div style="min-height: 100vh; display: flex; align-items: center; justify-content: center; background-color: #f3f4f6; color: #1f2937;">Loading application...</div>';
}

// Render the main App component into the React root.
// <React.StrictMode> is a tool for highlighting potential problems in an application.
// It does not render any visible UI. It activates additional checks and warnings for its descendants.
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Any initial Firebase auth setup or error handling (like config issues)
// is now handled internally by the useAuth hook within App.jsx and its child components.
// The previous comment "// import { initializeAuth } from './firebase.js';" is correctly commented out
// as explicit initialization of auth from here is no longer needed with the current setup.


--- END FILE: src\main.jsx ---

--- START FILE: src\components\Header.jsx ---

import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth'; // Import useAuth hook
import { RiMenu3Line, RiCloseLine } from 'react-icons/ri'; // Import menu icons

export default function Header({ darkMode, setDarkMode, lang, setLang, t }) {
  const { user, logout } = useAuth(); // Get user and logout from useAuth
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false); // State for mobile menu visibility

  const handleLogout = async () => {
    try {
      await logout();
    } catch (error) {
      console.error("Failed to log out:", error);
    }
  };

  const toggleMobileMenu = () => {
    setIsMobileMenuOpen(!isMobileMenuOpen);
  };

  return (
    <header className="bg-red-600 text-white p-4 shadow-md flex justify-between items-center relative">
      {/* Tournament Title/Link */}
      <Link to="/" className="text-xl font-bold tracking-wide z-20" onClick={() => setIsMobileMenuOpen(false)}>
        {t.title}
      </Link>

      {/* Hamburger/Close Icon for Mobile */}
      <div className="md:hidden z-20">
        <button
          onClick={toggleMobileMenu}
          className="p-2 rounded-md hover:bg-red-700 transition-colors focus:outline-none focus:ring-2 focus:ring-white"
          aria-label={isMobileMenuOpen ? "Close menu" : "Open menu"}
        >
          {isMobileMenuOpen ? (
            <RiCloseLine className="h-6 w-6" />
          ) : (
            <RiMenu3Line className="h-6 w-6" />
          )}
        </button>
      </div>

      {/* Navigation and Controls - Desktop */}
      <div className="hidden md:flex items-center space-x-4">
        {/* Language Switcher */}
        <div className="relative">
          <select
            value={lang}
            onChange={(e) => setLang(e.target.value)}
            className="bg-red-700 text-white p-2 rounded-md appearance-none pr-8 focus:outline-none focus:ring-2 focus:ring-white"
            aria-label="Select Language"
          >
            <option value="en">English</option>
            <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
            <option value="bn">‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
          </select>
          <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-white">
            <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
              <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
            </svg>
          </div>
        </div>

        {/* Dark Mode Toggle */}
        <button
          onClick={() => setDarkMode(!darkMode)}
          className="p-2 rounded-md hover:bg-red-700 transition-colors"
          aria-label={darkMode ? t.light : t.dark}
        >
          {darkMode ? '‚òÄÔ∏è' : 'üåô'}
        </button>

        {/* Logout Button */}
        {user && (
          <button
            onClick={handleLogout}
            className="bg-red-700 hover:bg-red-800 text-white font-semibold py-2 px-4 rounded-md transition-colors"
          >
            {t.logout}
          </button>
        )}
      </div>

      {/* Mobile Menu Overlay */}
      {isMobileMenuOpen && (
        <div className="md:hidden absolute top-0 left-0 w-full h-screen bg-red-600 z-10 flex flex-col items-center justify-center space-y-6 pt-16 pb-8">
          {/* Language Switcher */}
          <div className="relative w-48"> {/* Fixed width for mobile select */}
            <select
              value={lang}
              onChange={(e) => setLang(e.target.value)}
              className="bg-red-700 text-white p-3 rounded-md appearance-none pr-8 w-full focus:outline-none focus:ring-2 focus:ring-white text-lg"
              aria-label="Select Language"
            >
              <option value="en">English</option>
              <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
              <option value="bn">‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
            </select>
            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-white">
              <svg className="fill-current h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
              </svg>
            </div>
          </div>

          {/* Dark Mode Toggle */}
          <button
            onClick={() => { setDarkMode(!darkMode); setIsMobileMenuOpen(false); }}
            className="p-3 rounded-md hover:bg-red-700 transition-colors text-xl w-48"
            aria-label={darkMode ? t.light : t.dark}
          >
            {darkMode ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode'}
          </button>

          {/* Logout Button */}
          {user && (
            <button
              onClick={() => { handleLogout(); setIsMobileMenuOpen(false); }}
              className="bg-red-700 hover:bg-red-800 text-white font-semibold py-3 px-6 rounded-md transition-colors text-lg w-48"
            >
              {t.logout}
            </button>
          )}
        </div>
      )}
    </header>
  );
}

--- END FILE: src\components\Header.jsx ---

--- START FILE: src\components\LanguageSwitcher.jsx ---

// üìÅ src/components/LanguageSwitcher.jsx
import React from 'react';

export default function LanguageSwitcher({ lang, setLang }) {
  return (
    <select
      value={lang} // Controlled component: value is determined by the `lang` prop
      onChange={(e) => {
        setLang(e.target.value); // Update the language state
        localStorage.setItem('lang', e.target.value); // Persist the selected language in local storage
      }}
      className="border px-2 py-1 rounded bg-white dark:bg-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
      aria-label="Select application language" // Added for improved accessibility
    >
      {/* Language Options with Emojis */}
      <option value="en">üá¨üáß English</option>
      <option value="hi">üáÆüá≥ ‡§π‡§ø‡§Ç‡§¶‡•Ä</option>
      <option value="bn">üáßüá© ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
    </select>
  );
}

--- END FILE: src\components\LanguageSwitcher.jsx ---

--- START FILE: src\components\Modal.jsx ---

import React from 'react';

export default function Modal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  children, // For custom content
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  showConfirmButton = true,
}) {
  if (!isOpen) return null;

  return (
    // Overlay: Fixed position, full screen, semi-transparent black background, high z-index (z-50)
    // This div captures clicks outside the modal content to close it (if onClose is provided and appropriate)
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      {/* Modal Content Container:
          - bg-white dark:bg-gray-800: Background colors for light/dark modes.
          - p-6 md:p-8: Responsive padding.
          - rounded-lg: Rounded corners.
          - shadow-xl: Large shadow for depth.
          - w-full: Takes full width on small screens.
          - max-w-sm md:max-w-md: Responsive max-width.
          - max-h-[90vh] overflow-y-auto: Ensures modal content is scrollable if it exceeds viewport height.
          - text-center: Centers text horizontally.
          - relative z-50: Sets a new stacking context for its children and ensures it's on top.
      */}
      <div className="bg-white dark:bg-gray-800 p-6 md:p-8 rounded-lg shadow-xl w-full max-w-sm md:max-w-md max-h-[90vh] overflow-y-auto text-center relative z-50">
        <h3 className="text-xl md:text-2xl font-bold mb-4 text-gray-900 dark:text-white">{title || 'Attention'}</h3>
        {message && <p className="text-lg mb-4 text-gray-700 dark:text-gray-300">{message}</p>}

        {/* This is the placeholder for custom content, such as the score input fields.
            The 'children' prop renders whatever JSX is passed into the <Modal> component from its parent.
        */}
        {children}

        <div className="flex flex-col sm:flex-row justify-center gap-4 mt-6">
          {showConfirmButton && (
            <button
              onClick={onConfirm} // This triggers the confirmation logic (e.g., score update)
              className="bg-red-600 text-white px-6 py-2 rounded-md hover:bg-red-700 transition-colors font-semibold w-full sm:w-auto"
            >
              {confirmText}
            </button>
          )}
          <button
            onClick={onClose} // This triggers the modal to close
            className="bg-gray-400 text-white px-6 py-2 rounded-md hover:bg-gray-500 transition-colors font-semibold w-full sm:w-auto"
          >
            {cancelText}
          </button>
        </div>
      </div>
    </div>
  );
}

--- END FILE: src\components\Modal.jsx ---

--- START FILE: src\components\ProtectedRoute.jsx ---

import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth'; // Import useAuth hook

export default function ProtectedRoute({ children }) {
  const { user, loading } = useAuth(); // Destructure user and loading from useAuth

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-lg font-semibold animate-pulse">Checking authentication...</p>
      </div>
    );
  }

  // If user is not logged in, redirect to the login page
  if (!user) {
    return <Navigate to="/login" replace />; // Redirects to /login
  }

  // If user is logged in, render the children components
  return children;
}

--- END FILE: src\components\ProtectedRoute.jsx ---

--- START FILE: src\components\ScoreInputModalContent.jsx ---

import React, { useState, useEffect, useImperativeHandle, forwardRef } from 'react';

// Wrap the component with forwardRef
// The 'ref' parameter here is CRUCIAL for the parent component's ref to work
const ScoreInputModalContent = forwardRef(function ScoreInputModalContent(
  { fixture, initialScoreA, initialScoreB }, // Props (first argument)
  ref // The ref from the parent (second argument)
) {
  const [localTempScoreA, setLocalTempScoreA] = useState('');
  const [localTempScoreB, setLocalTempScoreB] = useState('');

  useEffect(() => {
    // This effect ensures initial values are set when props change (e.g., modal opens for a new fixture)
    setLocalTempScoreA(initialScoreA !== undefined && initialScoreA !== null ? String(initialScoreA) : '');
    setLocalTempScoreB(initialScoreB !== undefined && initialScoreB !== null ? String(initialScoreB) : '');
  }, [initialScoreA, initialScoreB]);

  // useImperativeHandle allows the parent to call methods on this child component via the ref
  useImperativeHandle(ref, () => ({
    getScoreA: () => localTempScoreA, // Expose a method to get the current state of score A
    getScoreB: () => localTempScoreB, // Expose a method to get the current state of score B
  }));

  // Handle changes in input fields
  const handleScoreAChange = (e) => {
    const value = e.target.value;
    // Allow only digits
    if (/^\d*$/.test(value)) {
      setLocalTempScoreA(value);
    }
  };

  const handleScoreBChange = (e) => {
    const value = e.target.value;
    // Allow only digits
    if (/^\d*$/.test(value)) {
      setLocalTempScoreB(value);
    }
  };

  return (
    // Added responsive padding: p-4 for small screens, md:p-6 for medium and larger
    <div className="p-4 md:p-6">
      {/* Changed to flex-col on small screens, sm:flex-row for horizontal on small-medium and up */}
      {/* Increased gap for better spacing, adjusted mb-6 to mb-8 */}
      <div className="flex flex-col sm:flex-row justify-around items-center gap-6 sm:gap-4 mb-8">
        <div className="text-center w-full sm:w-auto"> {/* Make div take full width on small screens */}
          <label htmlFor="scoreA" className="block text-sm sm:text-base font-medium text-gray-700 dark:text-gray-300 mb-2">
            {fixture.teamA} Score
          </label>
          <input
            id="scoreA"
            type="number"
            value={localTempScoreA}
            onChange={handleScoreAChange}
            // Adjusted width to w-full on small screens, w-28 on sm and up
            className="w-full sm:w-28 px-3 py-2 border border-gray-300 rounded-md text-center text-xl sm:text-lg font-semibold
                       dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            inputMode="numeric"
            pattern="[0-9]*"
          />
        </div>

        {/* Adjusted font size for separator */}
        <span className="text-3xl sm:text-2xl font-bold text-gray-900 dark:text-white my-4 sm:my-0">-</span>

        <div className="text-center w-full sm:w-auto"> {/* Make div take full width on small screens */}
          <label htmlFor="scoreB" className="block text-sm sm:text-base font-medium text-gray-700 dark:text-gray-300 mb-2">
            {fixture.teamB} Score
          </label>
          <input
            id="scoreB"
            type="number"
            value={localTempScoreB}
            onChange={handleScoreBChange}
            // Adjusted width to w-full on small screens, w-28 on sm and up
            className="w-full sm:w-28 px-3 py-2 border border-gray-300 rounded-md text-center text-xl sm:text-lg font-semibold
                       dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            inputMode="numeric"
            pattern="[0-9]*"
          />
        </div>
      </div>
    </div>
  );
});

export default ScoreInputModalContent;

--- END FILE: src\components\ScoreInputModalContent.jsx ---

--- START FILE: src\hooks\useAuth.js ---

import { useState, useEffect } from 'react';
import { auth, db } from '../firebase'; // Import auth and db from firebase.js
import {
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  GoogleAuthProvider, // Import GoogleAuthProvider
  signInWithPopup,    // Import signInWithPopup
  sendPasswordResetEmail // Import sendPasswordResetEmail
} from 'firebase/auth';
import { doc, setDoc } from 'firebase/firestore'; // For creating/updating user profiles in Firestore

/**
 * Custom React Hook for Firebase Authentication and User Profile Management.
 * Provides user authentication state, loading status, errors, and authentication functions.
 * @returns {{
 * user: import('firebase/auth').User | null,
 * loading: boolean,
 * error: Error | null,
 * register: (email: string, password: string) => Promise<import('firebase/auth').User>,
 * login: (email: string, password: string) => Promise<import('firebase/auth').User>,
 * loginWithGoogle: () => Promise<import('firebase/auth').User>, // New function
 * resetPassword: (email: string) => Promise<void>,             // New function
 * logout: () => Promise<void>
 * }}
 */
export const useAuth = () => {
  const [user, setUser] = useState(null); // Stores the Firebase User object when signed in
  const [loading, setLoading] = useState(true); // Indicates if the initial authentication state check is ongoing
  const [error, setError] = useState(null); // Stores any authentication-related errors

  /**
   * Effect hook to listen for changes in Firebase Authentication state.
   * This runs once on component mount and cleans up the listener on unmount.
   */
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        // User is signed in. Set the user state.
        setUser(firebaseUser);
        console.log("Firebase Auth State Changed: User signed in:", firebaseUser.uid);

        // Ensure a user document exists in Firestore for this user's UID.
        const userDocRef = doc(db, 'users', firebaseUser.uid);
        try {
          await setDoc(userDocRef, {
            email: firebaseUser.email,
            createdAt: firebaseUser.metadata?.creationTime,
            lastSignInTime: firebaseUser.metadata?.lastSignInTime,
            displayName: firebaseUser.displayName || 'Anonymous User',
          }, { merge: true });
          console.log("User profile ensured in Firestore for:", firebaseUser.uid);
        } catch (firestoreError) {
          console.error("Error ensuring user profile in Firestore:", firestoreError);
        }

      } else {
        // User is signed out (or initially not signed in). Clear the user state.
        setUser(null);
        console.log("Firebase Auth State Changed: User signed out.");
      }
      setLoading(false); // Authentication state check is complete, set loading to false.
    }, (authError) => {
      // Error occurred during authentication state change observation.
      console.error("Firebase Auth Listener Error:", authError);
      setError(authError); // Set error state
      setLoading(false); // Auth check is complete
    });

    // Cleanup function: Unsubscribe from the auth state listener when the component unmounts.
    return () => unsubscribe();
  }, []);

  /**
   * Registers a new user with email and password.
   * @param {string} email - The user's email address.
   * @param {string} password - The user's password.
   * @returns {Promise<import('firebase/auth').User>} A promise that resolves with the Firebase User object.
   * @throws {Error} Throws a Firebase Auth error if registration fails.
   */
  const register = async (email, password) => {
    setLoading(true);
    setError(null);
    try {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      console.log("User registered:", userCredential.user.uid);
      return userCredential.user;
    } catch (authError) {
      console.error("Registration error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  /**
   * Logs in an existing user with email and password.
   * @param {string} email - The user's email address.
   * @param {string} password - The user's password.
   * @returns {Promise<import('firebase/auth').User>} A promise that resolves with the Firebase User object.
   * @throws {Error} Throws a Firebase Auth error if login fails.
   */
  const login = async (email, password) => {
    setLoading(true);
    setError(null);
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      console.log("User logged in:", userCredential.user.uid);
      return userCredential.user;
    } catch (authError) {
      console.error("Login error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  /**
   * Logs in a user using Google authentication.
   * @returns {Promise<import('firebase/auth').User>} A promise that resolves with the Firebase User object.
   * @throws {Error} Throws a Firebase Auth error if login fails.
   */
  const loginWithGoogle = async () => {
    setLoading(true);
    setError(null);
    try {
      const provider = new GoogleAuthProvider();
      const userCredential = await signInWithPopup(auth, provider);
      console.log("User logged in with Google:", userCredential.user.uid);
      return userCredential.user;
    } catch (authError) {
      console.error("Google login error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  /**
   * Sends a password reset email to the specified email address.
   * @param {string} email - The user's email address.
   * @returns {Promise<void>} A promise that resolves when the email is sent.
   * @throws {Error} Throws a Firebase Auth error if sending fails.
   */
  const resetPassword = async (email) => {
    setLoading(true);
    setError(null);
    try {
      await sendPasswordResetEmail(auth, email);
      console.log("Password reset email sent to:", email);
    } catch (authError) {
      console.error("Password reset error:", authError);
      setError(authError);
      throw authError;
    } finally {
      setLoading(false);
    }
  };


  /**
   * Logs out the current user.
   * @returns {Promise<void>} A promise that resolves when the user is signed out.
   * @throws {Error} Throws a Firebase Auth error if logout fails.
   */
  const logout = async () => {
    setLoading(true);
    setError(null);
    try {
      await signOut(auth);
      console.log("User logged out.");
    } catch (authError) {
      console.error("Logout error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  // Return the user, loading state, error, and authentication functions for consumption by components.
  return { user, loading, error, register, login, loginWithGoogle, resetPassword, logout };
};

--- END FILE: src\hooks\useAuth.js ---

--- START FILE: src\hooks\useTournaments.js ---

import { useState, useEffect } from 'react';
import { collection, addDoc, onSnapshot, query, orderBy, where, serverTimestamp } from 'firebase/firestore';
import { db, auth } from '../firebase'; // Import auth from firebase.js

export const useTournaments = () => {
  const [tournaments, setTournaments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [userId, setUserId] = useState(null); // State to store the current user's ID

  // Listen for Firebase Auth state changes to get the user ID
  useEffect(() => {
    const unsubscribeAuth = auth.onAuthStateChanged(user => {
      if (user) {
        setUserId(user.uid);
      } else {
        setUserId(null); // Clear userId if user logs out
        setTournaments([]); // Clear tournaments if no user
        setLoading(false); // Stop loading if no user to fetch for
      }
    });
    return () => unsubscribeAuth();
  }, []); // Empty dependency array: runs once on mount, cleans up on unmount

  // Real-time listener for tournaments, now filtered by userId
  useEffect(() => {
    if (!userId) { // Only fetch if a userId is available
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Query tournaments where 'userId' field matches the current user's UID
      const tournamentsCollectionRef = collection(db, 'tournaments');
      const q = query(
        tournamentsCollectionRef,
        where('userId', '==', userId), // Filter by the current user's ID
        orderBy('createdAt', 'desc')
      );

      const unsubscribe = onSnapshot(q, (snapshot) => {
        const list = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setTournaments(list);
        setLoading(false);
      }, (err) => {
        console.error('Error fetching real-time tournaments for user:', userId, err);
        setError('Failed to load your tournaments. Please try again.');
        setLoading(false);
      });

      return () => unsubscribe(); // Clean up the listener
    } catch (err) {
      console.error("Error setting up tournaments listener:", err);
      setError("Failed to set up tournaments listener.");
      setLoading(false);
    }
  }, [userId]); // Re-run effect when userId changes

  // Function to create a new tournament, now requiring userId
  const createTournament = async (tournamentData) => {
    if (!userId) {
      // It's good to provide a more specific error or handle this in the UI
      console.error('Attempted to create tournament without authenticated user.');
      throw new Error('Authentication required to create a tournament.');
    }
    try {
      const docRef = await addDoc(collection(db, 'tournaments'), {
        ...tournamentData,
        userId: userId, // Associate tournament with the creator's ID
        createdAt: serverTimestamp(), // Use server timestamp for consistency
      });
      console.log("New tournament created with ID:", docRef.id);
      return docRef.id;
    } catch (err) {
      console.error('Error creating tournament:', err);
      throw new Error('Failed to create tournament.'); // Re-throw a generic error for the calling component
    }
  };

  return { tournaments, loading, error, createTournament };
};


--- END FILE: src\hooks\useTournaments.js ---

--- START FILE: src\pages\AIPredictionPage.jsx ---

import React, { useEffect, useState } from 'react';
import { db } from '../firebase';
import { collection, getDocs, doc, getDoc } from 'firebase/firestore';
import { useParams } from 'react-router-dom';

export default function AIPredictionPage() {
  const { id: tournamentId } = useParams();
  const [fixtures, setFixtures] = useState([]);
  const [selectedMatch, setSelectedMatch] = useState(null);
  const [result, setResult] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isPredicting, setIsPredicting] = useState(false);
  const [tournamentName, setTournamentName] = useState('');

  useEffect(() => {
    const fetchTournamentAndFixtures = async () => {
      setLoading(true);
      setError(null);
      try {
        if (!tournamentId) {
          setError("Tournament ID is missing.");
          setLoading(false);
          return;
        }

        // Fetch tournament name
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentDocSnap = await getDoc(tournamentDocRef);
        if (tournamentDocSnap.exists()) {
          setTournamentName(tournamentDocSnap.data().name);
        } else {
          setError("Tournament not found.");
          setLoading(false);
          return;
        }

        // Fetch fixtures
        const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
        const snapshot = await getDocs(fixturesCollectionRef);
        const data = snapshot.docs
          .map(doc => ({ id: doc.id, ...doc.data() }))
          .filter(fixture => fixture.status !== 'completed'); // Only show uncompleted matches
        setFixtures(data);
      } catch (err) {
        console.error('Error fetching data:', err);
        setError('Failed to load data. Please try again.');
      } finally {
        setLoading(false);
      }
    };
    fetchTournamentAndFixtures();
  }, [tournamentId]);

  const handlePredict = async () => {
    if (!selectedMatch) {
      setResult('Please select a match before predicting.');
      return;
    }
    setIsPredicting(true);
    setResult(null); // Clear previous results

    try {
      // IMPORTANT SECURITY NOTE:
      // NEVER expose your API_KEY directly in client-side code in a production application.
      // This is for demonstration purposes only.
      // In a real application, you should proxy this request through a secure backend server
      // (e.g., a Firebase Function or your own backend) to call the Generative AI API securely.
      // The API key should only be accessible on your backend.

      const API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
      if (!API_KEY) {
        throw new Error("Gemini API Key is not configured. Please check your .env file.");
      }

      const selectedFixture = fixtures.find(f => f.id === selectedMatch);
      if (!selectedFixture) {
        throw new Error("Selected fixture not found.");
      }

      const prompt = `Predict the winner or outcome of a football match between ${selectedFixture.teamA} and ${selectedFixture.teamB}.
      Consider general team strengths, current form (if known, otherwise assume average), and head-to-head records (if available, otherwise ignore).
      Provide a concise prediction.`;

      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error("API Error:", errorData);
        throw new Error(`Failed to get prediction: ${errorData.error.message || response.statusText}`);
      }

      const data = await response.json();
      const predictionText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No prediction could be generated.';
      setResult(predictionText);

    } catch (err) {
      console.error("Prediction error:", err);
      setResult(`Prediction failed: ${err.message}`);
      setError(err.message);
    } finally {
      setIsPredicting(false);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-lg font-semibold animate-pulse">Loading AI Prediction page...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white p-4">
        <p className="text-lg font-semibold text-red-500 text-center">Error: {error}</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
      <div className="p-4 sm:p-6 max-w-4xl mx-auto"> {/* Adjusted padding for responsiveness */}
        <h2 className="text-2xl sm:text-3xl font-extrabold mb-6 sm:mb-8 text-center text-red-600 dark:text-red-500">
          ‚ú® AI Match Prediction for {tournamentName}
        </h2>

        {fixtures.length === 0 ? (
          <p className="text-center text-gray-500 dark:text-gray-400 text-lg py-10">
            No upcoming fixtures to predict.
          </p>
        ) : (
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700">
            <p className="text-md sm:text-lg mb-4 text-gray-800 dark:text-gray-200">
              Select a match to get an AI-powered prediction:
            </p>

            <div className="flex flex-col sm:flex-row items-center gap-4 mb-6"> {/* Responsive layout for controls */}
              <select
                className="w-full sm:w-2/3 px-4 py-2 border border-gray-300 rounded-md bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white
                           focus:outline-none focus:ring-2 focus:ring-blue-500 text-base sm:text-lg"
                onChange={(e) => setSelectedMatch(e.target.value)}
                value={selectedMatch || ''}
              >
                <option value="">-- Select a Match --</option>
                {fixtures.map((fixture) => (
                  <option key={fixture.id} value={fixture.id}>
                    {fixture.teamA} vs {fixture.teamB} (
                    {new Date(fixture.timestamp?.toDate()).toLocaleDateString()})
                  </option>
                ))}
              </select>

              <button
                className={`w-full sm:w-1/3 px-4 py-2 rounded-md font-semibold text-lg transition-colors
                            ${selectedMatch && !isPredicting
                                ? 'bg-red-600 text-white hover:bg-red-700'
                                : 'bg-gray-300 text-gray-600 cursor-not-allowed dark:bg-gray-700 dark:text-gray-400'
                            }`}
                onClick={handlePredict}
                disabled={!selectedMatch || isPredicting}
              >
                {isPredicting ? 'Predicting...' : 'Predict Outcome'}
              </button>
            </div>

            {result && (
              <div className="mt-6 p-4 bg-blue-50 dark:bg-blue-900 border border-blue-200 dark:border-blue-700 rounded-md shadow-inner">
                <h3 className="text-lg sm:text-xl font-semibold text-blue-800 dark:text-blue-200 mb-2">Prediction:</h3>
                <p className="text-gray-700 dark:text-gray-300 text-base sm:text-lg">{result}</p>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

--- END FILE: src\pages\AIPredictionPage.jsx ---

--- START FILE: src\pages\AuthPage.jsx ---

import React, { useState, useEffect } from 'react';
import { useAuth } from '../hooks/useAuth';
import { FaEye, FaEyeSlash, FaGoogle } from 'react-icons/fa'; // Import icons
import { getPasswordStrength, getStrengthColor } from '../utils/passwordStrength'; // We'll create this utility

export default function AuthPage() {
  const { login, register, loginWithGoogle, resetPassword, loading, error } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isRegisterMode, setIsRegisterMode] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');
  const [successMessage, setSuccessMessage] = useState(''); // New state for success messages
  const [showPassword, setShowPassword] = useState(false); // State for password visibility
  const [passwordStrength, setPasswordStrength] = useState(0); // State for password strength (0-4)

  // Effect to listen to the global error from useAuth and display it
  useEffect(() => {
    if (error) {
      let friendlyError = 'An unexpected error occurred.';
      switch (error.code) {
        case 'auth/invalid-email':
          friendlyError = 'Invalid email address format.';
          break;
        case 'auth/user-disabled':
          friendlyError = 'This account has been disabled.';
          break;
        case 'auth/user-not-found':
        case 'auth/wrong-password':
          friendlyError = 'Invalid email or password.';
          break;
        case 'auth/email-already-in-use':
          friendlyError = 'This email is already registered. Try logging in.';
          break;
        case 'auth/weak-password':
          friendlyError = 'Password is too weak. It should be at least 6 characters.';
          break;
        case 'auth/network-request-failed':
          friendlyError = 'Network error. Please check your internet connection.';
          break;
        case 'auth/popup-closed-by-user': // For social login
          friendlyError = 'Login window closed. Please try again.';
          break;
        case 'auth/cancelled-popup-request': // For social login
          friendlyError = 'Another login attempt is in progress. Please wait or try again.';
          break;
        default:
          friendlyError = error.message;
      }
      setErrorMessage(friendlyError);
      setSuccessMessage(''); // Clear any success messages
    } else if (!loading) { // Clear errors when auth state is stable and no error
      setErrorMessage('');
    }
  }, [error, loading]);

  // Handle password change for strength indicator
  useEffect(() => {
    if (isRegisterMode) {
      setPasswordStrength(getPasswordStrength(password));
    } else {
      setPasswordStrength(0); // Reset strength when not in register mode
    }
  }, [password, isRegisterMode]);


  const handleSubmit = async (e) => {
    e.preventDefault();
    setErrorMessage('');
    setSuccessMessage('');

    try {
      if (isRegisterMode) {
        await register(email, password);
        setSuccessMessage('Registration successful! Please log in.');
        setIsRegisterMode(false); // Switch to login mode after successful registration
        setEmail(''); // Clear form fields
        setPassword('');
      } else {
        await login(email, password);
        // On successful login, useAuth hook's listener will update user state in App.jsx,
        // triggering navigation.
      }
    } catch (err) {
      // Error handled by useEffect listening to 'error' from useAuth
      console.error("Auth operation failed in AuthPage:", err);
    }
  };

  const handleGoogleLogin = async () => {
    setErrorMessage('');
    setSuccessMessage('');
    try {
      await loginWithGoogle();
      // On successful login, useAuth hook's listener will update user state in App.jsx,
      // triggering navigation.
    } catch (err) {
      // Error handled by useEffect listening to 'error' from useAuth
      console.error("Google login failed:", err);
    }
  };

  const handleForgotPassword = async () => {
    setErrorMessage('');
    setSuccessMessage('');
    if (!email) {
      setErrorMessage('Please enter your email to reset password.');
      return;
    }
    try {
      await resetPassword(email);
      setSuccessMessage('Password reset email sent! Check your inbox (and spam folder).');
      setEmail('');
    } catch (err) {
      console.error("Forgot password failed:", err);
      // Error handled by useEffect listening to 'error' from useAuth
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 px-4 py-8 relative overflow-hidden">
      {/* Background overlay for subtle texture/gradient matching the app's dark theme */}
      <div className="absolute inset-0 bg-gradient-to-br from-red-800 to-gray-900 opacity-20"></div>
      <div className="absolute inset-0 bg-pattern-dots opacity-5"></div> {/* Optional subtle pattern */}

      <div className="relative z-10 bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-md border border-red-700 backdrop-blur-sm bg-opacity-90 transition-all duration-300 hover:shadow-red-500/20">
        <div className="flex justify-center mb-6">
          {/* You can replace this with your actual logo component or image */}
          <img src="/logo.png" alt="Tournament Manager Logo" className="h-20 w-auto" onError={(e) => e.target.style.display = 'none'} />
          {/* Fallback text if image doesn't load or no logo is provided */}
          <h1 className="text-4xl font-extrabold text-red-500 hidden" style={{ display: 'none' }}>LTC</h1>
        </div>
        <h2 className="text-3xl font-extrabold mb-8 text-center text-white">
          {isRegisterMode ? 'üìù Create Account' : 'üîê Welcome Back!'}
        </h2>

        {/* Dynamic Message Area */}
        {errorMessage && (
          <div className="bg-red-900 text-red-200 p-3 rounded-md mb-4 text-center text-sm animate-fade-in-down border border-red-700">
            {errorMessage}
          </div>
        )}
        {successMessage && (
          <div className="bg-green-700 text-green-100 p-3 rounded-md mb-4 text-center text-sm animate-fade-in-down border border-green-500">
            {successMessage}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label htmlFor="email-address" className="sr-only">Email address</label>
            <input
              id="email-address"
              name="email"
              type="email"
              autoComplete="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Email address"
              className="w-full px-5 py-3 border border-gray-600 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-200"
              required
            />
          </div>
          <div className="mb-4 relative">
            <label htmlFor="password" className="sr-only">Password</label>
            <input
              id="password"
              name="password"
              type={showPassword ? 'text' : 'password'}
              autoComplete={isRegisterMode ? 'new-password' : 'current-password'}
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Password"
              className="w-full px-5 py-3 border border-gray-600 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-200 pr-12"
              required
            />
            <button
              type="button"
              onClick={() => setShowPassword(!showPassword)}
              className="absolute inset-y-0 right-0 pr-4 flex items-center text-gray-400 hover:text-white focus:outline-none transition-colors duration-200"
              aria-label={showPassword ? 'Hide password' : 'Show password'}
            >
              {showPassword ? <FaEyeSlash /> : <FaEye />}
            </button>
          </div>

          {isRegisterMode && password && (
            <div className="mb-4">
              <div className="text-sm font-medium text-gray-300 mb-1">
                Password Strength: <span className={`${getStrengthColor(passwordStrength)}`}>
                  {passwordStrength === 0 ? 'Too Short' : passwordStrength === 1 ? 'Weak' : passwordStrength === 2 ? 'Moderate' : passwordStrength === 3 ? 'Good' : 'Strong'}
                </span>
              </div>
              <div className="w-full bg-gray-600 rounded-full h-2">
                <div
                  className={`h-2 rounded-full transition-all duration-300`}
                  style={{
                    width: `${(passwordStrength / 4) * 100}%`,
                    backgroundColor: getStrengthColor(passwordStrength).replace('text-', 'bg-') // Map text color to background color
                  }}
                ></div>
              </div>
              <p className="text-xs text-gray-400 mt-1">
                {passwordStrength < 3 && 'Use 8+ characters, mixed case, numbers, and symbols for a stronger password.'}
              </p>
            </div>
          )}

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-red-600 text-white px-5 py-3 rounded-lg font-semibold text-lg hover:bg-red-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 active:scale-95"
          >
            {loading ? (isRegisterMode ? 'Registering...' : 'Logging In...') : isRegisterMode ? 'Register Account' : 'Login'}
          </button>
        </form>

        <div className="relative flex items-center justify-center my-6">
          <div className="flex-grow border-t border-gray-600"></div>
          <span className="flex-shrink mx-4 text-gray-500 text-sm">OR</span>
          <div className="flex-grow border-t border-gray-600"></div>
        </div>

        {/* Google Login Button */}
        <button
          onClick={handleGoogleLogin}
          disabled={loading}
          className="w-full flex items-center justify-center bg-gray-700 text-white px-5 py-3 rounded-lg font-semibold text-lg hover:bg-gray-600 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 active:scale-95"
        >
          <FaGoogle className="mr-3 text-xl" />
          {loading ? 'Signing In...' : 'Sign in with Google'}
        </button>

        <div className="flex justify-between items-center mt-6">
          <button
            onClick={() => setIsRegisterMode(!isRegisterMode)}
            className="text-red-400 hover:text-red-300 hover:underline text-sm transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 rounded-md p-1"
          >
            {isRegisterMode ? 'Already have an account? Login' : 'Need an account? Register'}
          </button>
          <button
            onClick={handleForgotPassword}
            className="text-gray-400 hover:text-gray-300 hover:underline text-sm transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500 rounded-md p-1"
          >
            Forgot Password?
          </button>
        </div>
      </div>
    </div>
  );
}

--- END FILE: src\pages\AuthPage.jsx ---

--- START FILE: src\pages\Dashboard.jsx ---

import React, { useState, useEffect } from 'react';
import { Link, useParams, useLocation } from 'react-router-dom';
import { db } from '../firebase';
import { collection, query, where, onSnapshot, addDoc, doc, deleteDoc, serverTimestamp, writeBatch, getDoc } from 'firebase/firestore';
import { useAuth } from '../hooks/useAuth';
import { useTournaments } from '../hooks/useTournaments'; // Import the custom hook

export default function Dashboard() {
  const { user, loading: authLoading } = useAuth();
  const { tournaments, loading, error, createTournament } = useTournaments(); // Use the custom hook
  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  const shareId = queryParams.get('shareId'); // Get shareId from URL

  const [isCreating, setIsCreating] = useState(false);
  const [newTournamentName, setNewTournamentName] = useState('');
  const [newTournamentType, setNewTournamentType] = useState('League');
  const [createError, setCreateError] = useState(null);

  // Modal State for custom actions like delete confirmation or info messages
  const [modalOpen, setModalOpen] = useState(false);
  const [modalMessage, setModalMessage] = useState('');
  const [modalConfirmAction, setModalConfirmAction] = useState(null);
  const [modalInputRequired, setModalInputRequired] = useState(false);
  const [modalInputLabel, setModalInputLabel] = useState('');
  const [modalInputValue, setModalInputValue] = useState('');
  const [modalCustomContent, setModalCustomContent] = useState(null); // For rendering custom JSX in modal

  // State to manage shared view access
  const [isViewOnly, setIsViewOnly] = useState(false);
  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);
  const [isOwner, setIsOwner] = useState(false);

  useEffect(() => {
    if (shareId) {
      setIsViewOnly(true);
      // Fetch tournament owner ID if in shared view
      const fetchOwner = async () => {
        try {
          const tournamentRef = doc(db, 'tournaments', shareId);
          const tournamentSnap = await getDoc(tournamentRef);
          if (tournamentSnap.exists()) {
            setTournamentOwnerId(tournamentSnap.data().userId);
          } else {
            console.error('Tournament not found for shareId:', shareId);
            // Optionally, redirect to a not-found page or show an error
          }
        } catch (err) {
          console.error('Error fetching tournament owner:', err);
        }
      };
      fetchOwner();
    } else {
      setIsViewOnly(false);
      setTournamentOwnerId(null);
    }
  }, [shareId]);

  useEffect(() => {
    // Determine if the current user is the owner of the tournament (if in shared view)
    if (isViewOnly && user && tournamentOwnerId) {
      setIsOwner(user.uid === tournamentOwnerId);
    } else if (!isViewOnly && user) {
      // If not in view-only mode, the user is always the owner of their own dashboard
      setIsOwner(true);
    } else {
      setIsOwner(false);
    }
  }, [isViewOnly, user, tournamentOwnerId]);

  // Handler for opening the custom modal
  const openCustomModal = (title, message, onConfirm, inputRequired = false, inputLabel = '', customContent = null) => {
    setModalMessage(message);
    setModalConfirmAction(() => onConfirm);
    setModalInputRequired(inputRequired);
    setModalInputLabel(inputLabel);
    setModalInputValue(''); // Clear previous input
    setModalCustomContent(customContent);
    setModalOpen(true);
  };

  // Handler for closing the custom modal
  const closeCustomModal = () => {
    setModalOpen(false);
    setModalMessage('');
    setModalConfirmAction(null);
    setModalInputRequired(false);
    setModalInputLabel('');
    setModalInputValue('');
    setModalCustomContent(null);
  };

  const handleModalConfirm = () => {
    if (modalConfirmAction) {
      modalConfirmAction(modalInputValue); // Pass the input value to the confirm action
    }
    closeCustomModal();
  };

  const handleModalCancel = () => {
    closeCustomModal();
  };

  const handleCreateTournament = async (e) => {
    e.preventDefault();
    setCreateError(null);
    if (!newTournamentName.trim()) {
      setCreateError("Tournament name cannot be empty.");
      return;
    }
    try {
      await createTournament({
        name: newTournamentName,
        type: newTournamentType,
      });
      setNewTournamentName('');
      setNewTournamentType('League');
      setIsCreating(false);
    } catch (err) {
      setCreateError(err.message || "Failed to create tournament.");
    }
  };

  const handleDeleteTournament = (tournamentId, tournamentName) => {
    // Only allow deletion if not in view-only mode AND the user is the owner
    if (isViewOnly || !isOwner) {
      openCustomModal('Access Denied', 'You do not have permission to delete tournaments in view-only mode.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Deletion',
      `Are you sure you want to delete the tournament "${tournamentName}"? This action cannot be undone.`,
      async () => {
        try {
          const tournamentRef = doc(db, 'tournaments', tournamentId);
          await deleteDoc(tournamentRef);
          // Also delete all subcollections (fixtures, teams, leaderboard entries, players, knockout matches, match stats)
          // This requires fetching all documents in each subcollection and deleting them in a batch.
          // Due to Firestore limitations on batch writes (max 500 operations), this might need to be paginated for very large tournaments.
          // For simplicity, we'll demonstrate a basic deletion for common subcollections.
          // In a production app, consider Cloud Functions for recursive deletes.

          const subcollections = ['fixtures', 'teams', 'leaderboard', 'players', 'knockoutMatches', 'match_stats'];
          for (const subcollectionName of subcollections) {
            const subcollectionRef = collection(db, `tournaments/${tournamentId}/${subcollectionName}`);
            const q = query(subcollectionRef);
            const snapshot = await getDocs(q);
            const batch = writeBatch(db);
            snapshot.docs.forEach(doc => {
              batch.delete(doc.ref);
            });
            if (snapshot.docs.length > 0) {
              await batch.commit();
              console.log(`Deleted ${snapshot.docs.length} documents from ${subcollectionName}`);
            }
          }

          openCustomModal('Success', `Tournament "${tournamentName}" and all its data deleted successfully!`, null, false);
        } catch (err) {
          console.error('Error deleting tournament:', err);
          openCustomModal('Error', 'Failed to delete tournament. Please try again.', null, false);
        }
      }
    );
  };

  const copyShareLink = () => {
    const shareLink = `${window.location.origin}/?shareId=${user.uid}`;
    navigator.clipboard.writeText(shareLink)
      .then(() => {
        openCustomModal('Link Copied!', 'The shareable link to your dashboard has been copied to your clipboard.', null, false);
      })
      .catch((err) => {
        console.error('Failed to copy link:', err);
        openCustomModal('Error', 'Failed to copy link. Please try manually.', null, false);
      });
  };

  // Conditional rendering for loading and error states
  if (authLoading || loading) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[calc(100vh-4rem)] bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-xl font-semibold">Loading dashboard...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[calc(100vh-4rem)] bg-gray-100 dark:bg-gray-900 text-red-500">
        <p className="text-xl font-semibold">Error: {error.message || "Failed to load tournaments."}</p>
      </div>
    );
  }

  return (
    <div className="min-h-[calc(100vh-4rem)] bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white p-6"> {/* Responsive padding and background */}
      <div className="max-w-6xl mx-auto"> {/* Max width and auto margins for centering on large screens */}
        <h2 className="text-3xl font-bold mb-6 text-center">Your Tournaments</h2>

        {/* Share Dashboard Section - only visible if user is logged in and not in view-only mode */}
        {user && !isViewOnly && (
          <div className="bg-blue-100 dark:bg-blue-900 p-4 rounded-lg shadow-md mb-6 text-center">
            <p className="text-blue-800 dark:text-blue-200 mb-3">
              Share your dashboard with others! They will be able to view your tournaments.
            </p>
            <button
              onClick={copyShareLink}
              className="bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors duration-200"
            >
              Copy Shareable Link
            </button>
          </div>
        )}

        {/* Create Tournament Section - only show if not view-only AND owner */}
        {!isViewOnly && isOwner && (
          <div className="mb-6 text-center">
            <button
              onClick={() => setIsCreating(!isCreating)}
              className="bg-red-600 text-white font-bold py-3 px-6 rounded-md shadow-lg hover:bg-red-700 transition-colors duration-200 uppercase tracking-wide transform hover:scale-105"
            >
              {isCreating ? 'Cancel Creation' : 'Create New Tournament'}
            </button>
          </div>
        )}

        {isCreating && (
          <div className="max-w-md mx-auto bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md mb-8"> {/* Responsive form container */}
            <h3 className="text-xl font-bold mb-4 text-center">‚ûï New Tournament Details</h3>
            <form onSubmit={handleCreateTournament} className="space-y-4">
              <div>
                <label htmlFor="tournamentName" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Tournament Name
                </label>
                <input
                  type="text"
                  id="tournamentName"
                  value={newTournamentName}
                  onChange={(e) => setNewTournamentName(e.target.value)}
                  className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white" // w-full for responsive input width
                  placeholder="e.g., Summer League 2024"
                  required
                />
              </div>
              <div>
                <label htmlFor="tournamentType" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Tournament Type
                </label>
                <select
                  id="tournamentType"
                  value={newTournamentType}
                  onChange={(e) => setNewTournamentType(e.target.value)}
                  className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white" // w-full for responsive select width
                >
                  <option value="League">League</option>
                  <option value="Knockout">Knockout</option>
                </select>
              </div>
              {createError && <p className="text-red-500 text-sm text-center">{createError}</p>}
              <button
                type="submit"
                className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors font-semibold"
              >
                Create Tournament
              </button>
            </form>
          </div>
        )}

        {/* Displaying Tournaments Section (Now always visible below action buttons/form) */}
        <div className="w-full max-w-4xl mx-auto"> {/* Max width and auto margins for centering */}
          <h3 className="text-xl font-bold mb-4 text-center mt-8">My Tournaments</h3>
          {tournaments.length === 0 ? (
            <p className="text-gray-500 text-center">
              {isViewOnly ? "This user has no tournaments yet." : "No tournaments found yet. Create one!"}
            </p>
          ) : (
            <ul className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"> {/* Responsive grid for tournament cards */}
              {tournaments.map(t => (
                <li key={t.id} className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border border-gray-200 dark:border-gray-700 flex flex-col justify-between items-center text-center transition-transform transform hover:scale-[1.02]">
                  <h4 className="font-semibold text-lg mb-1">{t.name}</h4>
                  <p className="text-sm text-gray-500 dark:text-gray-400 mb-2">{t.type}</p>
                  {t.createdAt && t.createdAt.seconds && (
                    <p className="text-xs text-gray-400 dark:text-gray-500 mb-3">
                      Created on: {new Date(t.createdAt.seconds * 1000).toLocaleDateString()}
                    </p>
                  )}
                  <div className="flex gap-2 mt-2"> {/* Container for buttons */}
                    <Link
                      to={`/tournament/${t.id}${shareId ? `?shareId=${shareId}` : ''}`}
                      className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors duration-200 text-sm"
                    >
                      Open Tournament
                    </Link>
                    {!isViewOnly && isOwner && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation(); // Prevent Link from triggering
                          handleDeleteTournament(t.id, t.name);
                        }}
                        className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600 transition-colors duration-200 text-sm"
                      >
                        Delete
                      </button>
                    )}
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>

        {/* Custom Modal Component (Inline implementation for Dashboard's specific needs) */}
        {modalOpen && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50"> {/* Responsive modal overlay */}
            <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm text-center"> {/* Responsive modal content container */}
              {/* Conditional rendering for custom content or default message/input */}
              {modalCustomContent || (
                <>
                  <p className="text-lg font-semibold mb-4">{modalMessage}</p>
                  {modalInputRequired && (
                    <div className="flex flex-col gap-2 mb-4">
                      {/* Maps over labels to create multiple inputs if needed. The value and onChange logic handles them as a comma-separated string. */}
                      {modalInputLabel.split(',').map((label, index) => (
                        <input
                          key={index} // Important for React list rendering
                          type="text" // Can be changed to "number" if input is strictly numeric
                          placeholder={label.trim()}
                          // This value logic is for handling multiple inputs with a single state string
                          value={modalInputValue.split(',')[index] || ''}
                          onChange={(e) => {
                            const newValues = modalInputValue.split(',');
                            newValues[index] = e.target.value;
                            setModalInputValue(newValues.join(','));
                          }}
                          className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500" // w-full for responsive input width
                        />
                      ))}
                    </div>
                  )}
                </>
              )}
              <div className="flex justify-center gap-4 mt-4">
                {modalConfirmAction && (
                  <button
                    onClick={handleModalConfirm}
                    className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors"
                  >
                    Confirm
                  </button>
                )}
                <button
                  onClick={handleModalCancel}
                  className="bg-gray-400 text-white px-4 py-2 rounded-md hover:bg-gray-500 transition-colors"
                >
                  {modalConfirmAction ? 'Cancel' : 'Close'}
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

--- END FILE: src\pages\Dashboard.jsx ---

--- START FILE: src\pages\FixturesPage.jsx ---

// üìÅ src/pages/FixturesPage.jsx
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  collection,
  query,
  orderBy,
  onSnapshot,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  writeBatch,
  getDocs,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../firebase';
import { useAuth } from '../hooks/useAuth';
import Modal from '../components/Modal';
import ScoreInputModalContent from '../components/ScoreInputModalContent';

export default function FixturesPage() {
  const { id: tournamentId } = useParams();
  
  // All hooks must be declared at the top level, unconditionally
  const [fixtures, setFixtures] = useState([]);
  const [teams, setTeams] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isAddingFixture, setIsAddingFixture] = useState(false);
  const [newFixture, setNewFixture] = useState({
    teamA: '',
    teamB: '',
    date: '', // Storing as YYYY-MM-DD string
    timestamp: null, // Firestore Timestamp object for ordering
    status: 'scheduled',
    scoreA: 0,
    scoreB: 0,
    weekNumber: 0, // Default to 0 for manually added fixtures
  });
  const [fixtureError, setFixtureError] = useState('');
  const [tournamentDetails, setTournamentDetails] = useState(null);
  const { user } = useAuth();
  const [isViewOnly, setIsViewOnly] = useState(false); // State to check if it's a shared view
  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);

  // State for Custom Modal
  const [customModalOpen, setCustomModalOpen] = useState(false);
  const [customModalTitle, setCustomModalTitle] = useState('');
  const [customModalMessage, setCustomModalMessage] = useState('');
  const [customModalOnConfirm, setCustomModalOnConfirm] = useState(null);
  const [customModalShowConfirm, setCustomModalShowConfirm] = useState(true);

  // State for Score Input Modal
  const [scoreModalOpen, setScoreModalOpen] = useState(false);
  const [editingFixture, setEditingFixture] = useState(null);
  const scoreInputRef = useRef(null); // Ref for ScoreInputModalContent

  // Helper to open the custom modal
  const openCustomModal = useCallback((title, message, onConfirm = null, showConfirm = true) => {
    setCustomModalTitle(title);
    setCustomModalMessage(message);
    setCustomModalOnConfirm(() => onConfirm); // Use a function to set state with a function
    setCustomModalShowConfirm(showConfirm);
    setCustomModalOpen(true);
  }, []);

  // Helper to close the custom modal
  const closeCustomModal = useCallback(() => {
    setCustomModalOpen(false);
    setCustomModalTitle('');
    setCustomModalMessage('');
    setCustomModalOnConfirm(null);
    setCustomModalShowConfirm(true);
  }, []);

  // Helper function to shuffle an array (Fisher-Yates)
  const shuffleArray = useCallback((array) => {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
  }, []);

  // Fetch tournament details and set view-only mode
  useEffect(() => {
    if (!tournamentId) return;

    const tournamentRef = doc(db, 'tournaments', tournamentId);
    const unsubscribe = onSnapshot(
      tournamentRef,
      (docSnap) => {
        if (docSnap.exists()) {
          const data = docSnap.data();
          setTournamentDetails(data);
          setTournamentOwnerId(data.userId);
          // Determine if it's a view-only link
          if (window.location.pathname.startsWith('/share/')) {
            setIsViewOnly(true);
          } else {
            setIsViewOnly(false);
          }
        } else {
          setError('Tournament not found.');
          setLoading(false);
        }
      },
      (err) => {
        console.error('Error fetching tournament details:', err);
        setError('Failed to load tournament details.');
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, [tournamentId, user]);

  // Listen to Teams and Fixtures collections
  useEffect(() => {
    if (!tournamentId) return;

    // Teams subscription
    const teamsCollectionRef = collection(db, `tournaments/${tournamentId}/teams`);
    const unsubscribeTeams = onSnapshot(
      query(teamsCollectionRef, orderBy('name', 'asc')),
      (snapshot) => {
        setTeams(snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() })));
      },
      (err) => {
        console.error('Error fetching real-time teams:', err);
        if (!isViewOnly) {
          setError('Failed to load teams.');
        }
      }
    );

    // Fixtures subscription
    const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
    const unsubscribeFixtures = onSnapshot(
      query(fixturesCollectionRef, orderBy('timestamp', 'asc')), // Order by timestamp
      (snapshot) => {
        const fetchedFixtures = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
          // Convert Firestore Timestamp to Date string for input[type="date"]
          date: doc.data().timestamp ? new Date(doc.data().timestamp.toDate()).toISOString().split('T')[0] : '',
        }));
        setFixtures(fetchedFixtures);
        setLoading(false);
      },
      (err) => {
        console.error('Error fetching real-time fixtures:', err);
        if (!isViewOnly) {
          setError('Failed to load fixtures.');
        }
        setLoading(false);
      }
    );

    return () => {
      unsubscribeTeams();
      unsubscribeFixtures();
    };
  }, [tournamentId, isViewOnly]);

  // Generate Round Robin Fixtures
  const generateRoundRobinFixtures = useCallback((teamNames, isHomeAndAway) => {
    const numTeams = teamNames.length;
    if (numTeams < 2) return [];

    let teamsForScheduling = [...teamNames];
    // If odd number of teams, add a 'BYE' team
    if (numTeams % 2 !== 0) {
      teamsForScheduling.push('BYE');
    }

    const n = teamsForScheduling.length;
    const roundsNeeded = n - 1; // Number of rounds in a single round-robin

    let allLogicalRounds = [];

    for (let roundNum = 0; roundNum < roundsNeeded; roundNum++) {
      let currentRoundFixtures = [];
      // Pair the first team with the last rotating team
      const fixedTeam = teamsForScheduling[0];
      const rotatingTeamOppositeFixed = teamsForScheduling[(roundNum + (n - 1)) % (n - 1) + 1] || teamsForScheduling[n - 1]; // Robust indexing

      if (fixedTeam !== 'BYE' && rotatingTeamOppositeFixed !== 'BYE') {
        if (roundNum % 2 === 0) {
          currentRoundFixtures.push({ teamA: fixedTeam, teamB: rotatingTeamOppositeFixed });
        } else {
          currentRoundFixtures.push({ teamA: rotatingTeamOppositeFixed, teamB: fixedTeam });
        }
      }

      // Pair the remaining teams
      for (let i = 1; i < n / 2; i++) {
        const team1 = teamsForScheduling[(roundNum + i) % (n - 1) + 1];
        const team2 = teamsForScheduling[(roundNum + n - 1 - i) % (n - 1) + 1];

        if (team1 !== 'BYE' && team2 !== 'BYE') {
          if (i % 2 === 0) {
            currentRoundFixtures.push({ teamA: team1, teamB: team2 });
          } else {
            currentRoundFixtures.push({ teamA: team2, teamB: team1 });
          }
        }
      }
      shuffleArray(currentRoundFixtures); // Shuffle fixtures within each round
      allLogicalRounds.push(currentRoundFixtures);
    }

    let finalFixturesForDb = [];
    if (isHomeAndAway) {
      let returnRounds = [];
      allLogicalRounds.forEach(round => {
        let returnRound = [];
        round.forEach(fixture => {
          returnRound.push({ teamA: fixture.teamB, teamB: fixture.teamA });
        });
        returnRounds.push(returnRound);
      });
      allLogicalRounds = [...allLogicalRounds, ...returnRounds];
    }

    allLogicalRounds.forEach((roundFixtures, index) => {
      const weekNumber = index + 1; // Start week numbers from 1
      roundFixtures.forEach(fixture => {
        finalFixturesForDb.push({
          ...fixture,
          weekNumber: weekNumber,
        });
      });
    });

    return finalFixturesForDb;
  }, [shuffleArray]);

  const handleGenerateFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to generate fixtures in view-only mode.', null, false);
      return;
    }

    if (teams.length < 2) {
      openCustomModal('Info', 'You need at least two teams to generate fixtures!', null, false);
      return;
    }

    if (!tournamentDetails) {
      openCustomModal('Error', 'Tournament details not loaded. Cannot generate fixtures.', null, false);
      return;
    }

    const currentFixtureOption = tournamentDetails.fixtureOption || 'Single Matches';
    const teamNames = teams.map(t => t.name);
    const generatedFixturesWithWeekNumbers = generateRoundRobinFixtures(teamNames, currentFixtureOption === 'Home and Away Matches');

    let currentDate = new Date();
    currentDate.setHours(12, 0, 0, 0); // Normalize to midday to avoid timezone issues

    const finalFixturesToSave = [];

    // Group fixtures by week number and ensure weeks are processed in order
    const groupedByWeek = generatedFixturesWithWeekNumbers.reduce((acc, fixture) => {
      const weekNum = fixture.weekNumber;
      if (!acc[weekNum]) {
        acc[weekNum] = [];
      }
      acc[weekNum].push(fixture);
      return acc;
    }, {});

    const sortedWeekNumbers = Object.keys(groupedByWeek).sort((a, b) => parseInt(a) - parseInt(b));

    sortedWeekNumbers.forEach(weekNum => {
      const fixturesInThisWeek = groupedByWeek[weekNum];
      fixturesInThisWeek.forEach(fixture => {
        finalFixturesToSave.push({
          teamA: fixture.teamA,
          teamB: fixture.teamB,
          date: currentDate.toISOString().split('T')[0], // Store date as string for easy display
          timestamp: new Date(currentDate), // Store as Date object for Firestore Timestamp conversion
          status: 'scheduled',
          scoreA: 0,
          scoreB: 0,
          weekNumber: parseInt(weekNum), // Store week number for display/grouping
        });
      });
      currentDate.setDate(currentDate.getDate() + 7); // Increment date by 7 days for next week
    });


    if (finalFixturesToSave.length === 0) {
      openCustomModal('Info', 'No fixtures could be generated. Check your team list and fixture options.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Fixture Generation',
      `This will delete ALL existing fixtures and generate ${finalFixturesToSave.length} new ones based on '${currentFixtureOption}'. Are you sure?`,
      async () => {
        const batch = writeBatch(db);
        const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);

        // Delete existing fixtures
        const existingFixturesSnapshot = await getDocs(fixturesCollectionRef);
        existingFixturesSnapshot.docs.forEach((doc) => {
          batch.delete(doc.ref);
        });

        // Add new fixtures
        finalFixturesToSave.forEach(fixture => {
          const newFixtureRef = doc(fixturesCollectionRef); // Let Firestore auto-generate ID
          batch.set(newFixtureRef, fixture);
        });

        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', `Successfully generated ${finalFixturesToSave.length} fixtures!`, null, false);
          // Optionally, trigger a leaderboard update here if it depends on fixtures
          // For now, assume leaderboard update is handled elsewhere or is reactive to fixture changes
        } catch (err) {
          console.error('Error generating fixtures:', err);
          openCustomModal('Error', 'Failed to generate fixtures. Please try again.');
        }
      }
    );
  };

  const handleAddFixture = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to add fixtures in view-only mode.', null, false);
      return;
    }

    setFixtureError('');
    if (!newFixture.teamA || !newFixture.teamB || !newFixture.date) {
      setFixtureError('Please select both teams and a date for the fixture.');
      return;
    }
    if (newFixture.teamA === newFixture.teamB) {
      setFixtureError('Teams cannot be the same.');
      return;
    }

    try {
      const fixtureDate = new Date(newFixture.date);
      // Validate date object
      if (isNaN(fixtureDate.getTime())) {
        setFixtureError('Invalid date format.');
        return;
      }
      fixtureDate.setHours(12, 0, 0, 0); // Normalize date to midday UTC

      await addDoc(collection(db, `tournaments/${tournamentId}/fixtures`), {
        ...newFixture,
        timestamp: fixtureDate, // Store as Date object for Firestore
        scoreA: 0, // Default scores
        scoreB: 0,
        status: 'scheduled', // Default status
        weekNumber: 0, // Manually added fixtures default to week 0, can be updated later if needed
      });
      setNewFixture({ teamA: '', teamB: '', date: '', timestamp: null, status: 'scheduled', scoreA: 0, scoreB: 0 }); // Reset form
      setFixtureError(''); // Clear any previous errors
      setIsAddingFixture(false); // Hide the form after adding
    } catch (err) {
      console.error('Error adding fixture:', err);
      setFixtureError('Failed to add fixture.');
    }
  };

  const handleDeleteFixture = async (fixtureId) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to delete fixtures in view-only mode.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Delete',
      'Are you sure you want to delete this fixture? This action cannot be undone.',
      async () => {
        try {
          await deleteDoc(doc(db, `tournaments/${tournamentId}/fixtures`, fixtureId));
          closeCustomModal();
          // Assume leaderboard updates reactively or a separate function triggers it
        } catch (err) {
          console.error('Error deleting fixture:', err);
          openCustomModal('Error', 'Failed to delete fixture. Please try again.');
        }
      }
    );
  };

  const handleClearAllFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to clear all fixtures in view-only mode.', null, false);
      return;
    }

    if (fixtures.length === 0) {
      openCustomModal('Info', 'No fixtures to clear.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Clear All Fixtures',
      'Are you sure you want to delete ALL fixtures? This will reset match data for the leaderboard.',
      async () => {
        const batch = writeBatch(db);
        fixtures.forEach(fixture => {
          const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, fixture.id);
          batch.delete(fixtureRef);
        });

        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', 'All fixtures cleared successfully!', null, false);
          // Assuming leaderboard updates reactively
        } catch (err) {
          console.error('Error clearing all fixtures:', err);
          openCustomModal('Error', 'Failed to clear all fixtures. Please try again.');
        }
      }
    );
  };

  const handleOpenScoreModal = (fixture) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to edit scores in view-only mode.', null, false);
      return;
    }
    setEditingFixture(fixture);
    setScoreModalOpen(true);
  };

  const handleCloseScoreModal = () => {
    setScoreModalOpen(false);
    setEditingFixture(null);
  };

  const handleUpdateScore = async () => {
    if (!editingFixture || !scoreInputRef.current) return;

    const scoreA = scoreInputRef.current.getScoreA();
    const scoreB = scoreInputRef.current.getScoreB();

    const parsedScoreA = parseInt(scoreA);
    const parsedScoreB = parseInt(scoreB);

    if (isNaN(parsedScoreA) || isNaN(parsedScoreB)) {
      openCustomModal('Invalid Input', 'Please enter valid numbers for scores.', null, false);
      return;
    }

    try {
      const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, editingFixture.id);
      await updateDoc(fixtureRef, {
        scoreA: parsedScoreA,
        scoreB: parsedScoreB,
        status: 'completed', // Mark as completed once score is updated
      });
      handleCloseScoreModal();
      openCustomModal('Success', 'Score updated successfully!', null, false);
      // Assuming leaderboard updates reactively
    } catch (err) {
      console.error('Error updating score:', err);
      openCustomModal('Error', 'Failed to update score. Please try again.', null, false);
    }
  };

  const groupedFixtures = useMemo(() => {
    return fixtures.reduce((acc, fixture) => {
      const week = fixture.weekNumber > 0 ? `Week ${fixture.weekNumber}` : 'Manual Fixtures';
      if (!acc[week]) {
        acc[week] = [];
      }
      acc[week].push(fixture);
      return acc;
    }, {});
  }, [fixtures]);

  const sortedWeeks = useMemo(() => {
    return Object.keys(groupedFixtures).sort((a, b) => {
      if (a === 'Manual Fixtures') return 1; // Manual fixtures last
      if (b === 'Manual Fixtures') return -1;
      return parseInt(a.split(' ')[1]) - parseInt(b.split(' ')[1]); // Sort by week number
    });
  }, [groupedFixtures]);


  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        Loading fixtures...
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex justify-center items-center min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-red-500">Error: {error}</p>
      </div>
    );
  }

  return (
    <div className="flex flex-col min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className={`bg-red-600 text-white p-4 font-bold text-lg ${isViewOnly ? 'flex justify-around' : 'grid grid-cols-2 md:flex md:justify-around'}`}>
        <Link to={isViewOnly ? `/share/${tournamentId}` : `/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
        <Link to={isViewOnly ? `/share/${tournamentId}/fixtures` : `/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
        <Link to={isViewOnly ? `/share/${tournamentId}/players` : `/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors hidden md:block">TOP SCORERS</Link>
        <Link to={isViewOnly ? `/share/${tournamentId}/knockout` : `/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors hidden md:block">KNOCKOUT</Link>
        {/* Add responsive navigation for other pages if needed for small screens */}
      </div>

      <div className="p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full">
        <h2 className="text-2xl sm:text-3xl font-bold mb-6 text-center text-gray-800 dark:text-white">
          üìÖ Fixtures: {tournamentDetails?.name || 'Loading...'}
        </h2>

        {!isViewOnly && (
          <div className="flex flex-col sm:flex-row justify-center items-center gap-4 mb-6">
            <button
              onClick={handleGenerateFixtures}
              className="bg-green-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
            >
              Generate Fixtures
            </button>
            <button
              onClick={() => setIsAddingFixture(!isAddingFixture)}
              className="bg-blue-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
            >
              {isAddingFixture ? 'Hide Add Fixture Form' : '‚ûï Add New Fixture'}
            </button>
            <button
              onClick={handleClearAllFixtures}
              className="bg-red-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
            >
              Clear All Fixtures
            </button>
          </div>
        )}

        {isAddingFixture && !isViewOnly && (
          <div className="mb-8 p-6 bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700">
            <h3 className="text-xl font-bold mb-4 text-center">Add New Fixture</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">
              <div>
                <label htmlFor="teamA" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Team A</label>
                <select
                  id="teamA"
                  value={newFixture.teamA}
                  onChange={(e) => setNewFixture({ ...newFixture, teamA: e.target.value })}
                  className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="" disabled>Select Team A</option>
                  {teams.map((team) => (
                    <option key={team.id} value={team.name}>{team.name}</option>
                  ))}
                </select>
              </div>
              <div>
                <label htmlFor="teamB" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Team B</label>
                <select
                  id="teamB"
                  value={newFixture.teamB}
                  onChange={(e) => setNewFixture({ ...newFixture, teamB: e.target.value })}
                  className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="" disabled>Select Team B</option>
                  {teams.map((team) => (
                    <option key={team.id} value={team.name}>{team.name}</option>
                  ))}
                </select>
              </div>
              <div>
                <label htmlFor="date" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Date</label>
                <input
                  type="date"
                  id="date"
                  value={newFixture.date}
                  onChange={(e) => setNewFixture({ ...newFixture, date: e.target.value })}
                  className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>
            {fixtureError && <p className="text-red-500 text-center mb-4">{fixtureError}</p>}
            <button
              onClick={handleAddFixture}
              className="w-full bg-green-500 text-white px-6 py-3 rounded-lg shadow-md hover:bg-green-600 transition-colors duration-200 font-semibold text-base"
            >
              Add Fixture
            </button>
          </div>
        )}

        {fixtures.length === 0 ? (
          <p className="text-center text-gray-500 dark:text-gray-400 text-lg mt-8">No fixtures found. Generate or add some!</p>
        ) : (
          <div className="space-y-8 mt-8">
            {sortedWeeks.map(week => (
              <div key={week} className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl">
                <h3 className="text-xl sm:text-2xl font-bold mb-6 text-center text-gray-800 dark:text-white">{week}</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                  {groupedFixtures[week].map((fixture) => (
                    <div
                      key={fixture.id}
                      className="bg-gray-50 dark:bg-gray-700 p-6 rounded-lg shadow-md flex flex-col justify-between transition-transform transform hover:scale-[1.02] border border-gray-200 dark:border-gray-600"
                    >
                      <div>
                        <p className="text-sm text-gray-500 dark:text-gray-300 mb-2">{fixture.date}</p>
                        <div className="flex justify-between items-center text-lg font-semibold mb-4">
                          <span>{fixture.teamA}</span>
                          <span className="mx-2">vs</span>
                          <span>{fixture.teamB}</span>
                        </div>
                        <div className="text-center text-2xl font-bold mb-4">
                          {fixture.status === 'completed' ? (
                            <span className="text-green-600 dark:text-green-400">
                              {fixture.scoreA} - {fixture.scoreB}
                            </span>
                          ) : (
                            <span className="text-yellow-600 dark:text-yellow-400">
                              Scheduled
                            </span>
                          )}
                        </div>
                      </div>
                      {!isViewOnly && (
                        <div className="flex flex-col sm:flex-row gap-3 mt-4">
                          <button
                            onClick={() => handleOpenScoreModal(fixture)}
                            className="flex-1 bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 transition-colors font-semibold"
                          >
                            Update Score
                          </button>
                          <button
                            onClick={() => handleDeleteFixture(fixture.id)}
                            className="flex-1 bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600 transition-colors font-semibold"
                          >
                            Delete
                          </button>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Custom Modal */}
      <Modal
        isOpen={customModalOpen}
        onClose={closeCustomModal}
        onConfirm={customModalOnConfirm}
        title={customModalTitle}
        message={customModalMessage}
        showConfirmButton={customModalOnConfirm !== null && customModalShowConfirm}
        confirmText="Confirm"
        cancelText="Close"
      />

      {/* Score Input Modal */}
      {editingFixture && (
        <Modal
          isOpen={scoreModalOpen}
          onClose={handleCloseScoreModal}
          onConfirm={handleUpdateScore}
          title={`Update Score for ${editingFixture.teamA} vs ${editingFixture.teamB}`}
          confirmText="Save Score"
        >
          <ScoreInputModalContent
            ref={scoreInputRef}
            fixture={editingFixture}
            initialScoreA={editingFixture.scoreA}
            initialScoreB={editingFixture.scoreB}
          />
        </Modal>
      )}
    </div>
  );
}

--- END FILE: src\pages\FixturesPage.jsx ---

--- START FILE: src\pages\KnockoutPage.jsx ---

import React, { useEffect, useState, useCallback, useRef } from 'react';
import { useParams, Link } from 'react-router-dom';
import { db } from '../firebase';
import { doc, getDoc, collection, addDoc, query, orderBy, onSnapshot, updateDoc, deleteDoc } from 'firebase/firestore';
import { useAuth } from '../hooks/useAuth';
import Modal from '../components/Modal'; // Assuming you have a Modal component
import ScoreInputModalContent from '../components/ScoreInputModalContent'; // Import the new component

export default function KnockoutPage({ readOnly = false }) {
    const { id: tournamentId } = useParams();
    const { user, loading: authLoading } = useAuth();
    const [tournamentName, setTournamentName] = useState('Loading...');
    const [matches, setMatches] = useState([]); // Renamed from 'rounds' to 'matches' for clarity
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [tournamentOwnerId, setTournamentOwnerId] = useState(null);

    const [isAddingMatch, setIsAddingMatch] = useState(false);
    const [newMatch, setNewMatch] = useState({
        round: '',
        teamA: '',
        teamB: '',
        winner: null,
        scoreA: null, // Use null initially for scores
        scoreB: null,
        status: 'scheduled'
    });

    const [modalOpen, setModalOpen] = useState(false);
    const [modalTitle, setModalTitle] = useState('');
    const [modalMessage, setModalMessage] = useState('');
    const [modalShowConfirmButton, setModalShowConfirmButton] = useState(true);
    const [modalContent, setModalContent] = useState(null);
    const [modalConfirmAction, setModalConfirmAction] = useState(null); // <--- Added this line
    const scoreInputRef = useRef(null);

    const openModal = useCallback((title, message, showConfirm, content = null, confirmAction = null) => {
        setModalTitle(title);
        setModalMessage(message);
        setModalShowConfirmButton(showConfirm);
        setModalContent(content);
        setModalConfirmAction(() => confirmAction); // <--- Set the confirm action here
        setModalOpen(true);
    }, []);

    const closeModal = useCallback(() => {
        setModalOpen(false);
        setModalTitle('');
        setModalMessage('');
        setModalShowConfirmButton(true);
        setModalContent(null);
        setModalConfirmAction(null); // Clear confirm action on close
    }, []);

    // Determine if the current user has view-only access
    const isViewOnly = readOnly || (user && tournamentOwnerId && user.uid !== tournamentOwnerId);

    useEffect(() => {
        const fetchData = async () => {
            if (authLoading) return; // Wait for Firebase auth to load

            if (!tournamentId) {
                setError("No tournament ID provided.");
                setLoading(false);
                return;
            }

            try {
                // Fetch tournament details to get name and owner ID
                const tournamentDocRef = doc(db, 'tournaments', tournamentId);
                const tournamentSnap = await getDoc(tournamentDocRef);

                if (tournamentSnap.exists()) {
                    const data = tournamentSnap.data();
                    setTournamentName(data.name);
                    setTournamentOwnerId(data.userId);

                    // If not readOnly and current user is not the owner, set an error
                    if (!readOnly && user && data.userId !== user.uid) {
                        setError("You do not have permission to modify this tournament.");
                    }
                } else {
                    setError("Tournament not found.");
                    setLoading(false);
                    return;
                }

                // Set up real-time listener for knockout matches
                const matchesCollectionRef = collection(db, `tournaments/${tournamentId}/knockoutMatches`);
                // Order by round (e.g., "Quarter-Finals", "Semi-Finals") and then by teamA name for consistent display
                const q = query(matchesCollectionRef, orderBy('round', 'asc'), orderBy('teamA', 'asc'));

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const fetchedMatches = snapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data(),
                        scoreA: doc.data().scoreA ?? null, // Ensure scores are null if not set
                        scoreB: doc.data().scoreB ?? null,
                    }));
                    setMatches(fetchedMatches);
                    setLoading(false);
                    setError(null); // Clear any previous errors if data loads successfully
                }, (err) => {
                    console.error('Real-time listener error for knockout matches:', err);
                    setError('Failed to load knockout matches. Please try again.');
                    setLoading(false);
                });

                return () => unsubscribe(); // Cleanup listener on unmount

            } catch (err) {
                console.error("Error fetching tournament data:", err);
                setError("Failed to load tournament data.");
                setLoading(false);
            }
        };

        fetchData();
    }, [tournamentId, user, authLoading, readOnly]);


    // Group matches by round for display
    const groupedRounds = matches.reduce((acc, match) => {
        const roundName = match.round || 'Unnamed Round';
        if (!acc[roundName]) {
            acc[roundName] = [];
        }
        acc[roundName].push(match);
        return acc;
    }, {});

    // Sort round names for consistent display order (e.g., Quarter-Finals, Semi-Finals, Final)
    const sortedRoundNames = Object.keys(groupedRounds).sort((a, b) => {
        const order = {
            'Round of 16': 1, 'Quarter-Finals': 2, 'Semi-Finals': 3, 'Final': 4, 'Winner': 5
        };
        return (order[a] || 99) - (order[b] || 99);
    });

    // Handle adding a new knockout match
    const handleAddMatch = async () => {
        if (isViewOnly || user?.uid !== tournamentOwnerId) {
            openModal('Access Denied', 'You do not have permission to add matches.', false);
            return;
        }
        if (!newMatch.round.trim() || !newMatch.teamA.trim() || !newMatch.teamB.trim()) {
            openModal('Validation Error', 'Please fill in all match details.', false);
            return;
        }
        try {
            await addDoc(collection(db, `tournaments/${tournamentId}/knockoutMatches`), {
                ...newMatch,
                scoreA: null, // Ensure scores are saved as null initially
                scoreB: null,
                status: 'scheduled'
            });
            setNewMatch({ round: '', teamA: '', teamB: '', winner: null, scoreA: null, scoreB: null, status: 'scheduled' });
            setIsAddingMatch(false);
            openModal('Success', 'Match added successfully!', false);
        } catch (err) {
            console.error('Error adding match:', err);
            openModal('Error', 'Failed to add match. Please try again.', false);
        }
    };

    // Handle updating scores for an existing knockout match
    const handleUpdateScores = useCallback(async (matchToEdit) => {
        if (isViewOnly || user?.uid !== tournamentOwnerId) {
            openModal('Access Denied', 'You do not have permission to update scores.', false);
            return;
        }

        const confirmAction = async () => {
            if (!scoreInputRef.current) {
                openModal('Error', 'Internal error: Cannot read scores. Please try again.', false);
                return;
            }
            const scoreA = scoreInputRef.current.getScoreA();
            const scoreB = scoreInputRef.current.getScoreB();

            const parsedScoreA = parseInt(scoreA);
            const parsedScoreB = parseInt(scoreB);

            if (isNaN(parsedScoreA) || isNaN(parsedScoreB)) {
                openModal('Invalid Input', 'Please enter valid numbers for scores.', true,
                    <ScoreInputModalContent
                        ref={scoreInputRef}
                        fixture={matchToEdit}
                        initialScoreA={scoreA} // Pass back current input values
                        initialScoreB={scoreB}
                    />,
                    () => confirmAction() // Pass confirmAction itself for re-attempt
                );
                return;
            }

            let winner = null;
            if (parsedScoreA > parsedScoreB) {
                winner = matchToEdit.teamA;
            } else if (parsedScoreB > parsedScoreA) {
                winner = matchToEdit.teamB;
            } else {
                winner = 'Draw'; // Or handle tie-breaker for knockouts
            }

            try {
                const matchRef = doc(db, `tournaments/${tournamentId}/knockoutMatches`, matchToEdit.id);
                await updateDoc(matchRef, {
                    scoreA: parsedScoreA,
                    scoreB: parsedScoreB,
                    status: 'completed',
                    winner: winner
                });
                closeModal();
                openModal('Success', 'Score updated successfully!', false);
            } catch (err) {
                console.error('Error updating scores:', err);
                openModal('Error', 'Failed to update scores. Please try again.', true,
                    <ScoreInputModalContent
                        ref={scoreInputRef}
                        fixture={matchToEdit}
                        initialScoreA={scoreA}
                        initialScoreB={scoreB}
                    />,
                    () => confirmAction() // Pass confirmAction itself for re-attempt
                );
            }
        };

        openModal(
            'Update Match Scores',
            `Enter scores for ${matchToEdit.teamA} vs ${matchToEdit.teamB}:`,
            true, // showConfirmButton
            <ScoreInputModalContent
                ref={scoreInputRef}
                fixture={matchToEdit}
                initialScoreA={matchToEdit.scoreA}
                initialScoreB={matchToEdit.scoreB}
            />,
            confirmAction // <--- Pass the confirm action here
        );
    }, [isViewOnly, user, tournamentOwnerId, openModal, closeModal, tournamentId]);


    // Handle deleting a knockout match
    const handleDeleteMatch = async (matchId) => {
        if (isViewOnly || user?.uid !== tournamentOwnerId) {
            openModal('Access Denied', 'You do not have permission to delete matches.', false);
            return;
        }

        const confirmDeleteAction = async () => {
            try {
                await deleteDoc(doc(db, `tournaments/${tournamentId}/knockoutMatches`, matchId));
                closeModal();
                openModal('Success', 'Match deleted successfully!', false);
            } catch (err) {
                console.error('Error deleting match:', err);
                openModal('Error', 'Failed to delete match. Please try again.', false);
            }
        };

        openModal('Confirm Delete', 'Are you sure you want to delete this match?', true, null, confirmDeleteAction); // <--- Pass confirmDeleteAction here
    };

    const commonNavLinks = (
        <div className="bg-red-600 text-white p-4 font-bold text-lg flex flex-wrap justify-around sm:flex-nowrap">
            <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">LEAGUE</Link>
            <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">FIXTURES</Link>
            <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">TOP SCORERS</Link>
            <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">STATS</Link>
            <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">KNOCKOUT</Link>
            <Link to={`/tournament/${tournamentId}/ai-prediction`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors text-sm sm:text-base">AI PREDICTION</Link>
        </div>
    );

    if (loading || authLoading) {
        return (
            <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
                {commonNavLinks}
                <div className="p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full">
                    <h2 className="text-xl sm:text-2xl font-bold mb-4 text-center">üèÜ Knockout Bracket ({tournamentName})</h2>
                    <p className="text-center text-gray-500 py-8">Loading knockout bracket...</p>
                </div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
                {commonNavLinks}
                <div className="p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full">
                    <h2 className="text-xl sm:text-2xl font-bold mb-4 text-center">üèÜ Knockout Bracket ({tournamentName})</h2>
                    <p className="text-center text-red-500 py-8">{error}</p>
                </div>
            </div>
        );
    }

    return (
        <div className="flex flex-col min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
            {commonNavLinks}

            <div className="flex-grow p-4 sm:p-6 lg:p-8 w-full overflow-x-auto">
                <h2 className="text-2xl sm:text-3xl font-bold mb-6 text-center text-gray-900 dark:text-white">
                    üèÜ Knockout Bracket ({tournamentName})
                </h2>

                {/* Add New Match Section */}
                {!isViewOnly && (
                    <div className="mb-6 text-center">
                        <button
                            onClick={() => setIsAddingMatch(!isAddingMatch)}
                            className="bg-blue-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 font-semibold text-base whitespace-nowrap"
                        >
                            {isAddingMatch ? 'Hide Add Match Form' : '‚ûï Add New Match'}
                        </button>
                    </div>
                )}

                {isAddingMatch && !isViewOnly && (
                    <div className="mb-8 p-6 bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 max-w-2xl mx-auto">
                        <h3 className="text-xl font-bold mb-4 text-center">Add New Knockout Match</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label htmlFor="roundName" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Round Name</label>
                                <input
                                    type="text"
                                    id="roundName"
                                    placeholder="e.g., Quarter-Finals"
                                    value={newMatch.round}
                                    onChange={e => setNewMatch({ ...newMatch, round: e.target.value })}
                                    className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                />
                            </div>
                            <div>
                                <label htmlFor="teamA" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Team A</label>
                                <input
                                    type="text"
                                    id="teamA"
                                    placeholder="Team A Name"
                                    value={newMatch.teamA}
                                    onChange={e => setNewMatch({ ...newMatch, teamA: e.target.value })}
                                    className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                />
                            </div>
                            <div>
                                <label htmlFor="teamB" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Team B</label>
                                <input
                                    type="text"
                                    id="teamB"
                                    placeholder="Team B Name"
                                    value={newMatch.teamB}
                                    onChange={e => setNewMatch({ ...newMatch, teamB: e.target.value })}
                                    className="w-full p-3 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                />
                            </div>
                            <div className="md:col-span-2 flex justify-center">
                                <button
                                    onClick={handleAddMatch}
                                    className="bg-green-600 text-white px-6 py-3 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200 font-semibold text-base w-full max-w-xs"
                                >
                                    Create Match
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {matches.length === 0 ? (
                    <p className="text-center text-gray-500 dark:text-gray-400 text-lg py-10">
                        No knockout matches configured for this tournament yet.
                        {!isViewOnly && " Use the 'Add New Match' button to create them."}
                    </p>
                ) : (
                    <div className="flex flex-col sm:flex-row justify-center items-start gap-4 md:gap-6 lg:gap-8 p-2">
                        {sortedRoundNames.map((roundName, roundIndex) => (
                            <div key={roundName} className="flex flex-col items-center flex-shrink-0 w-full sm:w-1/2 md:w-1/3 lg:w-auto min-w-[200px] md:min-w-[250px] max-w-sm">
                                <h3 className="text-lg sm:text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200 text-center">{roundName}</h3>
                                <div className="space-y-4 w-full">
                                    {groupedRounds[roundName].map((match) => (
                                        <div
                                            key={match.id}
                                            className={`bg-white dark:bg-gray-700 p-4 rounded-lg shadow flex flex-col items-center text-center border
                                                ${match.status === 'completed' ? 'border-green-500' : 'border-gray-300 dark:border-gray-600'}`}
                                        >
                                            <div className="w-full">
                                                <p className="font-medium text-gray-900 dark:text-white break-words text-base sm:text-lg">{match.teamA}</p>
                                                <p className="text-sm text-gray-600 dark:text-gray-300">vs</p>
                                                <p className="font-medium text-gray-900 dark:text-white break-words text-base sm:text-lg">{match.teamB}</p>
                                            </div>
                                            {match.status === 'completed' && match.scoreA !== null && match.scoreB !== null ? (
                                                <p className="mt-2 text-xl sm:text-2xl font-bold text-green-600 dark:text-green-400">
                                                    {match.scoreA} - {match.scoreB}
                                                </p>
                                            ) : (
                                                <p className="mt-2 text-base text-gray-500 dark:text-gray-400">Scheduled</p>
                                            )}
                                            {match.winner && match.winner !== 'Draw' && (
                                                <p className="mt-2 text-sm sm:text-base font-semibold text-blue-600 dark:text-blue-400">
                                                    Winner: {match.winner}
                                                </p>
                                            )}

                                            {!isViewOnly && (
                                                <div className="flex flex-col sm:flex-row gap-2 mt-3 w-full">
                                                    <button
                                                        onClick={() => handleUpdateScores(match)}
                                                        className="flex-1 bg-yellow-500 text-white px-3 py-2 rounded-md text-sm hover:bg-yellow-600 transition-colors font-semibold"
                                                    >
                                                        Update Scores
                                                    </button>
                                                    <button
                                                        onClick={() => handleDeleteMatch(match.id)}
                                                        className="flex-1 bg-red-500 text-white px-3 py-2 rounded-md text-sm hover:bg-red-600 transition-colors font-semibold"
                                                    >
                                                        Delete
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>

            <Modal
                isOpen={modalOpen}
                onClose={closeModal}
                onConfirm={modalConfirmAction} // This now correctly points to the state variable
                title={modalTitle}
                message={modalMessage}
                showConfirmButton={modalShowConfirmButton}
            >
                {modalContent}
            </Modal>
        </div>
    );
}

--- END FILE: src\pages\KnockoutPage.jsx ---

--- START FILE: src\pages\LeaderboardPage.jsx ---

import React, { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import { db } from '../firebase';
import { collection, onSnapshot, query, orderBy, doc, getDoc } from 'firebase/firestore';

export default function LeaderboardPage() {
  const { id: tournamentId } = useParams();
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [standings, setStandings] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!tournamentId) return;
    const fetchTournamentName = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);
        if (tournamentSnap.exists()) {
          setTournamentName(tournamentSnap.data().name);
        } else {
          setTournamentName('Tournament Not Found');
          setError('The requested tournament does not exist.');
        }
      } catch (err) {
        console.error('Error fetching tournament name:', err);
        setError('Failed to fetch tournament name.');
      }
    };
    fetchTournamentName();
  }, [tournamentId]);

  useEffect(() => {
    if (!tournamentId) {
      setError("No tournament ID provided.");
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const leaderboardCollectionRef = collection(db, `tournaments/${tournamentId}/leaderboard`);

      const q = query(
        leaderboardCollectionRef,
        orderBy('points', 'desc'),
        orderBy('goalDifference', 'desc'),
        orderBy('goalsFor', 'desc'),
        orderBy('name', 'asc')
      );

      const unsubscribe = onSnapshot(q, (snapshot) => {
        const data = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        setStandings(data);
        setLoading(false);
      }, (err) => {
        console.error('Error fetching real-time leaderboard:', err);
        setError('Failed to load leaderboard. Please try again.');
        setLoading(false);
      });

      return () => unsubscribe();
    } catch (err) {
      console.error("Error setting up leaderboard listener:", err);
      setError("Failed to set up leaderboard listener.");
      setLoading(false);
    }
  }, [tournamentId]);

  if (loading) {
    return (
      <div className="flex justify-center items-center h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-xl">Loading Leaderboard...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex justify-center items-center h-screen bg-gray-100 dark:bg-gray-900 text-red-500">
        <p className="text-xl">{error}</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white flex flex-col items-center p-4 sm:p-6 lg:p-8">
      {/* Tournament Navigation */}
      <div className="bg-red-600 text-white p-4 flex flex-wrap justify-center gap-2 font-bold text-lg w-full max-w-4xl rounded-md shadow-md mb-6">
        <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px]">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px]">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px]">PLAYERS</Link>
        <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px]">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px]">KNOCKOUT</Link>
      </div>

      <h2 className="text-xl sm:text-2xl lg:text-3xl font-bold mb-6 text-center">{tournamentName} Leaderboard</h2>

      {standings.length === 0 ? (
        <p className="text-base sm:text-xl text-gray-600 dark:text-gray-400 mt-8">No standings to display yet. Play some matches!</p>
      ) : (
        <div className="w-full max-w-4xl bg-white dark:bg-gray-800 shadow-lg rounded-lg overflow-hidden overflow-x-auto">
          <table className="min-w-full leading-normal">
            <thead>
              <tr className="bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-200 uppercase text-xs sm:text-sm md:text-base leading-normal">
                <th className="py-3 px-3 sm:px-6 text-left">Rank</th>
                <th className="py-3 px-3 sm:px-6 text-left">Team</th>
                <th className="py-3 px-3 sm:px-6 text-center">Played</th>
                <th className="py-3 px-3 sm:px-6 text-center">Win</th>
                <th className="py-3 px-3 sm:px-6 text-center">Draw</th>
                <th className="py-3 px-3 sm:px-6 text-center">Loss</th>
                <th className="py-3 px-3 sm:px-6 text-center">GF</th>
                <th className="py-3 px-3 sm:px-6 text-center">GA</th>
                <th className="py-3 px-3 sm:px-6 text-center">GD</th>
                <th className="py-3 px-3 sm:px-6 text-center">Points</th>
              </tr>
            </thead>
            <tbody className="text-gray-700 dark:text-gray-300 text-sm sm:text-base">
              {standings.map((team, index) => (
                <tr key={team.id} className="border-b border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700">
                  <td className="py-3 px-3 sm:px-6 text-left whitespace-nowrap">
                    <div className="flex items-center">
                      <span className="font-bold">{index + 1}</span>
                    </div>
                  </td>
                  <td className="py-3 px-3 sm:px-6 text-left">
                    <span className="font-medium">{team.name}</span>
                  </td>
                  <td className="py-3 px-3 sm:px-6 text-center">{team.matchesPlayed}</td>
                  <td className="py-3 px-3 sm:px-6 text-center">{team.wins}</td>
                  <td className="py-3 px-3 sm:px-6 text-center">{team.draws}</td>
                  <td className="py-3 px-3 sm:px-6 text-center">{team.losses}</td>
                  <td className="py-3 px-3 sm:px-6 text-center">{team.goalsFor}</td>
                  <td className="py-3 px-3 sm:px-6 text-center">{team.goalsAgainst}</td>
                  <td className="py-3 px-3 sm:px-6 text-center">{team.goalDifference}</td>
                  <td className="py-3 px-3 sm:px-6 text-center font-bold">{team.points}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
}

--- END FILE: src\pages\LeaderboardPage.jsx ---

--- START FILE: src\pages\PlayerPage.jsx ---

import React, { useEffect, useState, useMemo, useCallback } from 'react';
import { db } from '../firebase';
import { collection, addDoc, onSnapshot, doc, deleteDoc, updateDoc, query, orderBy, getDoc, getDocs, writeBatch, where } from 'firebase/firestore';
import { useParams, Link } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';

// Custom Modal Component defined directly within this file for its specific use cases.
const Modal = ({ isOpen, message, confirmAction, cancelAction, inputRequired, inputLabel, inputValue, setInputValue }) => {
  if (!isOpen) return null;
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm text-center text-gray-900 dark:text-white">
        {message && <p className="text-lg font-semibold mb-4">{message}</p>}
        {inputRequired && (
          <div className="flex flex-col gap-2 mb-4">
            <input
              type="number"
              placeholder={inputLabel.trim()}
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              style={{ pointerEvents: 'auto', zIndex: 'auto' }}
            />
          </div>
        )}
        <div className="flex justify-center gap-4 mt-4">
          {confirmAction && (
            <button
              onClick={confirmAction}
              className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors"
            >
              Confirm
            </button>
          )}
          <button
            onClick={cancelAction}
            className="bg-gray-400 text-white px-4 py-2 rounded-md hover:bg-gray-500 transition-colors"
          >
            {confirmAction ? 'Cancel' : 'Close'}
          </button>
        </div>
      </div>
    </div>
  );
};

export default function PlayerPage() {
  const { id: tournamentId } = useParams();
  const { user, loading: authLoading } = useAuth();
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [loadingTournamentData, setLoadingTournamentData] = useState(true);
  const [error, setError] = useState(null);
  const [players, setPlayers] = useState([]);
  // matchStats is no longer needed as goals, assists, and MOTM are directly on player document
  // const [matchStats, setMatchStats] = useState([]);
  const [teams, setTeams] = useState([]);
  const [newPlayerName, setNewPlayerName] = useState('');
  const [newPlayerTeam, setNewPlayerTeam] = useState('');
  const [customNewTeamName, setCustomNewTeamName] = useState('');
  const [addPlayerError, setAddPlayerError] = useState('');
  const [showAddPlayerForm, setShowAddPlayerForm] = useState(false);

  // Custom Modal Component states (for this inline modal)
  const [modalOpen, setModalOpen] = useState(false);
  const [modalMessage, setModalMessage] = useState('');
  const [modalConfirmAction, setModalConfirmAction] = useState(null);
  const [modalInputRequired, setModalInputRequired] = useState(false);
  const [modalInputLabel, setModalInputLabel] = useState('');
  const [modalInputValue, setModalInputValue] = useState('');

  // ADDED: Sorting state for the player table
  const [sortConfig, setSortConfig] = useState({ key: 'totalGoals', direction: 'descending' });

  const openModal = useCallback((message, confirmAction = null, inputRequired = false, inputLabel = '', initialValue = '') => {
    setModalMessage(message);
    setModalConfirmAction(() => confirmAction);
    setModalInputRequired(inputRequired);
    setModalInputLabel(inputLabel);
    setModalInputValue(initialValue);
    setModalOpen(true);
  }, []);

  const handleModalConfirm = useCallback(() => {
    if (modalConfirmAction) {
      if (modalInputRequired) {
        modalConfirmAction(modalInputValue);
      } else {
        modalConfirmAction();
      }
    }
    setModalOpen(false);
    setModalInputValue('');
    setModalConfirmAction(null);
  }, [modalConfirmAction, modalInputRequired, modalInputValue]);

  const handleModalCancel = useCallback(() => {
    setModalOpen(false);
    setModalInputValue('');
    setModalConfirmAction(null);
  }, []);

  useEffect(() => {
    if (authLoading) {
      setLoadingTournamentData(true);
      return;
    }
    if (!user) {
      setError("You must be logged in to view tournament details.");
      setLoadingTournamentData(false);
      return;
    }
    if (!tournamentId) {
      setError("No tournament ID provided in the URL.");
      setLoadingTournamentData(false);
      return;
    }

    setLoadingTournamentData(true);
    setError(null);

    const fetchTournamentName = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);
        if (tournamentSnap.exists()) {
          const data = tournamentSnap.data();
          if (data.userId === user.uid) {
            setTournamentName(data.name);
          } else {
            setTournamentName('Access Denied');
            setError('You do not have permission to access this tournament.');
          }
        } else {
          setTournamentName('Tournament Not Found');
          setError('The requested tournament does not exist.');
        }
        setLoadingTournamentData(false);
      } catch (err) {
        console.error('Error fetching tournament name:', err);
        setTournamentName('Error');
        setError('Failed to load tournament details.');
        setLoadingTournamentData(false);
      }
    };

    fetchTournamentName();
  }, [tournamentId, user, authLoading]);

  useEffect(() => {
    if (authLoading || !user || !tournamentId || error) return;

    const playersCollectionRef = collection(db, `tournaments/${tournamentId}/players`);
    // Listen for changes to players, including their 'goals', 'assists', and 'manOfTheMatchCount' fields
    const unsubscribePlayers = onSnapshot(playersCollectionRef, (snapshot) => {
      const fetchedPlayers = snapshot.docs.map(doc => ({
        id: doc.id,
        // Ensure goals, assists, and manOfTheMatchCount are initialized to 0 if not present
        goals: doc.data().goals || 0,
        assists: doc.data().assists || 0,
        manOfTheMatchCount: doc.data().manOfTheMatchCount || 0,
        ...doc.data()
      }));
      setPlayers(fetchedPlayers);

      const uniqueTeams = [...new Set(fetchedPlayers.map(player => player.team))].sort((a, b) => a.localeCompare(b));
      setTeams(uniqueTeams);

      if (showAddPlayerForm && newPlayerTeam === '' && uniqueTeams.length > 0) {
        setNewPlayerTeam(uniqueTeams[0]);
      } else if (showAddPlayerForm && newPlayerTeam === '' && uniqueTeams.length === 0) {
        setNewPlayerTeam('_new_team_');
      }
    }, (err) => {
      console.error('Error fetching real-time players:', err);
      setError('Failed to load players. Please try again.');
    });

    // Removed fetchMatchStats as goals, assists, and manOfTheMatchCount are now directly on player document
    // and updated via direct editing on this page. If fixture-derived stats are needed elsewhere,
    // they should be fetched/calculated in a component that specifically deals with fixtures.

    return () => {
      unsubscribePlayers();
    };
  }, [tournamentId, user, authLoading, error, showAddPlayerForm, newPlayerTeam]); // Depend on showAddPlayerForm and newPlayerTeam to re-evaluate default team selection

  // Combine players with their total goals, assists, and man of the match counts
  const playersWithStats = useMemo(() => {
    return players.map(player => ({
      ...player,
      // totalGoals now directly comes from player.goals
      totalGoals: player.goals,
      // totalAssists now directly comes from player.assists
      totalAssists: player.assists,
      // manOfTheMatchCount now directly comes from player.manOfTheMatchCount
      manOfTheMatchCount: player.manOfTheMatchCount
    }));
  }, [players]); // Depend only on players as stats are now directly on player objects

  // Sort players based on sortConfig
  const sortedPlayers = useMemo(() => {
    let sortablePlayers = [...playersWithStats];
    if (sortConfig.key) {
      sortablePlayers.sort((a, b) => {
        const aValue = a[sortConfig.key];
        const bValue = b[sortConfig.key];

        if (typeof aValue === 'string' && typeof bValue === 'string') {
          return sortConfig.direction === 'ascending' ?
            aValue.localeCompare(bValue) :
            bValue.localeCompare(aValue);
        } else {
          // Handle undefined values by treating them as 0 for numerical sorting
          const numA = aValue === undefined ? 0 : aValue;
          const numB = bValue === undefined ? 0 : bValue;
          return sortConfig.direction === 'ascending' ?
            numA - numB :
            numB - numA;
        }
      });
    }
    return sortablePlayers;
  }, [playersWithStats, sortConfig]);

  const requestSort = useCallback((key) => {
    let direction = 'ascending';
    if (sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  }, [sortConfig]);

  const getSortIndicator = (key) => {
    if (sortConfig.key === key) {
      return sortConfig.direction === 'ascending' ? ' üîº' : ' üîΩ';
    }
    return '';
  };

  const handleAddPlayer = async (e) => {
    e.preventDefault();
    setAddPlayerError('');

    if (!newPlayerName.trim()) {
      setAddPlayerError('Player name cannot be empty.');
      return;
    }

    let teamToAdd = newPlayerTeam;
    if (newPlayerTeam === '_new_team_') {
      if (!customNewTeamName.trim()) {
        setAddPlayerError('New team name cannot be empty.');
        return;
      }
      teamToAdd = customNewTeamName.trim();
    }

    try {
      // Check if a player with the same name and team already exists
      const q = query(
        collection(db, `tournaments/${tournamentId}/players`),
        where('name', '==', newPlayerName.trim()),
        where('team', '==', teamToAdd)
      );
      const querySnapshot = await getDocs(q);
      if (!querySnapshot.empty) {
        setAddPlayerError(`Player '${newPlayerName.trim()}' already exists in team '${teamToAdd}'.`);
        return;
      }

      await addDoc(collection(db, `tournaments/${tournamentId}/players`), {
        name: newPlayerName.trim(),
        team: teamToAdd,
        goals: 0, // Initialize goals for the player
        assists: 0, // Initialize assists for the player
        manOfTheMatchCount: 0 // Initialize man of the match count
      });
      setNewPlayerName('');
      setCustomNewTeamName('');
      setNewPlayerTeam(teams.length > 0 ? teams[0] : '_new_team_');
      setShowAddPlayerForm(false); // Hide form after successful addition
    } catch (err) {
      console.error('Error adding player:', err);
      setAddPlayerError('Failed to add player. Please try again.');
    }
  };

  const handleEditGoals = useCallback((player) => {
    openModal(
      `Set goals for ${player.name}:`,
      (value) => updatePlayerStat(player.id, 'goals', parseInt(value) || 0),
      true,
      'Goals',
      String(player.totalGoals)
    );
  }, [openModal]);

  const handleEditAssists = useCallback((player) => {
    openModal(
      `Set assists for ${player.name}:`,
      (value) => updatePlayerStat(player.id, 'assists', parseInt(value) || 0),
      true,
      'Assists',
      String(player.totalAssists)
    );
  }, [openModal]);

  const handleEditMOTM = useCallback((player) => {
    openModal(
      `Set Man of the Match count for ${player.name}:`,
      (value) => updatePlayerStat(player.id, 'manOfTheMatchCount', parseInt(value) || 0),
      true,
      'MOTM Count',
      String(player.manOfTheMatchCount)
    );
  }, [openModal]);

  // Generic function to update any player stat (goals, assists, manOfTheMatchCount)
  const updatePlayerStat = async (playerId, field, value) => {
    try {
      const playerRef = doc(db, `tournaments/${tournamentId}/players`, playerId);
      await updateDoc(playerRef, { [field]: value });
    } catch (err) {
      console.error(`Error updating player ${field}:`, err);
      openModal(`Failed to update ${field}. Please try again.`);
    }
  };

  const handleDeletePlayer = useCallback((playerId, playerName) => {
    openModal(
      `Are you sure you want to delete ${playerName}? This action cannot be undone.`,
      async () => {
        try {
          const playerRef = doc(db, `tournaments/${tournamentId}/players`, playerId);
          await deleteDoc(playerRef);

          // No longer need to update fixtures for goals/assists as they are on player doc.
          // Still need to clear manOfTheMatchPlayerId from fixtures if the deleted player was MOTM.
          const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
          const q = query(fixturesCollectionRef,
            where('manOfTheMatchPlayerId', '==', playerId)
          );
          const fixturesSnap = await getDocs(q);
          const batch = writeBatch(db);

          fixturesSnap.forEach(fixtureDoc => {
            batch.update(fixtureDoc.ref, {
              manOfTheMatchPlayerId: null // Clear MOTM if the deleted player was it
            });
          });
          await batch.commit();

          openModal('Player deleted successfully!');
        } catch (err) {
          console.error('Error deleting player:', err);
          openModal('Failed to delete player. Please try again.');
        }
      }
    );
  }, [tournamentId, openModal]);

  if (loadingTournamentData || authLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-lg font-semibold animate-pulse">Loading player data...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gray-100 dark:bg-gray-900 text-red-500 p-4">
        <p className="text-xl font-bold mb-4">Error:</p>
        <p className="text-lg text-center">{error}</p>
        <Link to="/" className="mt-6 bg-red-600 text-white px-6 py-3 rounded-md hover:bg-red-700 transition-colors font-semibold">
          Go to Dashboard
        </Link>
      </div>
    );
  }

  return (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex flex-wrap justify-around font-bold text-base md:text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">PLAYERS</Link>
        <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-fit">AI PREDICTION</Link>
      </div>

      <div className="p-4 sm:p-6 max-w-6xl mx-auto w-full">
        <h2 className="text-2xl sm:text-3xl font-bold mb-4 text-center">
          ‚öΩ Players in {tournamentName}
        </h2>

        {/* Add New Player Section */}
        <div className="mb-6 p-4 sm:p-6 bg-gray-50 dark:bg-gray-800 rounded-lg shadow-md border border-gray-200 dark:border-gray-700">
          <button
            onClick={() => setShowAddPlayerForm(!showAddPlayerForm)}
            className="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-md hover:bg-green-700 transition-colors duration-200 mb-4"
          >
            {showAddPlayerForm ? 'Hide Add Player Form' : 'Add New Player'}
          </button>

          {showAddPlayerForm && (
            <form onSubmit={handleAddPlayer} className="flex flex-col gap-4">
              <input
                type="text"
                placeholder="Player Name"
                value={newPlayerName}
                onChange={(e) => setNewPlayerName(e.target.value)}
                className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />

              <select
                value={newPlayerTeam}
                onChange={(e) => setNewPlayerTeam(e.target.value)}
                className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">Select Team</option>
                {teams.map((team, index) => (
                  <option key={index} value={team}>{team}</option>
                ))}
                <option value="_new_team_">Add New Team</option>
              </select>

              {newPlayerTeam === '_new_team_' && (
                <input
                  type="text"
                  placeholder="New Team Name"
                  value={customNewTeamName}
                  onChange={(e) => setCustomNewTeamName(e.target.value)}
                  className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              )}

              {addPlayerError && (
                <p className="text-red-500 text-sm mt-1">{addPlayerError}</p>
              )}

              <button
                type="submit"
                className="bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors duration-200"
              >
                Add Player
              </button>
            </form>
          )}
        </div>

        {/* Players List Table */}
        {players.length === 0 ? (
          <p className="text-gray-500 text-center py-4">No players added yet. Add some players!</p>
        ) : (
          <div className="overflow-x-auto rounded-lg shadow-lg border border-gray-300 dark:border-gray-600">
            <table className="min-w-full table-auto text-sm md:text-base">
              <thead>
                <tr className="bg-gray-100 dark:bg-gray-800 text-left">
                  <th className="px-3 py-2 border-b dark:border-gray-700 cursor-pointer" onClick={() => requestSort('name')}>
                    Player Name {getSortIndicator('name')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 cursor-pointer" onClick={() => requestSort('team')}>
                    Team {getSortIndicator('team')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 text-center cursor-pointer" onClick={() => requestSort('totalGoals')}>
                    Goals {getSortIndicator('totalGoals')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 text-center cursor-pointer" onClick={() => requestSort('totalAssists')}>
                    Assists {getSortIndicator('totalAssists')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 text-center cursor-pointer" onClick={() => requestSort('manOfTheMatchCount')}>
                    MOTM {getSortIndicator('manOfTheMatchCount')}
                  </th>
                  <th className="px-3 py-2 border-b dark:border-gray-700 text-center">Actions</th>
                </tr>
              </thead>
              <tbody>
                {sortedPlayers.map(player => (
                  <tr key={player.id} className="border-b dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700">
                    <td className="px-3 py-2">{player.name}</td>
                    <td className="px-3 py-2">{player.team}</td>
                    <td className="px-3 py-2 text-center">{player.totalGoals}</td>
                    <td className="px-3 py-2 text-center">{player.totalAssists}</td>
                    <td className="px-3 py-2 text-center">{player.manOfTheMatchCount}</td>
                    <td className="px-3 py-2 flex flex-wrap justify-center gap-2">
                      <button
                        onClick={() => handleEditGoals(player)}
                        className="bg-yellow-500 text-white px-3 py-1 rounded-md hover:bg-yellow-600 transition-colors text-xs sm:text-sm"
                        title="Edit Goals"
                      >
                        Edit Goals
                      </button>
                      <button
                        onClick={() => handleEditAssists(player)}
                        className="bg-blue-500 text-white px-3 py-1 rounded-md hover:bg-blue-600 transition-colors text-xs sm:text-sm"
                        title="Edit Assists"
                      >
                        Edit Assists
                      </button>
                      <button
                        onClick={() => handleEditMOTM(player)}
                        className="bg-purple-500 text-white px-3 py-1 rounded-md hover:bg-purple-600 transition-colors text-xs sm:text-sm"
                        title="Edit Man of the Match Count"
                      >
                        Edit MOTM
                      </button>
                      <button
                        onClick={() => handleDeletePlayer(player.id, player.name)}
                        className="bg-red-500 text-white px-3 py-1 rounded-md hover:bg-red-600 transition-colors text-xs sm:text-sm"
                        title="Delete Player"
                      >
                        Delete
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>

      {/* Custom Modal */}
      <Modal
        isOpen={modalOpen}
        message={modalMessage}
        confirmAction={modalConfirmAction ? handleModalConfirm : null}
        cancelAction={handleModalCancel}
        inputRequired={modalInputRequired}
        inputLabel={modalInputLabel}
        inputValue={modalInputValue}
        setInputValue={setModalInputValue}
      />
    </div>
  );
}

--- END FILE: src\pages\PlayerPage.jsx ---

--- START FILE: src\pages\StatsPage.jsx ---

// src/pages/StatsPage.jsx

import React, { useEffect, useState, useMemo, useCallback } from 'react';
import { useParams, Link, useLocation } from 'react-router-dom';
import { db } from '../firebase';
import { collection, query, onSnapshot, doc, getDoc } from 'firebase/firestore';
import { useAuth } from '../hooks/useAuth';
import { Bar, Pie, Doughnut } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend,
  ArcElement,
} from 'chart.js';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend, ArcElement);

export default function StatsPage() {
  const { id: tournamentId } = useParams();
  const { user, loading: authLoading } = useAuth();
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [loadingTournamentData, setLoadingTournamentData] = useState(true);
  const [error, setError] = useState(null);
  const [fixtures, setFixtures] = useState([]);
  const [players, setPlayers] = useState([]);
  const [teams, setTeams] = useState([]); // State to hold unique team names

  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  const shareId = queryParams.get('shareId');

  // Determine if the page is in read-only mode
  const isViewOnly = useMemo(() => {
    if (shareId) return true;
    return false; // Not read-only if no shareId
  }, [shareId]);

  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);

  useEffect(() => {
    if (authLoading) {
      setLoadingTournamentData(true);
      return;
    }

    if (!user && !shareId) {
      setError("You must be logged in to view tournament details.");
      setLoadingTournamentData(false);
      return;
    }

    if (!tournamentId) {
      setError("No tournament ID provided in the URL.");
      setLoadingTournamentData(false);
      return;
    }

    setLoadingTournamentData(true);
    setError(null);

    const fetchTournamentData = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);

        if (tournamentSnap.exists()) {
          const data = tournamentSnap.data();
          setTournamentName(data.name);
          setTournamentOwnerId(data.userId);

          // If shareId is present, allow access
          if (shareId && data.shareId === shareId) {
            // Public view, no further permission check needed
          } else if (user && data.userId === user.uid) {
            // Owner access
          } else {
            // Neither shareId matches, nor is the user the owner
            setTournamentName('Access Denied');
            setError('You do not have permission to access this tournament.');
          }
        } else {
          setTournamentName('Tournament Not Found');
          setError('The requested tournament does not exist.');
        }
        setLoadingTournamentData(false);
      } catch (err) {
        console.error('Error fetching tournament data:', err);
        setTournamentName('Error');
        setError('Failed to load tournament details.');
        setLoadingTournamentData(false);
      }
    };
    fetchTournamentData();
  }, [tournamentId, user, authLoading, shareId]);


  useEffect(() => {
    if (loadingTournamentData || error || (!user && !shareId)) return;

    const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
    const unsubscribeFixtures = onSnapshot(fixturesCollectionRef, (snapshot) => {
      const fetchedFixtures = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setFixtures(fetchedFixtures);
    }, (err) => {
      console.error('Error fetching real-time fixtures:', err);
      setError('Failed to load fixtures. Please try again.');
    });

    const playersCollectionRef = collection(db, `tournaments/${tournamentId}/players`);
    const unsubscribePlayers = onSnapshot(playersCollectionRef, (snapshot) => {
      const fetchedPlayers = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setPlayers(fetchedPlayers);
      const uniqueTeams = [...new Set(fetchedPlayers.map(player => player.team))];
      setTeams(uniqueTeams);
    }, (err) => {
      console.error('Error fetching real-time players:', err);
      setError('Failed to load players. Please try again.');
    });

    return () => {
      unsubscribeFixtures();
      unsubscribePlayers();
    };
  }, [tournamentId, loadingTournamentData, error, user, shareId]);


  // Derived state for stats
  const {
    totalMatches,
    completedMatches,
    pendingMatches,
    goalsPerMatch,
    winsByTeam,
    teamGoals,
    matchOutcomes,
    playerGoals,
    manOfTheMatchCounts
  } = useMemo(() => {
    let total = 0;
    let completed = 0;
    let teamWins = {};
    let teamGoalsFor = {};
    let outcomes = { 'Win': 0, 'Draw': 0, 'Loss': 0 }; // Relative to team A in a fixture
    let pGoals = {};
    let motmCounts = {};

    fixtures.forEach(fixture => {
      total++;
      if (fixture.status === 'completed') {
        completed++;

        const scoreA = fixture.scoreA || 0;
        const scoreB = fixture.scoreB || 0;

        // Wins by Team
        if (scoreA > scoreB) {
          teamWins[fixture.teamA] = (teamWins[fixture.teamA] || 0) + 1;
          outcomes['Win']++;
        } else if (scoreB > scoreA) {
          teamWins[fixture.teamB] = (teamWins[fixture.teamB] || 0) + 1;
          outcomes['Loss']++;
        } else {
          outcomes['Draw']++;
        }

        // Team Goals
        teamGoalsFor[fixture.teamA] = (teamGoalsFor[fixture.teamA] || 0) + scoreA;
        teamGoalsFor[fixture.teamB] = (teamGoalsFor[fixture.teamB] || 0) + scoreB;

        // Player Goals (assuming goals structure is {playerId: count})
        if (fixture.goals) {
          for (const playerId in fixture.goals) {
            pGoals[players.find(p => p.id === playerId)?.name || playerId] = (pGoals[players.find(p => p.id === playerId)?.name || playerId] || 0) + fixture.goals[playerId];
          }
        }

        // Man of the Match
        if (fixture.manOfTheMatch) {
          motmCounts[players.find(p => p.id === fixture.manOfTheMatch)?.name || fixture.manOfTheMatch] = (motmCounts[players.find(p => p.id === fixture.manOfTheMatch)?.name || fixture.manOfTheMatch] || 0) + 1;
        }
      }
    });

    const pending = total - completed;
    const totalGoals = Object.values(teamGoalsFor).reduce((sum, current) => sum + current, 0);
    const avgGoalsPerMatch = completed > 0 ? (totalGoals / (completed * 2)) : 0; // Each fixture has 2 teams scoring

    return {
      totalMatches: total,
      completedMatches: completed,
      pendingMatches: pending,
      goalsPerMatch: avgGoalsPerMatch.toFixed(2),
      winsByTeam: teamWins,
      teamGoals: teamGoalsFor,
      matchOutcomes: outcomes,
      playerGoals: pGoals,
      manOfTheMatchCounts: motmCounts
    };
  }, [fixtures, players]); // Re-calculate if fixtures or players change

  // Chart data configurations
  const goalsPerTeamChartData = {
    labels: Object.keys(teamGoals),
    datasets: [{
      label: 'Goals Scored',
      data: Object.values(teamGoals),
      backgroundColor: 'rgba(75, 192, 192, 0.6)',
      borderColor: 'rgba(75, 192, 192, 1)',
      borderWidth: 1,
    }]
  };

  const matchOutcomesChartData = {
    labels: Object.keys(matchOutcomes),
    datasets: [{
      label: 'Match Outcomes',
      data: Object.values(matchOutcomes),
      backgroundColor: [
        'rgba(54, 162, 235, 0.6)', // Win
        'rgba(255, 206, 86, 0.6)', // Draw
        'rgba(255, 99, 132, 0.6)', // Loss
      ],
      borderColor: [
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(255, 99, 132, 1)',
      ],
      borderWidth: 1,
    }]
  };

  const topScorersChartData = {
    labels: Object.keys(playerGoals).sort((a, b) => playerGoals[b] - playerGoals[a]).slice(0, 5), // Top 5
    datasets: [{
      label: 'Goals',
      data: Object.values(playerGoals).sort((a, b) => b - a).slice(0, 5),
      backgroundColor: 'rgba(153, 102, 255, 0.6)',
      borderColor: 'rgba(153, 102, 255, 1)',
      borderWidth: 1,
    }]
  };

  const manOfTheMatchChartData = {
    labels: Object.keys(manOfTheMatchCounts).sort((a, b) => manOfTheMatchCounts[b] - manOfTheMatchCounts[a]).slice(0, 5), // Top 5
    datasets: [{
      label: 'Man of the Match Awards',
      data: Object.values(manOfTheMatchCounts).sort((a, b) => b - a).slice(0, 5),
      backgroundColor: 'rgba(255, 159, 64, 0.6)',
      borderColor: 'rgba(255, 159, 64, 1)',
      borderWidth: 1,
    }]
  };

  // Common Loading/Error/No Access UI
  const renderLoadingOrError = () => (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar - Always render for consistent layout */}
      <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">AI PREDICTION</Link>
      </div>
      <div className="flex-grow flex items-center justify-center p-4">
        {loadingTournamentData ? (
          <p className="text-lg font-semibold animate-pulse">Loading tournament data...</p>
        ) : error ? (
          <p className="text-red-500 text-lg font-semibold">{error}</p>
        ) : (
          <p className="text-gray-500 text-lg font-semibold">No data available or access denied.</p>
        )}
      </div>
    </div>
  );

  if (loadingTournamentData || error || (!user && !shareId)) {
    return renderLoadingOrError();
  }

  // Check if there are any completed fixtures to display stats for
  const hasCompletedFixtures = fixtures.some(f => f.status === 'completed');

  return (
    <div className="flex flex-col min-h-screen bg-gray-100 text-gray-900 dark:bg-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex flex-wrap justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">PLAYERS</Link> {/* Changed from TOP SCORERS to PLAYERS */}
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors whitespace-nowrap min-w-max">AI PREDICTION</Link>
      </div>

      <div className="flex-grow p-4 md:p-6 lg:p-8 max-w-7xl mx-auto w-full">
        <h2 className="text-2xl md:text-3xl font-bold mb-6 text-center">üìä Tournament Stats ({tournamentName})</h2>

        {!hasCompletedFixtures ? (
          <p className="text-gray-500 text-center text-lg mt-8">No matches have been completed yet for this tournament. Complete some fixtures to see statistics!</p>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {/* General Stats Card */}
            <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md flex flex-col items-center justify-center">
              <h3 className="text-xl font-semibold mb-3">Overview</h3>
              <p className="text-lg">Total Matches: <span className="font-bold">{totalMatches}</span></p>
              <p className="text-lg">Completed Matches: <span className="font-bold text-green-600 dark:text-green-400">{completedMatches}</span></p>
              <p className="text-lg">Pending Matches: <span className="font-bold text-yellow-600 dark:text-yellow-400">{pendingMatches}</span></p>
              <p className="text-lg">Avg. Goals per Match: <span className="font-bold">{goalsPerMatch}</span></p>
            </div>

            {/* Goals Per Team Chart */}
            {Object.keys(teamGoals).length > 0 && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                <h3 className="text-xl font-semibold mb-4 text-center">Goals Scored Per Team</h3>
                <Bar data={goalsPerTeamChartData} options={{ responsive: true, maintainAspectRatio: true }} />
              </div>
            )}

            {/* Match Outcomes Chart */}
            {Object.values(matchOutcomes).some(count => count > 0) && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md flex flex-col items-center justify-center">
                <h3 className="text-xl font-semibold mb-4 text-center">Match Outcomes</h3>
                <div className="relative w-full max-w-xs aspect-square">
                  <Pie data={matchOutcomesChartData} options={{ responsive: true, maintainAspectRatio: false }} />
                </div>
              </div>
            )}

            {/* Top 5 Scorers Chart */}
            {Object.keys(playerGoals).length > 0 && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                <h3 className="text-xl font-semibold mb-4 text-center">Top 5 Scorers</h3>
                <Bar data={topScorersChartData} options={{ indexAxis: 'y', responsive: true, maintainAspectRatio: true }} />
              </div>
            )}

            {/* Top 5 Man of the Match Awards Chart */}
            {Object.keys(manOfTheMatchCounts).length > 0 && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
                <h3 className="text-xl font-semibold mb-4 text-center">Top Man of the Match Awards</h3>
                <Doughnut data={manOfTheMatchChartData} options={{ responsive: true, maintainAspectRatio: true }} />
              </div>
            )}

            {/* Wins By Team List (if more than charts needed) */}
            {Object.keys(winsByTeam).length > 0 && (
              <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md col-span-1 md:col-span-2 lg:col-span-1">
                <h3 className="text-xl font-semibold mb-4 text-center">Wins by Team</h3>
                <ul className="space-y-2">
                  {Object.entries(winsByTeam)
                    .sort(([, winsA], [, winsB]) => winsB - winsA)
                    .map(([teamName, wins]) => (
                      <li key={teamName} className="flex justify-between items-center bg-gray-50 dark:bg-gray-700 p-3 rounded-md">
                        <span className="font-medium">{teamName}</span>
                        <span className="font-bold text-blue-600 dark:text-blue-400">{wins} Wins</span>
                      </li>
                    ))}
                </ul>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

--- END FILE: src\pages\StatsPage.jsx ---

--- START FILE: src\pages\TournamentPage.jsx ---

import React, { useEffect, useState, useCallback, useRef } from 'react';
import { db } from '../firebase';
import {
  collection,
  addDoc,
  onSnapshot,
  doc,
  deleteDoc,
  updateDoc,
  query,
  orderBy,
  getDoc,
  writeBatch,
  getDocs,
  setDoc // Added setDoc for potential future use or consistency
} from 'firebase/firestore';
import { Link, useNavigate, useParams, useSearchParams } from 'react-router-dom'; // Added useSearchParams
import { useAuth } from '../hooks/useAuth';
import Modal from '../components/Modal';
import ScoreInputModalContent from '../components/ScoreInputModalContent';

export default function TournamentPage() {
  const { id: tournamentId } = useParams();
  const [searchParams] = useSearchParams(); // Hook to read URL query parameters
  const shareId = searchParams.get('shareId'); // Get the shareId from the URL
  const { user, loading: authLoading } = useAuth();
  const navigate = useNavigate();

  // State to determine if the page is in view-only mode
  // This will be true if shareId is present, or if user is null AND the tournament is public.
  const [isViewOnly, setIsViewOnly] = useState(false);
  // State to hold the actual owner ID for permission checks
  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);

  // Tournament Details State
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [tournamentDetails, setTournamentDetails] = useState(null);
  const [loadingTournamentData, setLoadingTournamentData] = useState(true);
  const [generalError, setGeneralError] = useState(null);

  // Team Management State
  const [teams, setTeams] = useState([]);
  const [newTeamName, setNewTeamName] = useState('');
  const [teamError, setTeamError] = useState('');

  // Fixture Management State
  const [fixtures, setFixtures] = useState([]);
  const [newFixture, setNewFixture] = useState({ teamA: '', teamB: '', date: '', timestamp: null, status: 'scheduled', scoreA: 0, scoreB: 0 });
  const [fixtureError, setFixtureError] = useState('');

  // Modal State (for the shared Modal component)
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalTitle, setModalTitle] = useState('');
  const [modalMessage, setModalMessage] = useState('');
  const [modalContent, setModalContent] = useState(null);
  const [modalConfirmAction, setModalConfirmAction] = useState(null);
  const [modalShowConfirmButton, setModalShowConfirmButton] = useState(true);

  // REF to access the ScoreInputModalContent component's methods (like getScoreA/B)
  const scoreInputRef = useRef(null);
  // State to hold the specific fixture being updated when the modal is open
  const [currentFixtureToUpdate, setCurrentFixtureToUpdate] = useState(null);

  // Tournament Configuration State
  const [enableColors, setEnableColors] = useState(false);
  const [promotionSpots, setPromotionSpots] = useState('');
  const [europeLeagueSpots, setEuropeLeagueSpots] = useState('');
  const [relegationSpots, setRelegationSpots] = useState('');
  const [fixtureOption, setFixtureOption] = useState('Single Matches');
  const [pointsPerWin, setPointsPerWin] = useState(3);
  const [pointsPerDraw, setPointsPerDraw] = useState(1);
  const [shareableLink, setShareableLink] = useState(''); // New state for the share link

  // Helper function to open the custom modal (uses the shared Modal component)
  const openCustomModal = useCallback((title, message, confirmAction = null, showConfirm = true, content = null) => {
    setModalTitle(title);
    setModalMessage(message);
    setModalConfirmAction(() => confirmAction);
    setModalShowConfirmButton(showConfirm);
    setModalContent(content);
    setIsModalOpen(true);
  }, []);
  const closeCustomModal = useCallback(() => {
    setIsModalOpen(false);
    setModalTitle('');
    setModalMessage('');
    setModalContent(null);
    setModalConfirmAction(null);
    setModalShowConfirmButton(true);
  }, []);

  // --- Effect to fetch Tournament Details ---
  useEffect(() => {
    // If auth is still loading, wait.
    if (authLoading) {
      setLoadingTournamentData(true);
      return;
    }

    if (!tournamentId) {
      setGeneralError("No tournament ID provided in the URL.");
      setLoadingTournamentData(false);
      return;
    }

    setLoadingTournamentData(true);
    setGeneralError(null);

    const fetchTournamentDetails = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);

        if (tournamentSnap.exists()) {
          const data = tournamentSnap.data();
          const ownerId = data.userId;
          const isPublicTournament = data.isPublic || false; // Check for isPublic flag

          setTournamentOwnerId(ownerId); // Store owner ID for later checks

          // Determine if it's view-only mode
          // It's view-only if a shareId is present, OR if the user is NOT logged in AND the tournament is public.
          const currentIsViewOnly = (!!shareId) || (!user && isPublicTournament);
          setIsViewOnly(currentIsViewOnly);


          // Permission Check:
          // If a user is logged in, they must be the owner to get full access.
          // If NO user is logged in, but a shareId is present AND the tournament is public, allow read-only.
          if (user && user.uid && ownerId === user.uid) {
            // Full access for the owner
            setTournamentName(data.name);
            setTournamentDetails(data);
            setEnableColors(data.enableColors || false);
            setPromotionSpots(data.promotionSpots !== undefined ? String(data.promotionSpots) : '');
            setEuropeLeagueSpots(data.europeLeagueSpots !== undefined ? String(data.europeLeagueSpots) : '');
            setRelegationSpots(data.relegationSpots !== undefined ? String(data.relegationSpots) : '');
            setFixtureOption(data.fixtureOption || 'Single Matches');
            setPointsPerWin(data.pointsPerWin !== undefined ? data.pointsPerWin : 3);
            setPointsPerDraw(data.pointsPerDraw !== undefined ? data.pointsPerDraw : 1);
            setShareableLink(`${window.location.origin}/tournament/${tournamentId}?shareId=${tournamentId}`); // Re-generate for owner to copy
          } else if (currentIsViewOnly) {
            // Read-only access for public viewers (via share link or unauthenticated to public tourney)
            setTournamentName(data.name);
            setTournamentDetails(data);
            setEnableColors(data.enableColors || false);
            setPromotionSpots(data.promotionSpots !== undefined ? String(data.promotionSpots) : '');
            setEuropeLeagueSpots(data.europeLeagueSpots !== undefined ? String(data.europeLeagueSpots) : '');
            setRelegationSpots(data.relegationSpots !== undefined ? String(data.relegationSpots) : '');
            setFixtureOption(data.fixtureOption || 'Single Matches');
            setPointsPerWin(data.pointsPerWin !== undefined ? data.pointsPerWin : 3);
            setPointsPerDraw(data.pointsPerDraw !== undefined ? data.pointsPerDraw : 1);
            setShareableLink(''); // No share link to show for viewers
            // No error, as this is expected behavior for view-only.
          } else {
            // User is logged in but not the owner, OR user is not logged in and tournament is not public.
            setTournamentName('Access Denied');
            setGeneralError('You do not have permission to access this tournament. Please log in with the correct account or use a valid share link.');
          }
        } else {
          setTournamentName('Tournament Not Found');
          setGeneralError('The requested tournament does not exist.');
        }
        setLoadingTournamentData(false);
      } catch (err) {
        console.error('Error fetching tournament details:', err);
        setTournamentName('Error');
        setGeneralError('Failed to load tournament details. Please try again.');
        setLoadingTournamentData(false);
      }
    };
    fetchTournamentDetails();
  }, [tournamentId, user, authLoading, shareId]); // Added shareId to dependencies

  // --- Effect to listen to Teams and Fixtures ---
  // These effects now listen regardless of `user` status, but the security rules will filter access.
  useEffect(() => {
    if (loadingTournamentData || generalError) {
      setTeams([]); // Clear teams if still loading or error
      return;
    }

    // Teams subscription
    const teamsCollectionRef = collection(db, `tournaments/${tournamentId}/teams`);
    const unsubscribeTeams = onSnapshot(query(teamsCollectionRef, orderBy('name', 'asc')), (snapshot) => {
      setTeams(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
    }, (err) => {
      console.error('Error fetching real-time teams:', err);
      // For view-only, just log the error, don't necessarily show it to the user.
      // For owner, you might want to show it.
      if (!isViewOnly) {
        setTeamError('Failed to load teams.');
      }
    });

    // Fixtures subscription
    const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
    const unsubscribeFixtures = onSnapshot(query(fixturesCollectionRef, orderBy('timestamp', 'asc')), (snapshot) => {
      setFixtures(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
    }, (err) => {
      console.error('Error fetching real-time fixtures:', err);
      if (!isViewOnly) {
        setFixtureError('Failed to load fixtures.');
      }
    });
    return () => {
      unsubscribeTeams();
      unsubscribeFixtures();
    };
  }, [tournamentId, loadingTournamentData, generalError, isViewOnly]); // Added isViewOnly to dependencies

  // --- Leaderboard Update Logic ---
  // This should ideally only be called by the owner or a backend function.
  // However, for simplicity, we'll keep it client-side but guard against view-only calls.
  const updateLeaderboard = useCallback(async () => {
    if (isViewOnly || !tournamentId || !tournamentDetails) {
      console.log('Skipping leaderboard update: View-only mode or tournament data missing.');
      return;
    }
    // Ensure the current user is the owner before attempting to write to the leaderboard
    if (user?.uid !== tournamentOwnerId) {
      console.warn('Attempted leaderboard update by non-owner in non-view-only mode. Aborting.');
      return;
    }

    const leaderboardRef = collection(db, `tournaments/${tournamentId}/leaderboard`);
    const teamsRef = collection(db, `tournaments/${tournamentId}/teams`);
    const fixturesRef = collection(db, `tournaments/${tournamentId}/fixtures`);

    try {
      const teamsSnapshot = await getDocs(teamsRef);
      const fixturesSnapshot = await getDocs(query(fixturesRef));

      const teamStats = {};
      teamsSnapshot.docs.forEach(teamDoc => {
        const teamName = teamDoc.data().name;
        teamStats[teamName] = {
          id: teamDoc.id,
          name: teamName,
          played: 0,
          wins: 0,
          draws: 0,
          losses: 0,
          goalsFor: 0,
          goalsAgainst: 0,
          goalDifference: 0,
          points: 0,
        };
      });

      fixturesSnapshot.docs.forEach(fixtureDoc => {
        const fixture = fixtureDoc.data();
        if (fixture.status === 'completed') {
          const teamA = fixture.teamA;
          const teamB = fixture.teamB;
          const scoreA = Number(fixture.scoreA) || 0;
          const scoreB = Number(fixture.scoreB) || 0;

          if (teamStats[teamA]) {
            teamStats[teamA].played++;
            teamStats[teamA].goalsFor += scoreA;
            teamStats[teamA].goalsAgainst += scoreB;
          }
          if (teamStats[teamB]) {
            teamStats[teamB].played++;
            teamStats[teamB].goalsFor += scoreB;
            teamStats[teamB].goalsAgainst += scoreA;
          }

          if (scoreA > scoreB) {
            if (teamStats[teamA]) teamStats[teamA].wins++;
            if (teamStats[teamB]) teamStats[teamB].losses++;
          } else if (scoreB > scoreA) {
            if (teamStats[teamB]) teamStats[teamB].wins++;
            if (teamStats[teamA]) teamStats[teamA].losses++;
          } else { // Draw
            if (teamStats[teamA]) teamStats[teamA].draws++;
            if (teamStats[teamB]) teamStats[teamB].draws++;
          }
        }
      });
      const currentPointsPerWin = tournamentDetails?.pointsPerWin || 3;
      const currentPointsPerDraw = tournamentDetails?.pointsPerDraw || 1;

      const batch = writeBatch(db);
      for (const teamName in teamStats) {
        const stats = teamStats[teamName];
        stats.goalDifference = stats.goalsFor - stats.goalsAgainst;
        stats.points = (stats.wins * currentPointsPerWin) + (stats.draws * currentPointsPerDraw);

        const teamLeaderboardDocRef = doc(leaderboardRef, stats.id);
        batch.set(teamLeaderboardDocRef, stats, { merge: true });
      }

      await batch.commit();
      console.log('Leaderboard updated successfully!');
    } catch (err) {
      console.error('Error updating leaderboard:', err);
    }
  }, [tournamentId, tournamentDetails, isViewOnly, user, tournamentOwnerId]); // Added user, tournamentOwnerId to dependencies

  // Effect to trigger leaderboard update when fixtures or tournamentDetails change
  useEffect(() => {
    // Only update leaderboard if not in view-only mode and is the owner
    if (!isViewOnly && user?.uid === tournamentOwnerId) {
      if (fixtures.length > 0 || (fixtures.length === 0 && !loadingTournamentData)) {
        updateLeaderboard();
      }
    }
  }, [fixtures, tournamentDetails, authLoading, user, updateLeaderboard, loadingTournamentData, isViewOnly, tournamentOwnerId]);

  // --- Team Management Handlers ---
  const handleAddTeam = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to add teams in view-only mode.', null, false);
      return;
    }
    setTeamError('');
    if (!newTeamName.trim()) {
      setTeamError('Team name cannot be empty.');
      return;
    }
    if (teams.some(team => team.name.toLowerCase() === newTeamName.trim().toLowerCase())) {
      setTeamError('A team with this name already exists.');
      return;
    }
    try {
      await addDoc(collection(db, `tournaments/${tournamentId}/teams`), { name: newTeamName });
      setNewTeamName('');
    } catch (err) {
      console.error('Error adding team:', err);
      setTeamError('Failed to add team. Make sure the tournament ID is valid and you have permission.');
    }
  };
  const handleDeleteTeam = async (teamId) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to delete teams in view-only mode.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Delete',
      'Are you sure you want to delete this team? This action cannot be undone.',
      async () => {
        try {
          await deleteDoc(doc(db, `tournaments/${tournamentId}/teams`, teamId));
          closeCustomModal();
          updateLeaderboard();
        } catch (err) {
          console.error('Error deleting team:', err);
          openCustomModal('Error', 'Failed to delete team. Please try again.');
        }
      }
    );
  };

  const handleClearAllTeams = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to clear all teams in view-only mode.', null, false);
      return;
    }
    if (teams.length === 0) {
      openCustomModal('Info', 'No teams to clear.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Clear All Teams',
      'Are you sure you want to delete ALL teams? This will also affect past match records.',
      async () => {
        const batch = writeBatch(db);
        teams.forEach(team => {
          const teamRef = doc(db, `tournaments/${tournamentId}/teams`, team.id);
          batch.delete(teamRef);
        });
        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', 'All teams cleared successfully.', null, false);
          updateLeaderboard();
        } catch (err) {
          console.error('Error clearing teams:', err);
          openCustomModal('Error', 'Failed to clear all teams. Please try again.');
        }
      }
    );
  };

  // --- Tournament Settings Handlers ---
  const handleSaveTournamentSettings = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to save settings in view-only mode.', null, false);
      return;
    }
    try {
      const tournamentRef = doc(db, 'tournaments', tournamentId);
      await updateDoc(tournamentRef, {
        enableColors: enableColors,
        promotionSpots: parseInt(promotionSpots) || 0,
        europeLeagueSpots: parseInt(europeLeagueSpots) || 0,
        relegationSpots: parseInt(relegationSpots) || 0,
        fixtureOption: fixtureOption,
        pointsPerWin: parseInt(pointsPerWin) || 3,
        pointsPerDraw: parseInt(pointsPerDraw) || 1,
      });
      openCustomModal('Success', 'Tournament settings saved successfully!', null, false);
      setTournamentDetails(prev => ({
        ...prev,
        enableColors: enableColors,
        promotionSpots: parseInt(promotionSpots) || 0,
        europeLeagueSpots: parseInt(europeLeagueSpots) || 0,
        relegationSpots: parseInt(relegationSpots) || 0,
        fixtureOption: fixtureOption,
        pointsPerWin: parseInt(pointsPerWin) || 3,
        pointsPerDraw: parseInt(pointsPerDraw) || 1,
      }));
    } catch (err) {
      console.error('Error saving tournament configuration:', err);
      openCustomModal('Error', 'Failed to save tournament configuration. Please try again.');
    }
  };

  // New handler to toggle tournament public status and generate link
  const handleTogglePublicStatus = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to change public status.', null, false);
      return;
    }

    const currentPublicStatus = tournamentDetails?.isPublic || false;
    const newPublicStatus = !currentPublicStatus;
    openCustomModal(
      'Confirm Public Status Change',
      `Are you sure you want to ${newPublicStatus ? 'make this tournament PUBLIC' : 'make this tournament PRIVATE'}?`,
      async () => {
        try {
          const tournamentRef = doc(db, 'tournaments', tournamentId);
          await updateDoc(tournamentRef, { isPublic: newPublicStatus });
          setTournamentDetails(prev => ({ ...prev, isPublic: newPublicStatus }));

          if (newPublicStatus) {
            const link = `${window.location.origin}/tournament/${tournamentId}?shareId=${tournamentId}`;
            setShareableLink(link);
            openCustomModal('Success', `Tournament is now public! Share this link: ${link}`, null, false);
          } else {
            setShareableLink('');
            openCustomModal('Success', 'Tournament is now private.', null, false);
          }
          closeCustomModal();
        } catch (err) {
          console.error('Error updating public status:', err);
          openCustomModal('Error', 'Failed to update public status. Please try again.');
        }
      }
    );
  };

  // Helper to copy share link to clipboard
  const copyShareLink = useCallback(() => {
    if (shareableLink) {
      navigator.clipboard.writeText(shareableLink)
        .then(() => openCustomModal('Link Copied!', 'The shareable link has been copied to your clipboard.', null, false))
        .catch(err => openCustomModal('Error', 'Failed to copy link. Please copy it manually.', null, false));
    }
  }, [shareableLink, openCustomModal]);

  // New helper function to shuffle an array
  const shuffleArray = useCallback((array) => {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex], array[currentIndex]];
    }
    return array;
  }, []);

  // Modified generateRoundRobinFixtures function
  const generateRoundRobinFixtures = useCallback((teamNames, isHomeAndAway) => {
    const numTeams = teamNames.length;
    if (numTeams < 2) return [];

    let teamsForScheduling = [...teamNames];
    if (numTeams % 2 !== 0) {
      teamsForScheduling.push('BYE');
    }

    const n = teamsForScheduling.length;
    const roundsNeeded = n - 1;

    let allLogicalRounds = [];

    for (let roundNum = 0; roundNum < roundsNeeded; roundNum++) {
      let currentRoundFixtures = [];

      const fixedTeam = teamsForScheduling[0];

      const rotatingTeamOppositeFixed = teamsForScheduling[(roundNum + (n - 1)) % (n - 1) + 1] || teamsForScheduling[n - 1]; // Corrected indexing for robustness
      if (fixedTeam !== 'BYE' && rotatingTeamOppositeFixed !== 'BYE') {
        if (roundNum % 2 === 0) {
          currentRoundFixtures.push({ teamA: fixedTeam, teamB: rotatingTeamOppositeFixed });
        } else {
          currentRoundFixtures.push({ teamA: rotatingTeamOppositeFixed, teamB: fixedTeam });
        }
      }

      for (let i = 1; i < n / 2; i++) {
        const team1 = teamsForScheduling[(roundNum + i) % (n - 1) + 1];
        const team2 = teamsForScheduling[(roundNum + n - 1 - i) % (n - 1) + 1];
        if (team1 !== 'BYE' && team2 !== 'BYE') {
          if (i % 2 === 0) {
            currentRoundFixtures.push({ teamA: team1, teamB: team2 });
          } else {
            currentRoundFixtures.push({ teamA: team2, teamB: team1 });
          }
        }
      }
      shuffleArray(currentRoundFixtures);
      allLogicalRounds.push(currentRoundFixtures);
    }

    let finalFixturesForDb = [];

    if (isHomeAndAway) {
      let returnRounds = [];
      allLogicalRounds.forEach(round => {
        let returnRound = [];
        round.forEach(fixture => {
          returnRound.push({ teamA: fixture.teamB, teamB: fixture.teamA });
        });
        returnRounds.push(returnRound);
      });
      allLogicalRounds = [...allLogicalRounds, ...returnRounds];
    }

    allLogicalRounds.forEach((roundFixtures, index) => {
      const weekNumber = index + 1;
      roundFixtures.forEach(fixture => {
        finalFixturesForDb.push({
          ...fixture,
          weekNumber: weekNumber,
        });
      });
    });
    return finalFixturesForDb;
  }, [shuffleArray]);

  const handleGenerateFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to generate fixtures in view-only mode.', null, false);
      return;
    }
    if (teams.length < 2) {
      openCustomModal('Info', 'You need at least two teams to generate fixtures!', null, false);
      return;
    }
    if (!tournamentDetails) {
      openCustomModal('Error', 'Tournament details not loaded. Cannot generate fixtures.', null, false);
      return;
    }

    const currentFixtureOption = tournamentDetails.fixtureOption || 'Single Matches';
    const teamNames = teams.map(t => t.name);
    const generatedFixturesWithWeekNumbers = generateRoundRobinFixtures(teamNames, currentFixtureOption === 'Home and Away Matches');

    let currentDate = new Date();
    currentDate.setHours(12, 0, 0, 0);
    const finalFixturesToSave = [];
    const groupedByWeek = generatedFixturesWithWeekNumbers.reduce((acc, fixture) => {
      const weekNum = fixture.weekNumber;
      if (!acc[weekNum]) {
        acc[weekNum] = [];
      }
      acc[weekNum].push(fixture);
      return acc;
    }, {});
    const sortedWeekNumbers = Object.keys(groupedByWeek).sort((a, b) => parseInt(a) - parseInt(b));

    sortedWeekNumbers.forEach(weekNum => {
      const fixturesInThisWeek = groupedByWeek[weekNum];
      fixturesInThisWeek.forEach(fixture => {
        finalFixturesToSave.push({
          teamA: fixture.teamA,
          teamB: fixture.teamB,
          date: currentDate.toISOString().split('T')[0],
          timestamp: new Date(currentDate),
          status: 'scheduled',
          scoreA: 0,
          scoreB: 0,
          weekNumber: parseInt(weekNum),
        });
      });
      currentDate.setDate(currentDate.getDate() + 7);
    });

    if (finalFixturesToSave.length === 0) {
      openCustomModal('Info', 'No fixtures could be generated. Check your team list and fixture options.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Fixture Generation',
      `This will delete ALL existing fixtures and generate ${finalFixturesToSave.length} new ones based on '${currentFixtureOption}'. Are you sure?`,
      async () => {
        const batch = writeBatch(db);
        const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);

        const existingFixturesSnapshot = await getDocs(fixturesCollectionRef);
        existingFixturesSnapshot.docs.forEach((doc) => {
          batch.delete(doc.ref);
        });

        finalFixturesToSave.forEach(fixture => {
          const newFixtureRef = doc(fixturesCollectionRef);
          batch.set(newFixtureRef, fixture);
        });

        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', `Successfully generated ${finalFixturesToSave.length} fixtures!`, null, false);
          updateLeaderboard();
        } catch (err) {
          console.error('Error generating fixtures:', err);
          openCustomModal('Error', 'Failed to generate fixtures. Please try again.');
        }
      }
    );
  };
  const handleAddFixture = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to add fixtures in view-only mode.', null, false);
      return;
    }
    setFixtureError('');
    if (!newFixture.teamA || !newFixture.teamB || !newFixture.date) {
      setFixtureError('Please select both teams and a date for the fixture.');
      return;
    }
    if (newFixture.teamA === newFixture.teamB) {
      setFixtureError('Teams cannot be the same.');
      return;
    }
    try {
      const fixtureDate = new Date(newFixture.date);
      if (isNaN(fixtureDate.getTime())) {
        setFixtureError('Invalid date format.');
        return;
      }
      fixtureDate.setHours(12, 0, 0, 0);
      await addDoc(collection(db, `tournaments/${tournamentId}/fixtures`), {
        ...newFixture,
        timestamp: fixtureDate,
        scoreA: 0,
        scoreB: 0,
        status: 'scheduled',
        weekNumber: 0,
      });
      setNewFixture({ teamA: '', teamB: '', date: '', timestamp: null, status: 'scheduled', scoreA: 0, scoreB: 0 });
    } catch (err) {
      console.error('Error adding fixture:', err);
      setFixtureError('Failed to add fixture.');
    }
  };
  const handleDeleteFixture = async (fixtureId) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to delete fixtures in view-only mode.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Delete',
      'Are you sure you want to delete this fixture? This action cannot be undone.',
      async () => {
        try {
          await deleteDoc(doc(db, `tournaments/${tournamentId}/fixtures`, fixtureId));
          closeCustomModal();
          updateLeaderboard();
        } catch (err) {
          console.error('Error deleting fixture:', err);
          openCustomModal('Error', 'Failed to delete fixture. Please try again.');
        }
      }
    );
  };
  const handleClearAllFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to clear all fixtures in view-only mode.', null, false);
      return;
    }
    if (fixtures.length === 0) {
      openCustomModal('Info', 'No fixtures to clear.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Clear All Fixtures',
      'Are you sure you want to delete ALL fixtures? This will reset match data for the leaderboard.',
      async () => {
        const batch = writeBatch(db);
        fixtures.forEach(fixture => {
          const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, fixture.id);
          batch.delete(fixtureRef);
        });
        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', 'All fixtures cleared successfully.', null, false);
          updateLeaderboard();
        } catch (err) {
          console.error('Error clearing fixtures:', err);
          openCustomModal('Error', 'Failed to clear all fixtures. Please try again.');
        }
      }
    );
  };

  // UPDATED handleUpdateScores to use ScoreInputModalContent
  const handleUpdateScores = useCallback(async (fixtureId, currentScoreA, currentScoreB) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to update scores in view-only mode.', null, false);
      return;
    }
    const fixtureToUpdate = fixtures.find(f => f.id === fixtureId);
    if (!fixtureToUpdate) {
      console.warn(`Fixture with ID ${fixtureId} not found.`);
      return;
    }
    setCurrentFixtureToUpdate(fixtureToUpdate);
    const confirmAction = async () => {
      if (!scoreInputRef.current) {
        console.error("scoreInputRef.current is null. ScoreInputModalContent might not be mounted or ref not attached.");
        openCustomModal('Error', 'Internal error: Cannot read scores. Please try again.', null, false);
        return;
      }
      const parsedScoreA = parseInt(scoreInputRef.current.getScoreA());
      const parsedScoreB = parseInt(scoreInputRef.current.getScoreB());

      if (isNaN(parsedScoreA) || isNaN(parsedScoreB)) {
        openCustomModal('Invalid Input', 'Please enter valid numbers for scores.', null, false, (
          <ScoreInputModalContent
            ref={scoreInputRef}
            fixture={fixtureToUpdate}
            initialScoreA={scoreInputRef.current.getScoreA()}
            initialScoreB={scoreInputRef.current.getScoreB()}
          />
        ));
        return;
      }

      try {
        const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, fixtureId);
        await updateDoc(fixtureRef, {
          scoreA: parsedScoreA,
          scoreB: parsedScoreB,
          status: 'completed'
        });
        closeCustomModal();
        updateLeaderboard();
      } catch (err) {
        console.error('Error updating scores:', err);
        openCustomModal('Error', 'Failed to update scores. Please try again.', null, false, (
          <ScoreInputModalContent
            ref={scoreInputRef}
            fixture={fixtureToUpdate}
            initialScoreA={scoreInputRef.current.getScoreA()}
            initialScoreB={scoreInputRef.current.getScoreB()}
          />
        ));
      }
    };

    openCustomModal(
      'Update Match Scores',
      `Enter scores for ${fixtureToUpdate.teamA} vs ${fixtureToUpdate.teamB}:`,
      confirmAction,
      true,
      <ScoreInputModalContent
        ref={scoreInputRef}
        fixture={fixtureToUpdate}
        initialScoreA={currentScoreA}
        initialScoreB={currentScoreB}
      />
    );
  }, [fixtures, tournamentId, openCustomModal, closeCustomModal, updateLeaderboard, isViewOnly, user, tournamentOwnerId]);


  // Common Loading/Error/No Access UI
  const renderLoadingOrError = () => (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar - Always render for consistent layout */}
      <div className="bg-red-600 text-white p-4 flex flex-wrap justify-center sm:justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">AI PREDICTION</Link>
      </div>

      <div className="p-4 sm:p-6 md:p-8 max-w-4xl mx-auto w-full">
        <h2 className="text-2xl sm:text-3xl font-bold mb-4 text-center">‚ú® {tournamentName} Details</h2>
        {generalError ?
          (
            <p className="text-red-500 text-center py-8">{generalError}</p>
          ) : (
            <p className="text-center text-gray-500 py-8">Loading tournament data...</p>
          )}
      </div>
    </div>
  );

  if (loadingTournamentData || authLoading || generalError) {
    return renderLoadingOrError();
  }

  // Determine if the current user is the owner
  const isOwner = user && user.uid === tournamentOwnerId;

  // Render content based on view-only mode
  console.log('TournamentPage rendering. isViewOnly:', isViewOnly, 'isOwner:', isOwner); // Debugging line


  return (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex flex-wrap justify-center sm:justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors min-w-[100px] md:min-w-0">AI PREDICTION</Link>
      </div>

      {/* Main Content Area */}
      <div className="flex-grow p-4 sm:p-6 md:p-8 max-w-7xl mx-auto w-full">
        <h1 className="text-3xl sm:text-4xl font-extrabold text-center mb-6 sm:mb-8 text-red-600 dark:text-red-400">
          {tournamentName}
        </h1>

        {isViewOnly && (
          <p className="text-center text-sm sm:text-base text-blue-500 mb-6 font-semibold bg-blue-100 dark:bg-blue-900 p-3 rounded-md">
            You are in view-only mode for this tournament. Some features are disabled.
          </p>
        )}

        {/* Tournament Owner Controls (Conditionally Rendered) */}
        {(!isViewOnly && isOwner) && (
          <div className="bg-gray-100 dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl sm:text-2xl font-bold mb-4 text-gray-800 dark:text-white">Tournament Controls</h2>

            {/* Public/Private Toggle */}
            <div className="mb-4 flex flex-col sm:flex-row sm:items-center sm:justify-between">
              <label htmlFor="publicToggle" className="block text-gray-700 dark:text-gray-300 font-semibold mb-2 sm:mb-0">
                Tournament Status:
              </label>
              <div className="flex items-center">
                <span className={`mr-2 font-medium ${tournamentDetails?.isPublic ? 'text-green-600' : 'text-gray-500'}`}>
                  {tournamentDetails?.isPublic ? 'PUBLIC' : 'PRIVATE'}
                </span>
                <button
                  onClick={handleTogglePublicStatus}
                  className={`px-4 py-2 rounded-md text-sm font-semibold transition-colors duration-200
                  ${tournamentDetails?.isPublic
                      ? 'bg-orange-500 hover:bg-orange-600 text-white'
                      : 'bg-green-500 hover:bg-green-600 text-white'
                    } w-full sm:w-auto`}
                >
                  {tournamentDetails?.isPublic ? 'Make Private' : 'Make Public'}
                </button>
              </div>
            </div>

            {/* Shareable Link */}
            {shareableLink && (
              <div className="mb-4">
                <label className="block text-gray-700 dark:text-gray-300 font-semibold mb-2">Shareable Link:</label>
                <div className="flex flex-col sm:flex-row items-center">
                  <input
                    type="text"
                    readOnly
                    value={shareableLink}
                    className="flex-grow p-2 border border-gray-300 rounded-md bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white mb-2 sm:mb-0 sm:mr-2 w-full"
                    onClick={(e) => e.target.select()} // Select all text on click
                  />
                  <button
                    onClick={copyShareLink}
                    className="bg-blue-500 text-white px-4 py-2 rounded-md text-sm hover:bg-blue-600 transition-colors font-semibold w-full sm:w-auto"
                  >
                    Copy Link
                  </button>
                </div>
              </div>
            )}

            {/* Tournament Configuration */}
            <h3 className="text-lg sm:text-xl font-bold mt-6 mb-3 text-gray-700 dark:text-gray-200">Configuration Settings</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
              <div>
                <label htmlFor="fixtureOption" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Fixture Type:</label>
                <select
                  id="fixtureOption"
                  value={fixtureOption}
                  onChange={(e) => setFixtureOption(e.target.value)}
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                >
                  <option value="Single Matches">Single Matches</option>
                  <option value="Home and Away Matches">Home and Away Matches</option>
                </select>
              </div>
              <div className="flex items-center">
                <input
                  type="checkbox"
                  id="enableColors"
                  checked={enableColors}
                  onChange={(e) => setEnableColors(e.target.checked)}
                  className="mr-2 h-4 w-4 text-red-600 focus:ring-red-500 border-gray-300 rounded"
                />
                <label htmlFor="enableColors" className="text-sm font-medium text-gray-700 dark:text-gray-300">Enable Leaderboard Colors</label>
              </div>
              <div>
                <label htmlFor="promotionSpots" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Promotion Spots (Top N):</label>
                <input
                  type="number"
                  id="promotionSpots"
                  value={promotionSpots}
                  onChange={(e) => setPromotionSpots(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              <div>
                <label htmlFor="europeLeagueSpots" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Europe League Spots (Next N):</label>
                <input
                  type="number"
                  id="europeLeagueSpots"
                  value={europeLeagueSpots}
                  onChange={(e) => setEuropeLeagueSpots(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              <div>
                <label htmlFor="relegationSpots" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Relegation Spots (Bottom N):</label>
                <input
                  type="number"
                  id="relegationSpots"
                  value={relegationSpots}
                  onChange={(e) => setRelegationSpots(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              <div>
                <label htmlFor="pointsPerWin" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Points per Win:</label>
                <input
                  type="number"
                  id="pointsPerWin"
                  value={pointsPerWin}
                  onChange={(e) => setPointsPerWin(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              <div>
                <label htmlFor="pointsPerDraw" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Points per Draw:</label>
                <input
                  type="number"
                  id="pointsPerDraw"
                  value={pointsPerDraw}
                  onChange={(e) => setPointsPerDraw(e.target.value)}
                  min="0"
                  className="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
            </div>
            <button
              onClick={handleSaveTournamentSettings}
              className="bg-green-500 text-white font-bold py-2 px-6 rounded-md hover:bg-green-600 transition-colors duration-200 uppercase tracking-wide w-full md:w-auto"
            >
              Save Settings
            </button>
          </div>
        )}

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Teams Section */}
          <div className="lg:col-span-1 bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md">
            <h2 className="text-xl sm:text-2xl font-bold mb-4 text-gray-800 dark:text-white">Teams ({teams.length})</h2>
            {teamError && <p className="text-red-500 mb-4">{teamError}</p>}
            {(!isViewOnly && isOwner) && (
              <div className="mb-6">
                <input
                  type="text"
                  placeholder="New team name"
                  value={newTeamName}
                  onChange={(e) => setNewTeamName(e.target.value)}
                  className="w-full p-2 border border-gray-300 rounded-md mb-2 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
                <button
                  onClick={handleAddTeam}
                  className="bg-blue-500 text-white px-4 py-2 rounded-md text-sm hover:bg-blue-600 transition-colors font-semibold w-full"
                >
                  Add Team
                </button>
              </div>
            )}
            {teams.length === 0 ? (
              <p className="text-gray-500 dark:text-gray-400">No teams added yet.</p>
            ) : (
              <div className="overflow-x-auto">
                <ul className="divide-y divide-gray-200 dark:divide-gray-700">
                  {teams.map((team) => (
                    <li key={team.id} className="py-3 flex flex-col sm:flex-row justify-between items-center">
                      <span className="font-semibold text-gray-900 dark:text-white text-base sm:text-lg mb-2 sm:mb-0">
                        {team.name}
                      </span>
                      {(!isViewOnly && isOwner) && (
                        <button
                          onClick={() => handleDeleteTeam(team.id)}
                          className="bg-red-500 text-white px-3 py-1 rounded-md text-sm hover:bg-red-600 transition-colors font-semibold w-full sm:w-auto"
                        >
                          Delete
                        </button>
                      )}
                    </li>
                  ))}
                </ul>
              </div>
            )}
            {(!isViewOnly && isOwner) && (
              <button
                onClick={handleClearAllTeams}
                className="bg-red-500 text-white font-bold py-2 px-6 rounded-md hover:bg-red-600 transition-colors duration-200 uppercase tracking-wide mt-6 w-full"
              >
                Clear All Teams
              </button>
            )}
          </div>

          {/* Fixtures Section */}
          <div className="lg:col-span-2 bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md">
            <h2 className="text-xl sm:text-2xl font-bold mb-4 text-gray-800 dark:text-white">Fixtures ({fixtures.length})</h2>
            {fixtureError && <p className="text-red-500 mb-4">{fixtureError}</p>}

            {(!isViewOnly && isOwner) && (
              <>
                <div className="mb-6 grid grid-cols-1 md:grid-cols-3 gap-4">
                  <select
                    value={newFixture.teamA}
                    onChange={(e) => setNewFixture({ ...newFixture, teamA: e.target.value })}
                    className="p-2 border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white w-full"
                  >
                    <option value="">Select Team A</option>
                    {teams.map(team => (
                      <option key={team.id} value={team.name}>{team.name}</option>
                    ))}
                  </select>
                  <select
                    value={newFixture.teamB}
                    onChange={(e) => setNewFixture({ ...newFixture, teamB: e.target.value })}
                    className="p-2 border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white w-full"
                  >
                    <option value="">Select Team B</option>
                    {teams.map(team => (
                      <option key={team.id} value={team.name}>{team.name}</option>
                    ))}
                  </select>
                  <input
                    type="date"
                    value={newFixture.date}
                    onChange={(e) => setNewFixture({ ...newFixture, date: e.target.value })}
                    className="p-2 border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white w-full"
                  />
                </div>
                <div className="flex flex-col sm:flex-row gap-4 mb-6">
                  <button
                    onClick={handleAddFixture}
                    className="bg-green-500 text-white px-4 py-2 rounded-md text-sm hover:bg-green-600 transition-colors font-semibold w-full sm:flex-1"
                  >
                    Add Custom Fixture
                  </button>
                  <button
                    onClick={handleGenerateFixtures}
                    className="bg-purple-500 text-white px-4 py-2 rounded-md text-sm hover:bg-purple-600 transition-colors font-semibold w-full sm:flex-1"
                  >
                    Generate Round-Robin Fixtures
                  </button>
                </div>
              </>
            )}

            {fixtures.length === 0 ? (
              <p className="text-gray-500 dark:text-gray-400">No fixtures scheduled yet.</p>
            ) : (
              <div className="overflow-x-auto">
                <ul className="divide-y divide-gray-200 dark:divide-gray-700">
                  {fixtures.map((fixture) => (
                    <li key={fixture.id} className="py-3 flex flex-col sm:flex-row justify-between items-center">
                      <div className="flex-1 mb-2 sm:mb-0 sm:mr-4">
                        <span className="font-semibold text-gray-900 dark:text-white text-base sm:text-lg">
                          {fixture.teamA} vs {fixture.teamB}
                        </span>
                        <p className="text-gray-600 dark:text-gray-400 text-sm">
                          {fixture.date} - Status:
                          <span className={`ml-1 font-medium ${fixture.status === 'completed' ? 'text-green-500' : 'text-yellow-500'}`}>
                            {fixture.status.toUpperCase()}
                          </span>
                          {fixture.status === 'completed' && (
                            <span className="ml-2 text-gray-700 dark:text-gray-300">
                              ({fixture.scoreA} - {fixture.scoreB})
                            </span>
                          )}
                        </p>
                      </div>
                      {(!isViewOnly && isOwner) && (
                        <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
                          <button
                            onClick={() => handleUpdateScores(fixture.id, fixture.scoreA, fixture.scoreB)}
                            className="bg-indigo-500 text-white px-4 py-2 rounded-md text-sm hover:bg-indigo-600 transition-colors font-semibold"
                          >
                            Update Score
                          </button>
                          <button
                            onClick={() => handleDeleteFixture(fixture.id)}
                            className="bg-red-500 text-white px-4 py-2 rounded-md text-sm hover:bg-red-600 transition-colors font-semibold"
                          >
                            Delete
                          </button>
                        </div>
                      )}
                    </li>
                  ))}
                </ul>
              </div>
            )}
            {(!isViewOnly && isOwner) && ( // Only show this button if not view-only AND owner
              <button
                onClick={handleClearAllFixtures}
                className="bg-red-500 text-white font-bold py-2 px-6 rounded-md hover:bg-red-600 transition-colors duration-200 uppercase tracking-wide mt-6 w-full"
              >
                Clear All Fixtures
              </button>
            )}
          </div>
        </div>
      </div>

      {/* Reusable Modal Component (from ../components/Modal.jsx) */}
      <Modal
        isOpen={isModalOpen}
        onClose={closeCustomModal}
        onConfirm={modalConfirmAction}
        title={modalTitle}
        message={modalMessage}
        showConfirmButton={modalShowConfirmButton}
      >
        {/* Render custom content (e.g., score input fields) inside the modal */}
        {modalContent}
      </Modal>
    </div>
  );
}

--- END FILE: src\pages\TournamentPage.jsx ---

--- START FILE: src\utils\passwordStrength.js ---

// src/utils/passwordStrength.js

export const getPasswordStrength = (password) => {
    let strength = 0;

    // Check for length
    if (password.length >= 8) {
        strength++;
    }

    // Check for uppercase and lowercase characters
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) {
        strength++;
    }

    // Check for numbers
    if (/\d/.test(password)) {
        strength++;
    }

    // Check for special characters
    if (/[^a-zA-Z0-9]/.test(password)) {
        strength++;
    }

    // Cap strength at 4
    return Math.min(strength, 4);
};

export const getStrengthColor = (strength) => {
    switch (strength) {
        case 0:
            return 'text-gray-400'; // Too Short / No Input
        case 1:
            return 'text-red-500'; // Weak
        case 2:
            return 'text-orange-500'; // Moderate
        case 3:
            return 'text-yellow-500'; // Good
        case 4:
            return 'text-green-500'; // Strong
        default:
            return 'text-gray-400';
    }
};

--- END FILE: src\utils\passwordStrength.js ---

----------------------------------------------------------------------------------------

tell me exactly waht to edit and what code snippet to add in their place for inlcuding a new tournament format? the new tournament format is multi phase tournament where group stage will be there and after group stage knockout stage will be there(round of 16, quarter finals, semi finals, final), this format will also have the option of single match or double match(home and away), just like the league round robin format every functionality will be there, except the difference in format.
