
--- START FILE: .gitignore ---

# ‚öôÔ∏è Node.js
node_modules/
dist/
.vite/
.env

# ‚öôÔ∏è Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ‚öôÔ∏è IDEs and editors
.vscode/
.idea/
*.sublime-project
*.sublime-workspace

# ‚öôÔ∏è System files
.DS_Store
Thumbs.db

# ‚öôÔ∏è Firebase emulators & CLI cache (if using locally)
.firebase/
.firebaserc
.firebase-debug.log


--- END FILE: .gitignore ---

--- START FILE: combine_project.py ---

import os

def combine_files_to_single_file(root_dir, output_filename="combined_project_files.txt"):
    """
    Combines the content of all files in a directory into a single file,
    excluding 'node_modules' directories and 'package-lock.json' files.

    Args:
        root_dir (str): The root directory of the project.
        output_filename (str): The name of the output file.
    """
    combined_content = []
    excluded_dirs = ['node_modules', '.git', '.vscode', '.idea', 'dist', 'build']
    excluded_files = ['package-lock.json', 'yarn.lock', 'bun.lockb', '.env'] # Added .env as it might contain sensitive info

    print(f"Starting to combine files from: {root_dir}")
    print(f"Excluding directories: {excluded_dirs}")
    print(f"Excluding files: {excluded_files}")

    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Modify dirnames in-place to skip excluded directories
        dirnames[:] = [d for d in dirnames if d not in excluded_dirs]

        for filename in filenames:
            if filename in excluded_files:
                print(f"Skipping excluded file: {os.path.join(dirpath, filename)}")
                continue

            file_path = os.path.join(dirpath, filename)
            # Make path relative to root_dir for the header
            relative_file_path = os.path.relpath(file_path, root_dir)

            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                combined_content.append(f"\n--- START FILE: {relative_file_path} ---\n\n")
                combined_content.append(content)
                combined_content.append(f"\n\n--- END FILE: {relative_file_path} ---\n")
                print(f"Included file: {relative_file_path}")
            except UnicodeDecodeError:
                print(f"Skipping binary or undecodable file (UnicodeDecodeError): {relative_file_path}")
            except Exception as e:
                print(f"Error reading file {relative_file_path}: {e}")

    output_path = os.path.join(root_dir, output_filename)
    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("".join(combined_content))
        print(f"\nSuccessfully combined all files into: {output_path}")
    except Exception as e:
        print(f"Error writing output file {output_path}: {e}")

if __name__ == "__main__":
    # Get the current working directory where the script is run
    # This assumes you run the script from your project's root directory
    project_root = os.getcwd()
    combine_files_to_single_file(project_root)


--- END FILE: combine_project.py ---

--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#1f2937" /> <!-- Defines a theme color for the browser UI, useful for mobile browsers -->
    <title>Tournament Manager</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <!-- Link to the favicon for the browser tab -->
    
    <!-- Preconnect to Google Fonts domains for improved loading performance of fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Link to the 'Inter' font from Google Fonts. Loads weights 400, 500, 600, 700. -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <!-- 
    Apply base Tailwind CSS classes for background and text colors.
    'bg-gray-100' and 'text-gray-900' for light mode.
    'dark:bg-gray-900' and 'dark:text-white' for dark mode (controlled by 'dark' class on html element via JavaScript).
    'font-inter' class ensures the 'Inter' font is used throughout the body.
  -->
  <body class="bg-gray-100 text-gray-900 dark:bg-gray-900 dark:text-white font-inter">
    <div id="root"></div> <!-- This is the root element where your React application will be mounted by main.jsx -->
    <script type="module" src="/src/main.jsx"></script> <!-- This script tag is the entry point for your client-side React application -->
  </body>
</html>


--- END FILE: index.html ---

--- START FILE: package.json ---

{
  "name": "tournament-manager",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "chart.js": "^4.5.0",
    "firebase": "^10.12.0",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^6.23.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.1.0",
    "autoprefixer": "^10.4.19",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.1",
    "vite": "^5.2.8"
  }
}


--- END FILE: package.json ---

--- START FILE: postcss.config.js ---

// ‚úÖ postcss.config.js (CommonJS)
module.exports = {
  plugins: {
    tailwindcss: {}, // Plugin for processing Tailwind CSS
    autoprefixer: {}, // Plugin for adding vendor prefixes to CSS rules
  },
};


--- END FILE: postcss.config.js ---

--- START FILE: README.md ---

check out the website here: https://tournament-manager-website.netlify.app/


--- END FILE: README.md ---

--- START FILE: tailwind.config.js ---

/** @type {import('tailwindcss').Config} */
export default {
  // Configure files to scan for Tailwind classes.
  // These paths tell Tailwind CSS where to look for class names
  // to generate the final CSS bundle, optimizing its size.
  content: [
    "./index.html", // Include the main HTML file where global classes might be used.
    "./src/**/*.{js,ts,jsx,tsx}", // Include all JavaScript, TypeScript, and React files in the 'src' directory.
  ],

  // Enable dark mode based on the presence of a 'dark' class on the HTML element.
  // This allows you to toggle dark/light themes by adding/removing 'dark' class via JavaScript.
  darkMode: "class", // üåô Enable dark mode via class

  theme: {
    // Extend the default Tailwind CSS theme.
    // This allows you to add custom configurations without overriding Tailwind's defaults.
    extend: {
      // Define a custom color palette.
      // These colors can then be used as Tailwind classes (e.g., `bg-primary`, `text-secondary`).
      colors: {
        primary: "#1d4ed8",   // A shade of blue (e.g., for primary buttons, links) - corresponds to blue-700
        secondary: "#9333ea", // A shade of purple (e.g., for accents or secondary actions) - corresponds to purple-600
      },
      fontFamily: { // Define custom font family.
        // Add 'Inter' font, which should be imported from Google Fonts in index.html.
        // This allows you to use `font-inter` class in your components.
        inter: ['Inter', 'sans-serif'],
      },
    },
  },

  // Add any Tailwind CSS plugins here.
  // Plugins extend Tailwind's capabilities with new utilities or components.
  plugins: [],
};


--- END FILE: tailwind.config.js ---

--- START FILE: vite.config.js ---

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react'; // Vite plugin for React applications

export default defineConfig({
  // Define plugins for Vite. Plugins extend Vite's capabilities.
  // The 'react()' plugin is essential for React support, enabling JSX transformation, HMR, etc.
  plugins: [react()],

  // Configure the development server.
  server: {
    port: 5173 // Specify the port number on which the development server will run.
              // If this port is already in use, Vite will automatically try the next available port.
  },

  // Build configuration (optional, currently commented out in the provided code).
  // This section would define how Vite builds your application for production.
  // build: {
  //   sourcemap: true, // Enabling sourcemaps is useful for debugging production builds.
  // },

  // Further configurations could include:
  // - `resolve.alias`: For setting up path aliases (e.g., '@components' to 'src/components').
  // - `css.postcss`: If custom PostCSS processing is needed beyond the default setup.
  // - `optimizeDeps`: For fine-tuning dependency pre-bundling.
});


--- END FILE: vite.config.js ---

--- START FILE: src\App.jsx ---

import React, { useEffect, useState } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom'; // Removed Link as it's not used here

// Import Page Components
import Dashboard from './pages/Dashboard';
import TournamentPage from './pages/TournamentPage';
import FixturesPage from './pages/FixturesPage';
import LeaderboardPage from './pages/LeaderboardPage';
import AuthPage from './pages/AuthPage'; // Authentications page (login/signup)
import KnockoutPage from './pages/KnockoutPage';
import AIPredictionPage from './pages/AIPredictionPage';
import StatsPage from './pages/StatsPage';
import PlayerPage from './pages/PlayerPage';

// Import Reusable Components
import Header from './components/Header';
import ProtectedRoute from './components/ProtectedRoute'; // Component to protect routes requiring authentication

// Import Custom Hooks
import { useAuth } from './hooks/useAuth'; // Custom hook for authentication state management

export default function App() {
  // Destructure user, loading state, and logout function from the useAuth hook
  const { user, loading, logout } = useAuth();

  // State for dark mode preference, initialized from localStorage
  const [darkMode, setDarkMode] = useState(() => localStorage.getItem('dark') === 'true');

  // State for language preference, initialized from localStorage, defaults to 'en'
  const [lang, setLang] = useState(() => localStorage.getItem('lang') || 'en');

  // useEffect to apply or remove the 'dark' class from the HTML document element
  // and persist the preference in localStorage whenever darkMode state changes.
  useEffect(() => {
    if (darkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
    localStorage.setItem('dark', darkMode); // Persist dark mode setting
  }, [darkMode]);

  // useEffect to persist the language preference in localStorage whenever lang state changes.
  useEffect(() => {
    localStorage.setItem('lang', lang);
  }, [lang]);

  // Translations object for Internationalization (i18n)
  // Provides different language strings for UI elements.
  const translations = {
    en: { // English translations
      title: 'Tournament Manager',
      logout: 'Logout',
      light: 'Light Mode',
      dark: 'Dark Mode',
      dashboard: 'Dashboard',
    },
    hi: { // Hindi translations
      title: '‡§ü‡•Ç‡§∞‡•ç‡§®‡§æ‡§Æ‡•á‡§Ç‡§ü ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§®',
      logout: '‡§≤‡•â‡§ó ‡§Ü‡§â‡§ü',
      light: '‡§≤‡§æ‡§á‡§ü ‡§Æ‡•ã‡§°',
      dark: '‡§°‡§æ‡§∞‡•ç‡§ï ‡§Æ‡•ã‡§°',
      dashboard: '‡§°‡•à‡§∂‡§¨‡•ã‡§∞‡•ç‡§°',
    },
    bn: { // Bengali translations
      title: '‡¶ü‡ßÅ‡¶∞‡ßç‡¶®‡¶æ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú‡¶æ‡¶∞',
      logout: '‡¶≤‡¶ó ‡¶Ü‡¶â‡¶ü',
      light: '‡¶≤‡¶æ‡¶á‡¶ü ‡¶Æ‡ßã‡¶°',
      dark: '‡¶°‡¶æ‡¶∞‡ßç‡¶ï ‡¶Æ‡ßã‡¶°',
      dashboard: '‡¶°‡ßç‡¶Ø‡¶æ‡¶∂‡¶¨‡ßã‡¶∞‡ßç‡¶°',
    },
  };

  // Select the current translation based on the 'lang' state, falling back to English if not found.
  const t = translations[lang] || translations.en;

  // Show a loading screen while Firebase Authentication is initializing.
  // This prevents UI flashes or errors before the user's auth status is known.
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        Loading application...
      </div>
    );
  }

  // If the user is not logged in (user object is null after loading), render the AuthPage.
  // This acts as the unauthenticated entry point.
  if (!user) {
    return <AuthPage />;
  }

  // If the user is logged in, render the main application layout with routing.
  return (
    // BrowserRouter wraps the entire application to enable client-side routing.
    <BrowserRouter>
      <div className="min-h-screen bg-white text-black dark:bg-gray-900 dark:text-white flex flex-col">
        {/* Header component: Displays app title, dark mode toggle, language selector, and logout button. */}
        <Header
          darkMode={darkMode}
          setDarkMode={setDarkMode}
          lang={lang}
          setLang={setLang}
          t={t}
          // Pass the logout function from useAuth directly to the Header component.
          setToken={() => logout()}
        />

        {/* Main content area: Uses React Router's Routes component to define application routes. */}
        <div className="flex-grow">
          <Routes>
            {/* Root route: Displays the Dashboard page, protected by ProtectedRoute. */}
            <Route path="/" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />

            {/* Tournament-specific pages: These routes use a dynamic :id parameter to fetch tournament data. */}
            {/* Each is protected, ensuring only authenticated users can access them. */}
            <Route path="/tournament/:id" element={<ProtectedRoute><TournamentPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/fixtures" element={<ProtectedRoute><FixturesPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/leaderboard" element={<ProtectedRoute><LeaderboardPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/knockout" element={<ProtectedRoute><KnockoutPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/ai-prediction" element={<ProtectedRoute><AIPredictionPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/stats" element={<ProtectedRoute><StatsPage /></ProtectedRoute>} />
            <Route path="/tournament/:id/players" element={<ProtectedRoute><PlayerPage /></ProtectedRoute>} />

            {/* Fallback route: If no other route matches, it redirects to the Dashboard. */}
            {/* This is also protected. */}
            <Route path="*" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />
          </Routes>
        </div>
      </div>
    </BrowserRouter>
  );
}

--- END FILE: src\App.jsx ---

--- START FILE: src\firebase.js ---

import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
import { getAuth } from "firebase/auth"; // Only getAuth is needed here for export

// Firebase configuration.
// It prioritizes the __firebase_config global variable provided by the Canvas environment.
// If __firebase_config is not defined (e.g., in a local development setup),
// it falls back to environment variables loaded via import.meta.env.
const firebaseConfig = typeof __firebase_config !== 'undefined'
  ? JSON.parse(__firebase_config) // Parse the stringified config from the Canvas environment
  : {
      apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
      authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
      projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
      storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
      appId: import.meta.env.VITE_FIREBASE_APP_ID,
    };

// Initialize the Firebase application with the provided configuration.
const app = initializeApp(firebaseConfig);

// Get a reference to the Firestore database service.
// This is the primary way to interact with your Firestore data.
const db = getFirestore(app);

// Get a reference to the Firebase Authentication service.
// This is used for user authentication (sign-in, sign-up, etc.).
const auth = getAuth(app);

// Export the initialized Firebase app, Firestore database, and Authentication instances.
// These can then be imported and used in other parts of your React application.
export { db, app, auth };


--- END FILE: src\firebase.js ---

--- START FILE: src\index.css ---

/* index.css */
/* Tailwind CSS imports */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom scrollbar styles for a cleaner look */
/* These styles apply to Webkit browsers (Chrome, Safari, Edge) */
::-webkit-scrollbar {
  width: 8px; /* Width of the vertical scrollbar */
  height: 8px; /* Height of the horizontal scrollbar */
}

::-webkit-scrollbar-track {
  background: #f1f1f1; /* Light background for the scrollbar track in light mode */
  border-radius: 10px; /* Rounded corners for the track */
}

/* Dark mode specific scrollbar track color */
html.dark ::-webkit-scrollbar-track {
  background: #333; /* Darker background for the track in dark mode */
}

::-webkit-scrollbar-thumb {
  background: #888; /* Gray thumb (the draggable part) in light mode */
  border-radius: 10px; /* Rounded corners for the thumb */
}

/* Dark mode specific scrollbar thumb color */
html.dark ::-webkit-scrollbar-thumb {
  background: #555; /* Darker thumb in dark mode */
}

::-webkit-scrollbar-thumb:hover {
  background: #555; /* Darker gray on hover for the thumb in light mode */
}

/* Dark mode specific scrollbar thumb hover color */
html.dark ::-webkit-scrollbar-thumb:hover {
  background: #777; /* Lighter gray on hover for the thumb in dark mode */
}

/* Ensure font consistency across the application */
/* Using 'Inter' font as per project instructions. Falls back to generic sans-serif. */
body {
  font-family: 'Inter', sans-serif;
}

/* Base styles for dark mode transition, applied to the html and body elements */
/* This creates a smooth visual transition when toggling dark/light mode. */
html {
  /* Define CSS variables for global text and background colors based on mode */
  --text-color: #1f2937; /* Default text color for light mode */
  --background-color: #ffffff; /* Default background color for light mode */
  transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
}

html.dark {
  --text-color: #f3f4f6; /* Text color for dark mode */
  --background-color: #1a202c; /* Background color for dark mode (e.g., gray-900) */
}

body {
  background-color: var(--background-color);
  color: var(--text-color);
}


--- END FILE: src\index.css ---

--- START FILE: src\main.jsx ---

import React from 'react';
import ReactDOM from 'react-dom/client'; // Correct import for React 18+
import App from './App.jsx'; // Main application component
import './index.css'; // Global CSS imports, including TailwindCSS

// Get the root DOM element where the React application will be mounted.
const rootElement = document.getElementById('root');

// Create a React root. This is the new API for React 18+ concurrent mode.
const root = ReactDOM.createRoot(rootElement);

// Display a loading message immediately before the React app fully mounts.
// This provides a user-friendly experience while initial assets and authentication state are determined.
// This is done by directly manipulating the innerHTML of the root element.
// Note: While this works, typically a dedicated loading component within App.jsx
// or a splash screen managed by a loading state in App.jsx is more React-idiomatic.
if (rootElement) { // Ensure rootElement exists before modifying it
  rootElement.innerHTML = '<div style="min-height: 100vh; display: flex; align-items: center; justify-content: center; background-color: #f3f4f6; color: #1f2937;">Loading application...</div>';
}

// Render the main App component into the React root.
// <React.StrictMode> is a tool for highlighting potential problems in an application.
// It does not render any visible UI. It activates additional checks and warnings for its descendants.
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Any initial Firebase auth setup or error handling (like config issues)
// is now handled internally by the useAuth hook within App.jsx and its child components.
// The previous comment "// import { initializeAuth } from './firebase.js';" is correctly commented out
// as explicit initialization of auth from here is no longer needed with the current setup.


--- END FILE: src\main.jsx ---

--- START FILE: src\components\Header.jsx ---

import React from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth'; // Import useAuth hook

export default function Header({ darkMode, setDarkMode, lang, setLang, t }) {
  const { user, logout } = useAuth(); // Get user and logout from useAuth

  const handleLogout = async () => {
    try {
      await logout();
      // No need to clear local storage token here, as useAuth handles Firebase state and App.jsx handles UI redirect
    } catch (error) {
      console.error("Failed to log out:", error);
      // Display error to user if logout fails (consider using a modal for user-friendly feedback)
    }
  };

  return (
    <header className="bg-red-600 text-white p-4 shadow-md flex justify-between items-center">
      {/* Tournament Title/Link */}
      <Link to="/" className="text-xl font-bold tracking-wide">{t.title}</Link>

      <div className="flex items-center space-x-4">
        {/* Language Switcher */}
        <div className="relative">
          <select
            value={lang}
            onChange={(e) => setLang(e.target.value)}
            className="bg-red-700 text-white p-2 rounded-md appearance-none pr-8 focus:outline-none focus:ring-2 focus:ring-white"
            aria-label="Select Language" // Added for accessibility
          >
            <option value="en">English</option>
            <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
            <option value="bn">‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
          </select>
          {/* Custom SVG for dropdown arrow */}
          <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-white">
            <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
              <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
            </svg>
          </div>
        </div>

        {/* Dark Mode Toggle */}
        <button
          onClick={() => setDarkMode(!darkMode)}
          className="p-2 rounded-md hover:bg-red-700 transition-colors"
          aria-label={darkMode ? t.light : t.dark} // Accessible label
        >
          {darkMode ? '‚òÄÔ∏è' : 'üåô'}
        </button>

        {/* Logout Button (only if user is authenticated) */}
        {user && ( // Only show logout button if a user is logged in
          <button
            onClick={handleLogout}
            className="bg-red-700 hover:bg-red-800 text-white font-semibold py-2 px-4 rounded-md transition-colors"
          >
            {t.logout}
          </button>
        )}
      </div>
    </header>
  );
}


--- END FILE: src\components\Header.jsx ---

--- START FILE: src\components\LanguageSwitcher.jsx ---

// üìÅ src/components/LanguageSwitcher.jsx
import React from 'react';

export default function LanguageSwitcher({ lang, setLang }) {
  return (
    <select
      value={lang} // Controlled component: value is determined by the `lang` prop
      onChange={(e) => {
        setLang(e.target.value); // Update the language state
        localStorage.setItem('lang', e.target.value); // Persist the selected language in local storage
      }}
      className="border px-2 py-1 rounded bg-white dark:bg-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
      aria-label="Select application language" // Added for improved accessibility
    >
      {/* Language Options with Emojis */}
      <option value="en">üá¨üáß English</option>
      <option value="hi">üáÆüá≥ ‡§π‡§ø‡§Ç‡§¶‡•Ä</option>
      <option value="bn">üáßüá© ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
    </select>
  );
}


--- END FILE: src\components\LanguageSwitcher.jsx ---

--- START FILE: src\components\Modal.jsx ---

import React from 'react';

export default function Modal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  children, // For custom content
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  showConfirmButton = true,
}) {
  if (!isOpen) return null;

  return (
    // Overlay: Fixed position, full screen, semi-transparent black background, high z-index (z-50)
    // This div captures clicks outside the modal content to close it (if onClose is provided and appropriate)
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      {/* Modal Content Container:
          - bg-white dark:bg-gray-800: Background colors for light/dark modes.
          - p-6: Padding inside the modal content.
          - rounded-lg: Rounded corners.
          - shadow-xl: Large shadow for depth.
          - w-full max-w-sm: Responsive width, max width of 384px.
          - text-center: Centers text horizontally.
          - relative z-50: Sets a new stacking context for its children and ensures it's on top.
                            Removed 'transform' and 'transition' which can sometimes interfere with event handling.
      */}
      <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm text-center relative z-50">
        <h3 className="text-xl font-bold mb-4 text-gray-900 dark:text-white">{title || 'Attention'}</h3>
        {message && <p className="text-lg mb-4 text-gray-700 dark:text-gray-300">{message}</p>}

        {/* This is the placeholder for custom content, such as the score input fields.
            The 'children' prop renders whatever JSX is passed into the <Modal> component from its parent. */}
        {children}

        <div className="flex justify-center gap-4 mt-6">
          {showConfirmButton && (
            <button
              onClick={onConfirm} // This triggers the confirmation logic (e.g., score update)
              className="bg-red-600 text-white px-6 py-2 rounded-md hover:bg-red-700 transition-colors font-semibold"
            >
              {confirmText}
            </button>
          )}
          <button
            onClick={onClose} // This triggers the modal to close
            className="bg-gray-400 text-white px-6 py-2 rounded-md hover:bg-gray-500 transition-colors font-semibold"
          >
            {cancelText}
          </button>
        </div>
      </div>
    </div>
  );
}


--- END FILE: src\components\Modal.jsx ---

--- START FILE: src\components\ProtectedRoute.jsx ---

import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth'; // Import useAuth hook

export default function ProtectedRoute({ children }) {
  const { user, loading } = useAuth(); // Destructure user and loading from useAuth

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
        <p className="text-lg font-semibold animate-pulse">Checking authentication...</p>
      </div>
    );
  }

  // If user is not logged in, redirect to the login page
  if (!user) {
    return <Navigate to="/login" replace />; // Redirects to /login
  }

  // If user is logged in, render the children components
  return children;
}

--- END FILE: src\components\ProtectedRoute.jsx ---

--- START FILE: src\components\ScoreInputModalContent.jsx ---

import React, { useState, useEffect, useImperativeHandle, forwardRef } from 'react'; // Ensure all these are imported

// Wrap the component with forwardRef
// The 'ref' parameter here is CRUCIAL for the parent component's ref to work
const ScoreInputModalContent = forwardRef(function ScoreInputModalContent(
  { fixture, initialScoreA, initialScoreB }, // Props (first argument)
  ref // The ref from the parent (second argument)
) {
  const [localTempScoreA, setLocalTempScoreA] = useState('');
  const [localTempScoreB, setLocalTempScoreB] = useState('');

  useEffect(() => {
    // This effect ensures initial values are set when props change (e.g., modal opens for a new fixture)
    setLocalTempScoreA(initialScoreA !== undefined && initialScoreA !== null ? String(initialScoreA) : '');
    setLocalTempScoreB(initialScoreB !== undefined && initialScoreB !== null ? String(initialScoreB) : '');
  }, [initialScoreA, initialScoreB]);

  // useImperativeHandle allows the parent to call methods on this child component via the ref
  useImperativeHandle(ref, () => ({
    getScoreA: () => localTempScoreA, // Expose a method to get the current state of score A
    getScoreB: () => localTempScoreB, // Expose a method to get the current state of score B
  }));

  // Handle changes in input fields
  const handleScoreAChange = (e) => {
    const value = e.target.value;
    setLocalTempScoreA(value);
  };

  const handleScoreBChange = (e) => {
    const value = e.target.value;
    setLocalTempScoreB(value);
  };

  // This console.log is for debugging: it should print as you type.
  // If it does, then the component is rendering and its local state is updating.
  console.log('ScoreInputModalContent rendering. Local ScoreA:', localTempScoreA, 'Local ScoreB:', localTempScoreB);

  return (
    <div className="flex flex-col gap-3 mb-4">
      <input
        type="text" // Using "text" to allow custom parsing and validation
        placeholder={`Score for ${fixture.teamA}`}
        value={localTempScoreA} // Bind value to local state
        onChange={handleScoreAChange} // Use local handler
        className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        aria-label={`Score for ${fixture.teamA}`} // Accessibility
      />
      <input
        type="text" // Using "text" to allow custom parsing and validation
        placeholder={`Score for ${fixture.teamB}`}
        value={localTempScoreB} // Bind value to local state
        onChange={handleScoreBChange} // Use local handler
        className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        aria-label={`Score for ${fixture.teamB}`} // Accessibility
      />
    </div>
  );
});

export default ScoreInputModalContent; // Ensure the forwardRef-wrapped component is exported


--- END FILE: src\components\ScoreInputModalContent.jsx ---

--- START FILE: src\hooks\useAuth.js ---

import { useState, useEffect } from 'react';
import { auth, db } from '../firebase'; // Import auth and db from firebase.js
import {
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  GoogleAuthProvider, // Import GoogleAuthProvider
  signInWithPopup,    // Import signInWithPopup
  sendPasswordResetEmail // Import sendPasswordResetEmail
} from 'firebase/auth';
import { doc, setDoc } from 'firebase/firestore'; // For creating/updating user profiles in Firestore

/**
 * Custom React Hook for Firebase Authentication and User Profile Management.
 * Provides user authentication state, loading status, errors, and authentication functions.
 * @returns {{
 * user: import('firebase/auth').User | null,
 * loading: boolean,
 * error: Error | null,
 * register: (email: string, password: string) => Promise<import('firebase/auth').User>,
 * login: (email: string, password: string) => Promise<import('firebase/auth').User>,
 * loginWithGoogle: () => Promise<import('firebase/auth').User>, // New function
 * resetPassword: (email: string) => Promise<void>,             // New function
 * logout: () => Promise<void>
 * }}
 */
export const useAuth = () => {
  const [user, setUser] = useState(null); // Stores the Firebase User object when signed in
  const [loading, setLoading] = useState(true); // Indicates if the initial authentication state check is ongoing
  const [error, setError] = useState(null); // Stores any authentication-related errors

  /**
   * Effect hook to listen for changes in Firebase Authentication state.
   * This runs once on component mount and cleans up the listener on unmount.
   */
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        // User is signed in. Set the user state.
        setUser(firebaseUser);
        console.log("Firebase Auth State Changed: User signed in:", firebaseUser.uid);

        // Ensure a user document exists in Firestore for this user's UID.
        const userDocRef = doc(db, 'users', firebaseUser.uid);
        try {
          await setDoc(userDocRef, {
            email: firebaseUser.email,
            createdAt: firebaseUser.metadata?.creationTime,
            lastSignInTime: firebaseUser.metadata?.lastSignInTime,
            displayName: firebaseUser.displayName || 'Anonymous User',
          }, { merge: true });
          console.log("User profile ensured in Firestore for:", firebaseUser.uid);
        } catch (firestoreError) {
          console.error("Error ensuring user profile in Firestore:", firestoreError);
        }

      } else {
        // User is signed out (or initially not signed in). Clear the user state.
        setUser(null);
        console.log("Firebase Auth State Changed: User signed out.");
      }
      setLoading(false); // Authentication state check is complete, set loading to false.
    }, (authError) => {
      // Error occurred during authentication state change observation.
      console.error("Firebase Auth Listener Error:", authError);
      setError(authError); // Set error state
      setLoading(false); // Auth check is complete
    });

    // Cleanup function: Unsubscribe from the auth state listener when the component unmounts.
    return () => unsubscribe();
  }, []);

  /**
   * Registers a new user with email and password.
   * @param {string} email - The user's email address.
   * @param {string} password - The user's password.
   * @returns {Promise<import('firebase/auth').User>} A promise that resolves with the Firebase User object.
   * @throws {Error} Throws a Firebase Auth error if registration fails.
   */
  const register = async (email, password) => {
    setLoading(true);
    setError(null);
    try {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      console.log("User registered:", userCredential.user.uid);
      return userCredential.user;
    } catch (authError) {
      console.error("Registration error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  /**
   * Logs in an existing user with email and password.
   * @param {string} email - The user's email address.
   * @param {string} password - The user's password.
   * @returns {Promise<import('firebase/auth').User>} A promise that resolves with the Firebase User object.
   * @throws {Error} Throws a Firebase Auth error if login fails.
   */
  const login = async (email, password) => {
    setLoading(true);
    setError(null);
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      console.log("User logged in:", userCredential.user.uid);
      return userCredential.user;
    } catch (authError) {
      console.error("Login error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  /**
   * Logs in a user using Google authentication.
   * @returns {Promise<import('firebase/auth').User>} A promise that resolves with the Firebase User object.
   * @throws {Error} Throws a Firebase Auth error if login fails.
   */
  const loginWithGoogle = async () => {
    setLoading(true);
    setError(null);
    try {
      const provider = new GoogleAuthProvider();
      const userCredential = await signInWithPopup(auth, provider);
      console.log("User logged in with Google:", userCredential.user.uid);
      return userCredential.user;
    } catch (authError) {
      console.error("Google login error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  /**
   * Sends a password reset email to the specified email address.
   * @param {string} email - The user's email address.
   * @returns {Promise<void>} A promise that resolves when the email is sent.
   * @throws {Error} Throws a Firebase Auth error if sending fails.
   */
  const resetPassword = async (email) => {
    setLoading(true);
    setError(null);
    try {
      await sendPasswordResetEmail(auth, email);
      console.log("Password reset email sent to:", email);
    } catch (authError) {
      console.error("Password reset error:", authError);
      setError(authError);
      throw authError;
    } finally {
      setLoading(false);
    }
  };


  /**
   * Logs out the current user.
   * @returns {Promise<void>} A promise that resolves when the user is signed out.
   * @throws {Error} Throws a Firebase Auth error if logout fails.
   */
  const logout = async () => {
    setLoading(true);
    setError(null);
    try {
      await signOut(auth);
      console.log("User logged out.");
    } catch (authError) {
      console.error("Logout error:", authError);
      setError(authError);
      setLoading(false);
      throw authError;
    }
  };

  // Return the user, loading state, error, and authentication functions for consumption by components.
  return { user, loading, error, register, login, loginWithGoogle, resetPassword, logout };
};

--- END FILE: src\hooks\useAuth.js ---

--- START FILE: src\hooks\useTournaments.js ---

import { useState, useEffect } from 'react';
import { collection, addDoc, onSnapshot, query, orderBy, where, serverTimestamp } from 'firebase/firestore';
import { db, auth } from '../firebase'; // Import auth from firebase.js

export const useTournaments = () => {
  const [tournaments, setTournaments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [userId, setUserId] = useState(null); // State to store the current user's ID

  // Listen for Firebase Auth state changes to get the user ID
  useEffect(() => {
    const unsubscribeAuth = auth.onAuthStateChanged(user => {
      if (user) {
        setUserId(user.uid);
      } else {
        setUserId(null); // Clear userId if user logs out
        setTournaments([]); // Clear tournaments if no user
        setLoading(false); // Stop loading if no user to fetch for
      }
    });
    return () => unsubscribeAuth();
  }, []); // Empty dependency array: runs once on mount, cleans up on unmount

  // Real-time listener for tournaments, now filtered by userId
  useEffect(() => {
    if (!userId) { // Only fetch if a userId is available
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Query tournaments where 'userId' field matches the current user's UID
      const tournamentsCollectionRef = collection(db, 'tournaments');
      const q = query(
        tournamentsCollectionRef,
        where('userId', '==', userId), // Filter by the current user's ID
        orderBy('createdAt', 'desc')
      );

      const unsubscribe = onSnapshot(q, (snapshot) => {
        const list = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setTournaments(list);
        setLoading(false);
      }, (err) => {
        console.error('Error fetching real-time tournaments for user:', userId, err);
        setError('Failed to load your tournaments. Please try again.');
        setLoading(false);
      });

      return () => unsubscribe(); // Clean up the listener
    } catch (err) {
      console.error("Error setting up tournaments listener:", err);
      setError("Failed to set up tournaments listener.");
      setLoading(false);
    }
  }, [userId]); // Re-run effect when userId changes

  // Function to create a new tournament, now requiring userId
  const createTournament = async (tournamentData) => {
    if (!userId) {
      // It's good to provide a more specific error or handle this in the UI
      console.error('Attempted to create tournament without authenticated user.');
      throw new Error('Authentication required to create a tournament.');
    }
    try {
      const docRef = await addDoc(collection(db, 'tournaments'), {
        ...tournamentData,
        userId: userId, // Associate tournament with the creator's ID
        createdAt: serverTimestamp(), // Use server timestamp for consistency
      });
      console.log("New tournament created with ID:", docRef.id);
      return docRef.id;
    } catch (err) {
      console.error('Error creating tournament:', err);
      throw new Error('Failed to create tournament.'); // Re-throw a generic error for the calling component
    }
  };

  return { tournaments, loading, error, createTournament };
};


--- END FILE: src\hooks\useTournaments.js ---

--- START FILE: src\pages\AIPredictionPage.jsx ---

// üìÅ src/pages/AIPredictionPage.jsx
import React, { useEffect, useState } from 'react';
import { db } from '../firebase';
import { collection, getDocs, doc, getDoc } from 'firebase/firestore';
import { useParams } from 'react-router-dom';

export default function AIPredictionPage() {
  const { id: tournamentId } = useParams();
  const [fixtures, setFixtures] = useState([]);
  const [selectedMatch, setSelectedMatch] = useState(null);
  const [result, setResult] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isPredicting, setIsPredicting] = useState(false); // State for prediction loading

  useEffect(() => {
    const fetchFixtures = async () => {
      setLoading(true);
      setError(null);
      try {
        if (!tournamentId) {
          setError("Tournament ID is missing.");
          setLoading(false);
          return;
        }
        const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
        const snapshot = await getDocs(fixturesCollectionRef);
        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setFixtures(data);
      } catch (err) {
        console.error('Error fetching fixtures:', err);
        setError('Failed to load fixtures. Please try again.');
      } finally {
        setLoading(false);
      }
    };
    fetchFixtures();
  }, [tournamentId]);

  const handlePredict = async () => {
    if (!selectedMatch) {
      setResult('Please select a match before predicting.');
      return;
    }

    setIsPredicting(true);
    setResult(null); // Clear previous results

    try {
      // IMPORTANT SECURITY NOTE:
      // NEVER expose your API_KEY directly in client-side code in a production application.
      // This is for demonstration purposes only.
      // In a real application, you should proxy this request through a secure backend server
      // (e.g., Firebase Cloud Functions, a Node.js/Express server, etc.)
      // where your API_KEY can be securely stored and used server-side.
      //
      // For Canvas environment, __api_key is automatically provided if you use gemini-2.0-flash or imagen-3.0-generate-002
      // For other models or if running outside Canvas, uncomment the line below and ensure you have an API key.
      const apiKey = "" // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.

      // Validate API Key presence only if not running in Canvas or for other models
      // In Canvas, __api_key is automatically injected, so this check might be overly strict for that environment.
      // If you are running locally and not setting REACT_APP_GEMINI_API_KEY, you might need to manually put your key here.
      if (!apiKey && typeof __api_key === 'undefined') { // Check if apiKey is empty AND not in Canvas environment
        setResult("API Key is not configured. For local development, set REACT_APP_GEMINI_API_KEY in your .env file or hardcode it (temporarily). In Canvas, it's auto-provided for allowed models.");
        setIsPredicting(false);
        return;
      }

      const prompt = `Predict the winner of the match between ${selectedMatch.teamA} and ${selectedMatch.teamB} for a football/soccer tournament. Consider general team strengths and provide a brief, concise reason for the prediction. Do not include probabilities or scores.`;
      const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
      const payload = { contents: chatHistory };
      
      // Use gemini-2.0-flash as the default for text generation unless specified by the user
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`; 

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        const errorBody = await response.json();
        console.error('API call failed:', response.status, response.statusText, errorBody);
        setResult(`Failed to get prediction: ${errorBody.error?.message || 'Unknown error'}. Check API key and quota.`);
        return;
      }

      const resultData = await response.json();

      if (resultData.candidates && resultData.candidates.length > 0 &&
          resultData.candidates[0].content && resultData.candidates[0].content.parts &&
          resultData.candidates[0].content.parts.length > 0) {
        const text = resultData.candidates[0].content.parts[0].text;
        setResult(text);
      } else {
        setResult('Could not get a prediction at this time. The AI returned an unexpected response structure.');
      }
    } catch (apiError) {
      console.error('Error calling generative AI API:', apiError);
      setResult(`Error getting prediction from AI: ${apiError.message}. Please try again later.`);
    } finally {
      setIsPredicting(false);
    }
  };

  return (
    <div className="p-6 bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
      <h2 className="text-3xl font-extrabold mb-6 text-center">ü§ñ AI Match Prediction</h2>
      <p className="text-lg text-center mb-8">Select a match to get an AI-powered prediction for the winner.</p>

      {loading ? (
        <p className="text-gray-500 text-center py-4">Loading matches...</p>
      ) : error ? (
        <p className="text-red-500 text-center py-4">{error}</p>
      ) : fixtures.length === 0 ? (
        <p className="text-gray-500 text-center py-4">No matches available for this tournament yet.</p>
      ) : (
        <div className="max-w-md mx-auto bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl space-y-6">
          {/* Match selection dropdown */}
          <div className="flex flex-col">
            <label htmlFor="match-select" className="mb-2 font-medium text-gray-700 dark:text-gray-300">Choose a Match:</label>
            <select
              id="match-select"
              onChange={(e) => {
                const match = fixtures.find(f => f.id === e.target.value);
                setSelectedMatch(match);
                setResult(null); // Clear result when a new match is selected
              }}
              value={selectedMatch?.id || ''}
              className="px-4 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isPredicting} // Disable dropdown during prediction
            >
              <option value="">-- Select a match --</option>
              {fixtures.map(f => (
                <option key={f.id} value={f.id}>
                  {f.teamA} vs {f.teamB} {f.status === 'completed' && ` (Final: ${f.scoreA}-${f.scoreB})`}
                </option>
              ))}
            </select>
          </div>

          {/* Predict button */}
          <button
            onClick={handlePredict}
            className={`w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition-colors text-lg
                        ${!selectedMatch || isPredicting ? 'opacity-50 cursor-not-allowed' : 'hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75'
                      }`}
            disabled={!selectedMatch || isPredicting}
          >
            {isPredicting ? (
              <div className="flex items-center justify-center">
                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Predicting...
              </div>
            ) : (
              'Predict Winner'
            )}
          </button>

          {/* Prediction result display */}
          {result && (
            <div className={`mt-4 p-4 rounded-lg ${result.includes('Error') || result.includes('invalid') || result.includes('not configured') ? 'bg-red-100 dark:bg-red-800 text-red-800 dark:text-red-200' : 'bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200'}`}>
              <p className="font-semibold text-xl mb-2">Prediction:</p>
              <p className="text-lg">{result}</p>
            </div>
          )}
        </div>
      )}
    </div>
  );
}


--- END FILE: src\pages\AIPredictionPage.jsx ---

--- START FILE: src\pages\AuthPage.jsx ---

import React, { useState, useEffect } from 'react';
import { useAuth } from '../hooks/useAuth';
import { FaEye, FaEyeSlash, FaGoogle } from 'react-icons/fa'; // Import icons
import { getPasswordStrength, getStrengthColor } from '../utils/passwordStrength'; // We'll create this utility

export default function AuthPage() {
  const { login, register, loginWithGoogle, resetPassword, loading, error } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isRegisterMode, setIsRegisterMode] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');
  const [successMessage, setSuccessMessage] = useState(''); // New state for success messages
  const [showPassword, setShowPassword] = useState(false); // State for password visibility
  const [passwordStrength, setPasswordStrength] = useState(0); // State for password strength (0-4)

  // Effect to listen to the global error from useAuth and display it
  useEffect(() => {
    if (error) {
      let friendlyError = 'An unexpected error occurred.';
      switch (error.code) {
        case 'auth/invalid-email':
          friendlyError = 'Invalid email address format.';
          break;
        case 'auth/user-disabled':
          friendlyError = 'This account has been disabled.';
          break;
        case 'auth/user-not-found':
        case 'auth/wrong-password':
          friendlyError = 'Invalid email or password.';
          break;
        case 'auth/email-already-in-use':
          friendlyError = 'This email is already registered. Try logging in.';
          break;
        case 'auth/weak-password':
          friendlyError = 'Password is too weak. It should be at least 6 characters.';
          break;
        case 'auth/network-request-failed':
          friendlyError = 'Network error. Please check your internet connection.';
          break;
        case 'auth/popup-closed-by-user': // For social login
          friendlyError = 'Login window closed. Please try again.';
          break;
        case 'auth/cancelled-popup-request': // For social login
          friendlyError = 'Another login attempt is in progress. Please wait or try again.';
          break;
        default:
          friendlyError = error.message;
      }
      setErrorMessage(friendlyError);
      setSuccessMessage(''); // Clear any success messages
    } else if (!loading) { // Clear errors when auth state is stable and no error
      setErrorMessage('');
    }
  }, [error, loading]);

  // Handle password change for strength indicator
  useEffect(() => {
    if (isRegisterMode) {
      setPasswordStrength(getPasswordStrength(password));
    } else {
      setPasswordStrength(0); // Reset strength when not in register mode
    }
  }, [password, isRegisterMode]);


  const handleSubmit = async (e) => {
    e.preventDefault();
    setErrorMessage('');
    setSuccessMessage('');

    try {
      if (isRegisterMode) {
        await register(email, password);
        setSuccessMessage('Registration successful! Please log in.');
        setIsRegisterMode(false); // Switch to login mode after successful registration
        setEmail(''); // Clear form fields
        setPassword('');
      } else {
        await login(email, password);
        // On successful login, useAuth hook's listener will update user state in App.jsx,
        // triggering navigation.
      }
    } catch (err) {
      // Error handled by useEffect listening to 'error' from useAuth
      console.error("Auth operation failed in AuthPage:", err);
    }
  };

  const handleGoogleLogin = async () => {
    setErrorMessage('');
    setSuccessMessage('');
    try {
      await loginWithGoogle();
      // On successful login, useAuth hook's listener will update user state in App.jsx,
      // triggering navigation.
    } catch (err) {
      // Error handled by useEffect listening to 'error' from useAuth
      console.error("Google login failed:", err);
    }
  };

  const handleForgotPassword = async () => {
    setErrorMessage('');
    setSuccessMessage('');
    if (!email) {
      setErrorMessage('Please enter your email to reset password.');
      return;
    }
    try {
      await resetPassword(email);
      setSuccessMessage('Password reset email sent! Check your inbox (and spam folder).');
      setEmail('');
    } catch (err) {
      console.error("Forgot password failed:", err);
      // Error handled by useEffect listening to 'error' from useAuth
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 px-4 py-8 relative overflow-hidden">
      {/* Background overlay for subtle texture/gradient matching the app's dark theme */}
      <div className="absolute inset-0 bg-gradient-to-br from-red-800 to-gray-900 opacity-20"></div>
      <div className="absolute inset-0 bg-pattern-dots opacity-5"></div> {/* Optional subtle pattern */}

      <div className="relative z-10 bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-md border border-red-700 backdrop-blur-sm bg-opacity-90 transition-all duration-300 hover:shadow-red-500/20">
        <div className="flex justify-center mb-6">
          {/* You can replace this with your actual logo component or image */}
          <img src="/logo.png" alt="Tournament Manager Logo" className="h-20 w-auto" onError={(e) => e.target.style.display = 'none'} />
          {/* Fallback text if image doesn't load or no logo is provided */}
          <h1 className="text-4xl font-extrabold text-red-500 hidden" style={{ display: 'none' }}>LTC</h1>
        </div>
        <h2 className="text-3xl font-extrabold mb-8 text-center text-white">
          {isRegisterMode ? 'üìù Create Account' : 'üîê Welcome Back!'}
        </h2>

        {/* Dynamic Message Area */}
        {errorMessage && (
          <div className="bg-red-900 text-red-200 p-3 rounded-md mb-4 text-center text-sm animate-fade-in-down border border-red-700">
            {errorMessage}
          </div>
        )}
        {successMessage && (
          <div className="bg-green-700 text-green-100 p-3 rounded-md mb-4 text-center text-sm animate-fade-in-down border border-green-500">
            {successMessage}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label htmlFor="email-address" className="sr-only">Email address</label>
            <input
              id="email-address"
              name="email"
              type="email"
              autoComplete="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Email address"
              className="w-full px-5 py-3 border border-gray-600 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-200"
              required
            />
          </div>
          <div className="mb-4 relative">
            <label htmlFor="password" className="sr-only">Password</label>
            <input
              id="password"
              name="password"
              type={showPassword ? 'text' : 'password'}
              autoComplete={isRegisterMode ? 'new-password' : 'current-password'}
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Password"
              className="w-full px-5 py-3 border border-gray-600 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-200 pr-12"
              required
            />
            <button
              type="button"
              onClick={() => setShowPassword(!showPassword)}
              className="absolute inset-y-0 right-0 pr-4 flex items-center text-gray-400 hover:text-white focus:outline-none transition-colors duration-200"
              aria-label={showPassword ? 'Hide password' : 'Show password'}
            >
              {showPassword ? <FaEyeSlash /> : <FaEye />}
            </button>
          </div>

          {isRegisterMode && password && (
            <div className="mb-4">
              <div className="text-sm font-medium text-gray-300 mb-1">
                Password Strength: <span className={`${getStrengthColor(passwordStrength)}`}>
                  {passwordStrength === 0 ? 'Too Short' : passwordStrength === 1 ? 'Weak' : passwordStrength === 2 ? 'Moderate' : passwordStrength === 3 ? 'Good' : 'Strong'}
                </span>
              </div>
              <div className="w-full bg-gray-600 rounded-full h-2">
                <div
                  className={`h-2 rounded-full transition-all duration-300`}
                  style={{
                    width: `${(passwordStrength / 4) * 100}%`,
                    backgroundColor: getStrengthColor(passwordStrength).replace('text-', 'bg-') // Map text color to background color
                  }}
                ></div>
              </div>
              <p className="text-xs text-gray-400 mt-1">
                {passwordStrength < 3 && 'Use 8+ characters, mixed case, numbers, and symbols for a stronger password.'}
              </p>
            </div>
          )}

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-red-600 text-white px-5 py-3 rounded-lg font-semibold text-lg hover:bg-red-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 active:scale-95"
          >
            {loading ? (isRegisterMode ? 'Registering...' : 'Logging In...') : isRegisterMode ? 'Register Account' : 'Login'}
          </button>
        </form>

        <div className="relative flex items-center justify-center my-6">
          <div className="flex-grow border-t border-gray-600"></div>
          <span className="flex-shrink mx-4 text-gray-500 text-sm">OR</span>
          <div className="flex-grow border-t border-gray-600"></div>
        </div>

        {/* Google Login Button */}
        <button
          onClick={handleGoogleLogin}
          disabled={loading}
          className="w-full flex items-center justify-center bg-gray-700 text-white px-5 py-3 rounded-lg font-semibold text-lg hover:bg-gray-600 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 active:scale-95"
        >
          <FaGoogle className="mr-3 text-xl" />
          {loading ? 'Signing In...' : 'Sign in with Google'}
        </button>

        <div className="flex justify-between items-center mt-6">
          <button
            onClick={() => setIsRegisterMode(!isRegisterMode)}
            className="text-red-400 hover:text-red-300 hover:underline text-sm transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 rounded-md p-1"
          >
            {isRegisterMode ? 'Already have an account? Login' : 'Need an account? Register'}
          </button>
          <button
            onClick={handleForgotPassword}
            className="text-gray-400 hover:text-gray-300 hover:underline text-sm transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500 rounded-md p-1"
          >
            Forgot Password?
          </button>
        </div>
      </div>
    </div>
  );
}

--- END FILE: src\pages\AuthPage.jsx ---

--- START FILE: src\pages\Dashboard.jsx ---

import React, { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useTournaments } from '../hooks/useTournaments'; // Import useTournaments from the hook
import { db } from '../firebase'; // Import db
import { doc, deleteDoc, collection, getDocs } from 'firebase/firestore'; // Import necessary Firestore functions
// Assuming you have a Modal component in components/Modal.jsx
// If you don't use the shared Modal component here, it's okay, but consistency is good practice.
// import Modal from '../components/Modal'; // Uncomment if you want to use the shared Modal

export default function Dashboard() {
  const { tournaments, loading, error, createTournament } = useTournaments(); // Get createTournament from hook
  const [showForm, setShowForm] = useState(false);
  // States for new tournament form details
  const [name, setName] = useState('');
  const [leagueType, setLeagueType] = useState('League'); // 'League' or 'Groups'
  const [teamsPerGroup, setTeamsPerGroup] = useState('');
  const [numGroups, setNumGroups] = useState('');
  const [fixtureOption, setFixtureOption] = useState('Home and Away Matches'); // 'Home and Away Matches' or 'Single Matches'
  const [pointsPerWin, setPointsPerWin] = useState(3);
  const [pointsPerDraw, setPointsPerDraw] = useState(1);

  const [createError, setCreateError] = useState(null); // State for create tournament errors
  const navigate = useNavigate();

  // Custom Modal Component states (inline, for this Dashboard component only)
  // These states and logic are for the modal defined directly within this file,
  // not the reusable Modal component imported from '../components/Modal'.
  const [modalOpen, setModalOpen] = useState(false);
  const [modalMessage, setModalMessage] = useState('');
  const [modalConfirmAction, setModalConfirmAction] = useState(null);
  const [modalInputRequired, setModalInputRequired] = useState(false);
  const [modalInputLabel, setModalInputLabel] = useState('');
  const [modalInputValue, setModalInputValue] = useState(''); // Stores comma-separated values for multiple inputs
  const [modalCustomContent, setModalCustomContent] = useState(null);

  const openModal = (message, confirmAction = null, inputRequired = false, inputLabel = '', initialValue = '', customContent = null) => {
    setModalMessage(message);
    setModalConfirmAction(() => confirmAction); // Wrap in arrow function to prevent immediate execution
    setModalInputRequired(inputRequired);
    setModalInputLabel(inputLabel);
    setModalInputValue(initialValue);
    setModalCustomContent(customContent);
    setModalOpen(true);
  };

  const handleModalConfirm = () => {
    if (modalConfirmAction) {
      modalConfirmAction(modalInputValue); // Pass input value if required
    }
    setModalOpen(false);
    setModalInputValue('');
    setModalCustomContent(null);
    setModalConfirmAction(null); // Clear action after execution
  };

  const handleModalCancel = () => {
    setModalOpen(false);
    setModalInputValue('');
    setModalCustomContent(null);
    setModalConfirmAction(null); // Clear action
  };

  const handleDeleteTournament = async (tournamentToDeleteId, tournamentNameToDelete) => {
    openModal(
      `Are you sure you want to delete the league "${tournamentNameToDelete}"? This action cannot be undone and will delete all associated data (teams, fixtures, etc.).`,
      async () => {
        try {
          const tournamentDocRef = doc(db, 'tournaments', tournamentToDeleteId);

          // Delete subcollections first (teams, fixtures, leaderboard, players, match_stats)
          const subcollections = ['teams', 'fixtures', 'leaderboard', 'players', 'match_stats'];
          for (const subcollectionName of subcollections) {
            const subcollectionRef = collection(tournamentDocRef, subcollectionName);
            const subcollectionSnapshot = await getDocs(subcollectionRef);
            const deletePromises = subcollectionSnapshot.docs.map(subDoc => deleteDoc(subDoc.ref));
            await Promise.all(deletePromises);
            console.log(`Deleted all documents in subcollection: tournaments/${tournamentToDeleteId}/${subcollectionName}`);
          }

          // Finally, delete the main tournament document
          await deleteDoc(tournamentDocRef);
          openModal(`League "${tournamentNameToDelete}" deleted successfully.`, null);
        } catch (err) {
          console.error('Error deleting tournament and its subcollections:', err);
          openModal(`Failed to delete league "${tournamentNameToDelete}". Please try again.`, null);
        }
      }
    );
  };


  const handleCreate = async () => {
    // Basic validation for required fields
    if (!name.trim()) {
      setCreateError('League name cannot be empty.');
      return;
    }
    if (leagueType === 'Groups' && (!teamsPerGroup || !numGroups)) {
      setCreateError('Please specify teams per group and number of groups.');
      return;
    }

    setCreateError(null); // Clear previous errors
    try {
      const tournamentData = {
        name,
        type: leagueType, // Use leagueType for the tournament type
        fixtureOption,
        pointsPerWin,
        pointsPerDraw,
      };

      if (leagueType === 'Groups') {
        tournamentData.teamsPerGroup = parseInt(teamsPerGroup);
        tournamentData.numGroups = parseInt(numGroups);
      }

      const id = await createTournament(tournamentData); // Use createTournament from useTournaments hook
      if (id) {
        navigate(`/tournament/${id}`); // Navigate to the newly created tournament
        // Reset form fields
        setName('');
        setLeagueType('League');
        setTeamsPerGroup('');
        setNumGroups('');
        setFixtureOption('Home and Away Matches');
        setPointsPerWin(3);
        setPointsPerDraw(1);
        setShowForm(false); // Hide form
      } else {
        setCreateError('Failed to create tournament. Please try again.');
      }
    } catch (err) {
      console.error('Dashboard: Error creating tournament:', err);
      setCreateError(err.message || 'An unexpected error occurred during tournament creation.');
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center p-6 bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Trophy Image (SVG for better scalability) */}
      <div className="mb-8">
        <svg
          width="150"
          height="150"
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
          className="text-yellow-500" // Gold-like color for the trophy
        >
          <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M17 2H7C6.44772 2 6 2.44772 6 3V17C6 17.5523 6.44772 18 7 18H17C17.5523 18 18 17.5523 18 17V3C18 2.44772 17.5523 2 17 2ZM7 4H17V16H7V4ZM12 18C12.5523 18 13 18.4477 13 19C13 19.5523 12.5523 20 12 20C11.4477 20 11 19.5523 11 19C11 18.4477 11.4477 18 12 18ZM20 13H22V15H20V13ZM4 13H2V15H4V13ZM12 22C12.5523 22 13 22.4477 13 23C13 23.5523 12.5523 24 12 24C11.4477 24 11 23.5523 11 23C11 22.4477 11.4477 22 12 22ZM12 20.5C12.2761 20.5 12.5 20.7239 12.5 21C12.5 21.2761 12.2761 21.5 12 21.5C11.7239 21.5 11.5 21.2761 11.5 21C11.5 20.7239 11.7239 20.5 12 20.5ZM12 17C12.5523 17 13 17.4477 13 18C13 18.5523 12.5523 19 12 19C11.4477 19 11 18.5523 11 18C11 17.4477 11.4477 17 12 17ZM17 4H7V16H7V4ZM10.5 2L13.5 2L13.5 4L10.5 4L10.5 2ZM19 18H5V20H19V18Z"
            fill="currentColor"
          />
          {/* Text "LTC" inside the trophy */}
          <text
            x="50%"
            y="50%"
            dominantBaseline="middle"
            textAnchor="middle"
            fontSize="5"
            fontWeight="bold"
            fill="#8B4513" // Brownish color for the text
          >
            LTC
          </text>
        </svg>
      </div>

      <h2 className="text-4xl font-extrabold mb-10 text-center">Tournament Manager</h2>

      {/* Action buttons */}
      <div className="flex flex-col gap-4 mb-8 w-full max-w-xs">
        {/* CREATE LEAGUE Button */}
        <button
          onClick={() => setShowForm(!showForm)}
          className="bg-red-600 text-white font-bold py-3 px-6 rounded-md shadow-lg hover:bg-red-700 transition-colors duration-200 uppercase tracking-wide transform hover:scale-105"
        >
          {showForm ? 'Hide Form' : 'Create League'}
        </button>

        {/* LOAD LEAGUE Button - Now hides the form if it's open, focusing on the list */}
        <button
          onClick={() => setShowForm(false)}
          className="bg-red-600 text-white font-bold py-3 px-6 rounded-md shadow-lg hover:bg-red-700 transition-colors duration-200 uppercase tracking-wide transform hover:scale-105"
        >
          Load League
        </button>
      </div>

      {/* New Tournament Creation Form */}
      {showForm && (
        <div className="mb-8 bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md border border-gray-200 dark:border-gray-700">
          <h3 className="text-xl font-semibold mb-4 text-center">Create New League</h3>
          <div className="flex flex-col gap-4">
            {/* League Name Input */}
            <input
              type="text"
              placeholder="Enter a name for your League"
              value={name}
              onChange={e => setName(e.target.value)}
              className="px-4 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />

            {/* League Type Radio Buttons */}
            <div className="flex items-center gap-4 mt-2">
              <label className="flex items-center">
                <input
                  type="radio"
                  value="League"
                  checked={leagueType === 'League'}
                  onChange={() => setLeagueType('League')}
                  className="mr-2"
                />
                League
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  value="Groups"
                  checked={leagueType === 'Groups'}
                  onChange={() => setLeagueType('Groups')}
                  className="mr-2"
                />
                Groups
              </label>
            </div>

            {/* Conditional Group Fields */}
            {leagueType === 'Groups' && (
              <div className="flex flex-col gap-3 mt-2">
                <input
                  type="number"
                  placeholder="Teams Per Group"
                  value={teamsPerGroup}
                  onChange={e => setTeamsPerGroup(e.target.value)}
                  className="px-4 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  min="1"
                />
                <input
                  type="number"
                  placeholder="Number of Groups"
                  value={numGroups}
                  onChange={e => setNumGroups(e.target.value)}
                  className="px-4 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  min="1"
                />
              </div>
            )}

            {/* Fixture Options Radio Buttons */}
            <h4 className="font-semibold mt-4 mb-2 text-gray-700 dark:text-gray-300">Fixture Options:</h4>
            <div className="flex flex-col gap-2">
              <label className="flex items-center">
                <input
                  type="radio"
                  value="Home and Away Matches"
                  checked={fixtureOption === 'Home and Away Matches'}
                  onChange={() => setFixtureOption('Home and Away Matches')}
                  className="mr-2"
                />
                Home and Away Matches
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  value="Single Matches"
                  checked={fixtureOption === 'Single Matches'}
                  onChange={() => setFixtureOption('Single Matches')}
                  className="mr-2"
                />
                Single Matches
              </label>
            </div>

            {/* Points Inputs */}
            <h4 className="font-semibold mt-4 mb-2 text-gray-700 dark:text-gray-300">Points:</h4>
            <div className="flex flex-col gap-3">
              <div className="flex items-center gap-2">
                <label className="w-28">Points per Win:</label>
                <input
                  type="number"
                  value={pointsPerWin}
                  onChange={e => setPointsPerWin(parseInt(e.target.value) || 0)} // Added || 0 for safer parsing
                  className="px-4 py-2 border rounded-md w-20 text-center dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  min="0"
                />
              </div>
              <div className="flex items-center gap-2">
                <label className="w-28">Points per Draw:</label>
                <input
                  type="number"
                  value={pointsPerDraw}
                  onChange={e => setPointsPerDraw(parseInt(e.target.value) || 0)} // Added || 0 for safer parsing
                  className="px-4 py-2 border rounded-md w-20 text-center dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  min="0"
                />
              </div>
            </div>

            {/* CONTINUE Button */}
            <button
              onClick={handleCreate}
              className="bg-red-600 text-white font-bold py-3 px-6 rounded-md shadow-lg hover:bg-red-700 transition-colors duration-200 uppercase tracking-wide transform hover:scale-105 mt-4"
            >
              Continue
            </button>
          </div>
          {createError && <p className="text-red-500 text-sm mt-3 text-center">{createError}</p>}
        </div>
      )}

      {/* Displaying Tournaments Section (Now always visible below action buttons/form) */}
      <div className="w-full max-w-4xl">
        <h3 className="text-xl font-bold mb-4 text-center mt-8">My Tournaments</h3>
        {loading ? (
          <p className="text-gray-500 text-center">Loading tournaments...</p>
        ) : error ? (
          <p className="text-red-500 text-center">Error loading tournaments: {error}</p>
        ) : tournaments.length === 0 ? (
          <p className="text-gray-500 text-center">No tournaments found yet. Create one!</p>
        ) : (
          <ul className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {tournaments.map(t => (
              <li
                key={t.id}
                className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border border-gray-200 dark:border-gray-700 flex flex-col justify-between items-center text-center transition-transform transform hover:scale-[1.02]"
              >
                <h4 className="font-semibold text-lg mb-1">{t.name}</h4>
                <p className="text-sm text-gray-500 dark:text-gray-400 mb-2">{t.type}</p>
                {t.createdAt && t.createdAt.seconds && (
                  <p className="text-xs text-gray-400 dark:text-gray-500 mb-3">
                    Created on: {new Date(t.createdAt.seconds * 1000).toLocaleDateString()}
                  </p>
                )}
                <div className="flex gap-2 mt-2"> {/* Container for buttons */}
                    <Link
                      to={`/tournament/${t.id}`}
                      className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors duration-200 text-sm"
                    >
                      Open Tournament
                    </Link>
                    <button
                      onClick={(e) => {
                        e.stopPropagation(); // Prevent Link from triggering
                        handleDeleteTournament(t.id, t.name);
                      }}
                      className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600 transition-colors duration-200 text-sm"
                    >
                      Delete
                    </button>
                </div>
              </li>
            ))}
          </ul>
        )}
      </div>

      {/* Custom Modal Component (Inline implementation for Dashboard's specific needs) */}
      {modalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm text-center">
            {/* Conditional rendering for custom content or default message/input */}
            {modalCustomContent || (
              <>
                <p className="text-lg font-semibold mb-4">{modalMessage}</p>
                {modalInputRequired && (
                  <div className="flex flex-col gap-2 mb-4">
                    {/* Maps over labels to create multiple inputs if needed.
                        The value and onChange logic handles them as a comma-separated string. */}
                    {modalInputLabel.split(',').map((label, index) => (
                      <input
                        key={index} // Important for React list rendering
                        type="text" // Can be changed to "number" if input is strictly numeric
                        placeholder={label.trim()}
                        // This value logic is for handling multiple inputs with a single state string
                        value={modalInputValue.split(',')[index] || ''}
                        onChange={(e) => {
                          const newValues = modalInputValue.split(',');
                          newValues[index] = e.target.value;
                          setModalInputValue(newValues.join(','));
                        }}
                        className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                    ))}
                  </div>
                )}
              </>
            )}
            <div className="flex justify-center gap-4 mt-4">
              {modalConfirmAction && (
                <button
                  onClick={handleModalConfirm}
                  className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors"
                >
                  Confirm
                </button>
              )}
              <button
                onClick={handleModalCancel}
                className="bg-gray-400 text-white px-4 py-2 rounded-md hover:bg-gray-500 transition-colors"
              >
                {modalConfirmAction ? 'Cancel' : 'Close'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}


--- END FILE: src\pages\Dashboard.jsx ---

--- START FILE: src\pages\FixturesPage.jsx ---

import React, { useEffect, useState, useCallback, useRef } from 'react';
import { db } from '../firebase';
import { collection, onSnapshot, query, orderBy, doc, updateDoc, getDoc } from 'firebase/firestore';
import { Link, useParams } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';
import Modal from '../components/Modal'; // Assuming you have this Modal component
import ScoreInputModalContent from '../components/ScoreInputModalContent'; // Import the new component

// --- MODIFICATION: Accept readOnly prop ---
export default function FixturesPage({ readOnly = false }) { // Default to false
    const { id: tournamentId } = useParams();
    const { user, loading: authLoading } = useAuth();
    const [fixtures, setFixtures] = useState([]);
    const [loadingFixtures, setLoadingFixtures] = useState(true);
    const [error, setError] = useState(null);
    const [tournamentName, setTournamentName] = useState('Loading...');

    // Modal State for the shared Modal component
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [modalTitle, setModalTitle] = useState('');
    const [modalMessage, setModalMessage] = useState('');
    const [modalContent, setModalContent] = useState(null); // For custom content (e.g., input fields)
    const [modalConfirmAction, setModalConfirmAction] = useState(null);
    const [modalShowConfirmButton, setModalShowConfirmButton] = useState(true);

    // REF to access the ScoreInputModalContent component's methods (like getScoreA/B)
    const scoreInputRef = useRef(null);

    // Helper function to open the custom modal
    const openCustomModal = useCallback((title, message, confirmAction = null, showConfirm = true, content = null) => {
        setModalTitle(title);
        setModalMessage(message);
        setModalConfirmAction(() => confirmAction); // Store the function directly
        setModalShowConfirmButton(showConfirm);
        setModalContent(content);
        setIsModalOpen(true);
    }, []);

    const closeCustomModal = useCallback(() => {
        setIsModalOpen(false);
        setModalTitle('');
        setModalMessage('');
        setModalContent(null);
        setModalConfirmAction(null);
        setModalShowConfirmButton(true);
    }, []);

    useEffect(() => {
        // --- MODIFICATION: Skip auth check if in readOnly mode ---
        if (!readOnly && authLoading) {
            setLoadingFixtures(true);
            return;
        }

        // --- MODIFICATION: Skip auth check if in readOnly mode ---
        if (!readOnly && (!user || !user.uid)) {
            setError("You must be logged in to view fixtures.");
            setLoadingFixtures(false);
            return;
        }

        if (!tournamentId) {
            setError("No tournament ID provided in the URL.");
            setLoadingFixtures(false);
            return;
        }

        const fetchTournamentDetails = async () => {
            try {
                const tournamentDocRef = doc(db, 'tournaments', tournamentId);
                const tournamentSnap = await getDoc(tournamentDocRef);
                if (tournamentSnap.exists()) {
                    const data = tournamentSnap.data();
                    // --- MODIFICATION: Only check userId if not in readOnly mode ---
                    // Allow read if readOnly is true, OR if user is authenticated and is the owner
                    if (readOnly || (user?.uid && data.userId === user.uid)) {
                        setTournamentName(data.name);
                    } else {
                        setTournamentName('Access Denied');
                        setError('You do not have permission to access this tournament.');
                    }
                } else {
                    setTournamentName('Tournament Not Found');
                    setError('The requested tournament does not exist.');
                }
            } catch (err) {
                console.error('Error fetching tournament details:', err);
                setTournamentName('Error');
                setError('Failed to load tournament details. Please try again.');
            } finally {
                setLoadingFixtures(false); // Ensure loading state is false after attempt
            }
        };
        fetchTournamentDetails();

        // --- MODIFICATION: Skip auth check for real-time fixtures if in readOnly mode ---
        if ((!readOnly && (!user || !user.uid)) || error) {
            // If already an error or not authenticated in non-readOnly mode, don't subscribe
            return;
        }

        const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
        const q = query(fixturesCollectionRef, orderBy('timestamp', 'asc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            setFixtures(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoadingFixtures(false);
        }, (err) => {
            console.error('Error fetching real-time fixtures:', err);
            setError('Failed to load fixtures. Please try again.');
            setLoadingFixtures(false);
        });

        return () => unsubscribe();
    }, [tournamentId, user, authLoading, error, readOnly]); // Add readOnly to dependencies

    // handleUpdateScores now uses the ScoreInputModalContent component
    const handleUpdateScores = useCallback(async (fixtureId, currentScoreA, currentScoreB) => {
        // --- MODIFICATION: Prevent action if in readOnly mode ---
        if (readOnly) {
            openCustomModal('This action is not allowed in view-only mode.', null, null, false); // No confirm button
            return;
        }

        const fixtureToUpdate = fixtures.find(f => f.id === fixtureId);
        if (!fixtureToUpdate) {
            console.warn(`Fixture with ID ${fixtureId} not found.`);
            return;
        }

        // Define the confirmation logic that will run when the modal's Confirm button is clicked
        const confirmAction = async () => {
            // Ensure scoreInputRef.current exists before attempting to read
            if (!scoreInputRef.current) {
                console.error("scoreInputRef.current is null. ScoreInputModalContent might not be mounted or ref not attached.");
                openCustomModal('Error', 'Internal error: Cannot read scores. Please try again.', null, false);
                return;
            }

            const parsedScoreA = parseInt(scoreInputRef.current.getScoreA());
            const parsedScoreB = parseInt(scoreInputRef.current.getScoreB());

            if (isNaN(parsedScoreA) || isNaN(parsedScoreB)) {
                // Re-open modal with error message, don't close it, and retain input values
                openCustomModal('Invalid Input', 'Please enter valid numbers for scores.', null, true, ( // showConfirm = true for re-try
                    // Pass the current fixture and the *last known input values* from the ref
                    <ScoreInputModalContent
                        ref={scoreInputRef} // Re-attach ref for the new render of ScoreInputModalContent
                        fixture={fixtureToUpdate}
                        initialScoreA={scoreInputRef.current.getScoreA()}
                        initialScoreB={scoreInputRef.current.getScoreB()}
                    />
                ));
                return; // Important: Stop execution here if validation fails
            }

            try {
                const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, fixtureId);
                await updateDoc(fixtureRef, {
                    scoreA: parsedScoreA,
                    scoreB: parsedScoreB,
                    status: 'completed'
                });
                closeCustomModal(); // Close the score update modal on success
            } catch (err) {
                console.error('Error updating scores:', err);
                // Re-open modal with error, retain input values
                openCustomModal('Error', 'Failed to update scores. Please try again.', null, true, ( // showConfirm = true for re-try
                    // Pass the current fixture and the *last known input values* from the ref
                    <ScoreInputModalContent
                        ref={scoreInputRef} // Re-attach ref for the new render of ScoreInputModalContent
                        fixture={fixtureToUpdate}
                        initialScoreA={scoreInputRef.current.getScoreA()}
                        initialScoreB={scoreInputRef.current.getScoreB()}
                    />
                ));
            }
        };

        // Open the modal, passing ScoreInputModalContent as the 'content' prop
        openCustomModal(
            'Update Match Scores',
            `Enter scores for ${fixtureToUpdate.teamA} vs ${fixtureToUpdate.teamB}:`,
            confirmAction, // This is the logic to run on confirm
            true, // showConfirmButton
            // Pass the actual ScoreInputModalContent component as content, with a ref and initial scores
            <ScoreInputModalContent
                ref={scoreInputRef} // Attach ref here so parent can access its methods
                fixture={fixtureToUpdate} // Pass the full fixture object
                initialScoreA={currentScoreA}
                initialScoreB={currentScoreB}
            />
        );
    }, [fixtures, tournamentId, openCustomModal, closeCustomModal, readOnly]); // Add readOnly to dependencies

    // Group fixtures by week
    const groupedFixtures = fixtures.reduce((acc, fixture) => {
        let dateStr = '';
        // Ensure timestamp exists and is a Firestore Timestamp object
        if (fixture.timestamp && typeof fixture.timestamp.toDate === 'function') {
            dateStr = fixture.timestamp.toDate().toISOString().split('T')[0];
        } else if (fixture.date) {
            dateStr = new Date(fixture.date).toISOString().split('T')[0]; // Ensure date is parsed consistently
        }

        if (!acc[dateStr]) {
            acc[dateStr] = [];
        }
        acc[dateStr].push(fixture);
        return acc;
    }, {});

    // Sort dates to ensure weeks appear in order
    const sortedDates = Object.keys(groupedFixtures).sort((a, b) => new Date(a) - new Date(b));

    if (loadingFixtures || authLoading) {
        return (
            <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
                {/* --- MODIFICATION: Conditionally render/adjust nav links based on readOnly --- */}
                {!readOnly ? (
                    <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
                        <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
                        <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
                        <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">PLAYERS</Link>
                        <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
                        <Link to={`/tournament/${tournamentId}/top-scorers`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
                    </div>
                ) : (
                    <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
                        <Link to={`/share/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
                        <Link to={`/share/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
                        <Link to={`/share/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
                        {/* You might also have a public stats page, or remove this if not needed for public */}
                        {/* <Link to={`/share/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link> */}
                    </div>
                )}
                <div className="p-6 max-w-4xl mx-auto w-full">
                    <h2 className="text-2xl font-bold mb-4 text-center">üìÖ Tournament Fixtures ({tournamentName})</h2>
                    <p className="text-center text-gray-500 py-8">Loading fixtures...</p>
                </div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
                {/* --- MODIFICATION: Conditionally render/adjust nav links based on readOnly --- */}
                {!readOnly ? (
                    <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
                        <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
                        <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
                        <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">PLAYERS</Link>
                        <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
                        <Link to={`/tournament/${tournamentId}/top-scorers`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
                    </div>
                ) : (
                    <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
                        <Link to={`/share/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
                        <Link to={`/share/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
                        <Link to={`/share/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
                    </div>
                )}
                <div className="p-6 max-w-4xl mx-auto w-full">
                    <h2 className="text-2xl font-bold mb-4 text-center">üìÖ Tournament Fixtures ({tournamentName})</h2>
                    <p className="text-red-500 text-center py-8">{error}</p>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
            {/* Top Navigation Bar */}
            {/* --- MODIFICATION: Conditionally render/adjust nav links based on readOnly --- */}
            {!readOnly ? (
                <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
                    <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
                    <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
                    <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">PLAYERS</Link>
                    <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
                    <Link to={`/tournament/${tournamentId}/top-scorers`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
                </div>
            ) : (
                <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
                    <Link to={`/share/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
                    <Link to={`/share/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
                    <Link to={`/share/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
                    {/* Again, consider if you need a public stats page */}
                    {/* <Link to={`/share/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link> */}
                </div>
            )}

            <div className="p-6 max-w-4xl mx-auto">
                <h2 className="text-3xl font-extrabold mb-8 text-center">üìÖ Tournament Fixtures ({tournamentName})</h2>

                {fixtures.length === 0 ? (
                    <p className="text-center text-gray-500 dark:text-gray-400 text-lg py-10">
                        No fixtures generated yet. {!readOnly && <>Go to the <Link to={`/tournament/${tournamentId}`} className="text-blue-500 hover:underline">Tournament Admin</Link> page to generate them.</>}
                    </p>
                ) : (
                    sortedDates.map((dateKey, index) => (
                        <div key={dateKey} className="mb-8">
                            <h3 className="bg-red-600 text-white text-xl font-bold py-3 px-4 rounded-t-lg shadow-md text-center">
                                Week {index + 1}
                            </h3>
                            <div className="overflow-x-auto bg-white dark:bg-gray-800 rounded-b-lg shadow-lg">
                                <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                                    <thead className="bg-gray-50 dark:bg-gray-700">
                                        <tr>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                                                Home Team
                                            </th>
                                            <th scope="col" className="px-6 py-3 text-center text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                                                Score
                                            </th>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                                                Away Team
                                            </th>
                                            {/* --- MODIFICATION: Conditionally render Actions header --- */}
                                            {!readOnly && <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                                                Actions
                                            </th>}
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                                        {groupedFixtures[dateKey].map(fixture => (
                                            <tr key={fixture.id} className="hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors">
                                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-white">
                                                    {fixture.teamA}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-center">
                                                    {fixture.status === 'completed' ? (
                                                        <span className="font-bold text-lg">
                                                            {fixture.scoreA} - {fixture.scoreB}
                                                        </span>
                                                    ) : (
                                                        <span className="text-gray-500 dark:text-gray-400">0 - 0</span>
                                                    )}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">
                                                    {fixture.teamB}
                                                </td>
                                                {/* --- MODIFICATION: Conditionally render Actions button --- */}
                                                {!readOnly && (
                                                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                                        <button
                                                            onClick={() => handleUpdateScores(fixture.id, fixture.scoreA, fixture.scoreB)}
                                                            className="bg-yellow-500 text-white px-4 py-2 rounded-md hover:bg-yellow-600 transition-colors font-semibold text-xs uppercase"
                                                        >
                                                            Edit
                                                        </button>
                                                    </td>
                                                )}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    ))
                )}
            </div>

            {/* Reusable Modal Component */}
            <Modal
                isOpen={isModalOpen}
                onClose={closeCustomModal}
                // --- MODIFICATION: Only allow onConfirm if not readOnly ---
                onConfirm={modalConfirmAction && !readOnly ? modalConfirmAction : null}
                title={modalTitle}
                message={modalMessage}
                // --- MODIFICATION: Only show confirm button if not readOnly AND modalShowConfirmButton is true ---
                showConfirmButton={modalShowConfirmButton && !readOnly}
            >
                {/* Render custom content (e.g., score input fields) inside the modal */}
                {modalContent}
            </Modal>
        </div>
    );
}

--- END FILE: src\pages\FixturesPage.jsx ---

--- START FILE: src\pages\KnockoutPage.jsx ---

import React, { useEffect, useState, useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import { db } from '../firebase';
import { doc, getDoc, collection, addDoc, query, orderBy, onSnapshot, updateDoc, deleteDoc } from 'firebase/firestore'; // Import necessary Firestore functions
import { useAuth } from '../hooks/useAuth'; // Import useAuth for authentication state
// Note: This component implements its own inline modal.
// The import 'Modal from '../components/Modal';' is present but not used for rendering.

// --- MODIFICATION: Accept readOnly prop ---
export default function KnockoutPage({ readOnly = false }) { // Default to false
    const { id: tournamentId } = useParams();
    const { user, loading: authLoading } = useAuth(); // Get user and authLoading from useAuth hook
    const [tournamentName, setTournamentName] = useState('Loading...');
    const [rounds, setRounds] = useState([]);
    const [loading, setLoading] = useState(true); // General loading state for the page content
    const [error, setError] = useState(null);
    const [newMatch, setNewMatch] = useState({
        round: '',
        teamA: '',
        teamB: '',
        winner: null,
        scoreA: 0,
        scoreB: 0,
        status: 'scheduled'
    });
    // --- MODIFICATION: Hide add match form by default in readOnly mode ---
    const [isAddingMatch, setIsAddingMatch] = useState(readOnly ? false : false); // Start false, or if readOnly, always false
    const [editingMatchId, setEditingMatchId] = useState(null); // State for editing match
    const [editMatchData, setEditMatchData] = useState({}); // State for edited match data

    // Custom Modal Component states (inline implementation within this component)
    const [modalOpen, setModalOpen] = useState(false);
    const [modalMessage, setModalMessage] = useState('');
    const [modalConfirmAction, setModalConfirmAction] = useState(null);
    const [modalInputRequired, setModalInputRequired] = useState(false);
    const [modalInputLabel, setModalInputLabel] = useState(''); // Used for generic input labels
    const [modalInputValue, setModalInputValue] = useState(''); // Used for generic input value
    const [modalCustomContent, setModalCustomContent] = useState(null); // For rendering custom JSX inside modal
    // --- MODIFICATION: Added modalShowConfirmButton for granular control ---
    const [modalShowConfirmButton, setModalShowConfirmButton] = useState(true);

    // Function to open the custom inline modal
    const openModal = useCallback((message, confirmAction = null, inputRequired = false, inputLabel = '', initialValue = '', customContent = null, showConfirm = true) => {
        setModalMessage(message);
        setModalConfirmAction(() => confirmAction); // Wrap in arrow function to prevent immediate execution
        setModalInputRequired(inputRequired);
        setModalInputLabel(inputLabel);
        setModalInputValue(initialValue);
        setModalCustomContent(customContent);
        setModalShowConfirmButton(showConfirm); // Set the new state
        setModalOpen(true);
    }, []); // useCallback for memoization

    // Function to handle modal confirmation
    const handleModalConfirm = useCallback(() => {
        // --- MODIFICATION: Prevent confirm if in readOnly mode (client-side safety) ---
        if (readOnly) {
            openModal('This action is not allowed in view-only mode.', null, false, '', '', null, false); // No confirm button
            return;
        }

        if (modalConfirmAction) {
            if (modalInputRequired) {
                modalConfirmAction(modalInputValue);
            } else {
                modalConfirmAction();
            }
        }
        setModalOpen(false);
        setModalInputValue('');
        setModalConfirmAction(null); // Clear action after execution
        setModalCustomContent(null); // Clear custom content
        setModalShowConfirmButton(true); // Reset
    }, [modalConfirmAction, modalInputRequired, modalInputValue, readOnly, openModal]); // Depend on values that might change

    // Function to handle modal cancellation/closing
    const handleModalCancel = useCallback(() => {
        setModalOpen(false);
        setModalInputValue('');
        setModalConfirmAction(null); // Clear action
        setModalCustomContent(null); // Clear custom content
        setModalShowConfirmButton(true); // Reset
    }, []); // useCallback for memoization


    useEffect(() => {
        // --- MODIFICATION: Wait for authentication to load only if not in readOnly mode ---
        if (!readOnly && authLoading) {
            setLoading(true); // Keep loading state true while auth is pending
            return;
        }

        // --- MODIFICATION: If no user is logged in after auth loads AND not in readOnly mode, show error ---
        if (!readOnly && !user) {
            setError("You must be logged in to view knockout stage details.");
            setLoading(false);
            return;
        }

        if (!tournamentId) {
            setError("No tournament ID provided.");
            setLoading(false);
            return;
        }

        setLoading(true); // Start loading page content
        setError(null); // Clear any previous errors

        const fetchTournamentDetails = async () => {
            try {
                const docRef = doc(db, 'tournaments', tournamentId);
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // --- MODIFICATION: Verify ownership only if not in readOnly mode, otherwise allow access ---
                    if (readOnly || (user?.uid && data.userId === user.uid)) { // Use user?.uid for safe access
                        setTournamentName(data.name);
                    } else {
                        setTournamentName('Access Denied');
                        setError('You do not have permission to access this tournament.');
                    }
                } else {
                    setTournamentName('Tournament Not Found');
                    setError('Tournament details could not be loaded.');
                }
            } catch (err) {
                console.error('Error fetching tournament details:', err);
                setTournamentName('Error'); // Set a generic name on error
                setError('Failed to fetch tournament details.');
            } finally {
                setLoading(false); // Ensure loading state is false after attempt
            }
        };
        fetchTournamentDetails();

        // --- MODIFICATION: Do not set up real-time listener if there's an error already, or not authenticated in non-readOnly mode ---
        // The previous error state could be from the ownership check.
        if ((!readOnly && (!user || !user.uid)) || error) {
            return;
        }

        // Set up a real-time listener for knockout matches
        const matchesCollectionRef = collection(db, `tournaments/${tournamentId}/knockoutMatches`);
        const q = query(matchesCollectionRef, orderBy('round', 'asc'), orderBy('teamA', 'asc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            try {
                const fetchedMatches = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data(),
                    scoreA: doc.data().scoreA || 0, // Default to 0 if not present
                    scoreB: doc.data().scoreB || 0, // Default to 0 if not present
                }));

                // Group matches by round
                const groupedRounds = fetchedMatches.reduce((acc, match) => {
                    const roundName = match.round || 'Unknown Round'; // Handle cases where round might be missing
                    if (!acc[roundName]) {
                        acc[roundName] = [];
                    }
                    acc[roundName].push(match);
                    return acc;
                }, {});

                // Convert to an array of { name: "Round Name", matches: [...] }
                const sortedRounds = Object.keys(groupedRounds)
                    .sort((a, b) => {
                        return a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
                    })
                    .map(name => ({ name, matches: groupedRounds[name] }));

                setRounds(sortedRounds);
                setLoading(false); // Finished loading matches
                setError(null);
            } catch (err) {
                console.error('Error processing real-time knockout matches data:', err);
                setError('Failed to load knockout matches.');
                setLoading(false);
            }
        }, (err) => {
            console.error('Real-time listener error for knockout matches:', err);
            setError('Real-time updates failed for knockout matches.');
            setLoading(false);
        });

        return () => unsubscribe(); // Cleanup listener
    }, [tournamentId, user, authLoading, error, readOnly]); // Add user, authLoading, error, and readOnly to dependencies

    const handleAddMatch = async () => {
        // --- MODIFICATION: Prevent action if in readOnly mode ---
        if (readOnly) {
            openModal('This action is not allowed in view-only mode.', null, false, '', '', null, false);
            return;
        }

        if (!newMatch.round.trim() || !newMatch.teamA.trim() || !newMatch.teamB.trim()) {
            openModal('Please fill in all match details.', null, false, '', '', null, false);
            return;
        }
        try {
            await addDoc(collection(db, `tournaments/${tournamentId}/knockoutMatches`), newMatch);
            setNewMatch({ round: '', teamA: '', teamB: '', winner: null, scoreA: 0, scoreB: 0, status: 'scheduled' });
            setIsAddingMatch(false);
            openModal('Match added successfully!', null, false, '', '', null, false);
        } catch (err) {
            console.error('Error adding match:', err);
            openModal('Failed to add match. Please try again.', null, false, '', '', null, false);
        }
    };

    const handleUpdateMatch = async (matchId) => {
        // --- MODIFICATION: Prevent action if in readOnly mode ---
        if (readOnly) {
            openModal('This action is not allowed in view-only mode.', null, false, '', '', null, false);
            return;
        }

        // Basic validation for score inputs before update
        const parsedScoreA = parseInt(editMatchData.scoreA);
        const parsedScoreB = parseInt(editMatchData.scoreB);

        if (isNaN(parsedScoreA) || isNaN(parsedScoreB)) {
            openModal('Invalid Input', null, false, '', '', null, false); // Simplified call for error
            return;
        }

        try {
            const matchRef = doc(db, `tournaments/${tournamentId}/knockoutMatches`, matchId);
            const updatedData = {
                scoreA: parsedScoreA,
                scoreB: parsedScoreB,
                status: 'completed',
                winner: parsedScoreA > parsedScoreB ? editMatchData.teamA : parsedScoreA < parsedScoreB ? editMatchData.teamB : 'Draw' // Determine winner
            };
            await updateDoc(matchRef, updatedData);
            setEditingMatchId(null); // Exit editing mode
            setEditMatchData({}); // Clear edit data
            openModal('Match updated successfully!', null, false, '', '', null, false);
        } catch (err) {
            console.error('Error updating match:', err);
            openModal('Failed to update match. Please try again.', null, false, '', '', null, false);
        }
    };

    const handleDeleteMatch = async (matchId) => {
        // --- MODIFICATION: Prevent action if in readOnly mode ---
        if (readOnly) {
            openModal('This action is not allowed in view-only mode.', null, false, '', '', null, false);
            return;
        }

        openModal('Are you sure you want to delete this match?', async () => { // Use custom modal
            try {
                await deleteDoc(doc(db, `tournaments/${tournamentId}/knockoutMatches`, matchId));
                openModal('Match deleted successfully!', null, false, '', '', null, false);
            } catch (err) {
                console.error('Error deleting match:', err);
                openModal('Failed to delete match. Please try again.', null, false, '', '', null, false);
            }
        });
    };

    const startEditing = (match) => {
        // --- MODIFICATION: Prevent editing if in readOnly mode ---
        if (readOnly) {
            openModal('Editing is not allowed in view-only mode.', null, false, '', '', null, false);
            return;
        }
        setEditingMatchId(match.id);
        // Ensure scores are treated as strings for input value, convert null/undefined to empty string
        setEditMatchData({
            ...match,
            scoreA: match.scoreA !== undefined && match.scoreA !== null ? String(match.scoreA) : '',
            scoreB: match.scoreB !== undefined && match.scoreB !== null ? String(match.scoreB) : ''
        });
    };

    const cancelEditing = () => {
        setEditingMatchId(null);
        setEditMatchData({});
    };

    return (
        <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
            {/* Top Navigation Bar */}
            {/* --- MODIFICATION: Conditionally render/adjust nav links based on readOnly --- */}
            {!readOnly ? (
                <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
                    <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
                    <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
                    <Link to={`/tournament/${tournamentId}/top-scorers`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
                    <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
                </div>
            ) : (
                <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
                    <Link to={`/share/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
                    <Link to={`/share/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
                    <Link to={`/share/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
                    <Link to={`/share/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
                </div>
            )}

            <div className="p-6 max-w-5xl mx-auto w-full">
                <h2 className="text-2xl font-bold mb-4 text-center">üèÜ Knockout Stage: {tournamentName}</h2>

                {/* --- MODIFICATION: Conditionally render Add New Match button and form --- */}
                {!readOnly && (
                    <button
                        onClick={() => setIsAddingMatch(!isAddingMatch)}
                        className="bg-blue-600 text-white px-4 py-2 rounded mb-4 hover:bg-blue-700 transition-colors"
                    >
                        {isAddingMatch ? 'Hide Add Match Form' : '‚ûï Add New Match'}
                    </button>
                )}

                {isAddingMatch && !readOnly && ( // Ensure form is only shown if not readOnly
                    <div className="mb-6 bg-gray-100 dark:bg-gray-800 p-4 rounded shadow-md">
                        <h3 className="text-lg font-semibold mb-3">Add New Knockout Match</h3>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-4">
                            <input
                                type="text"
                                placeholder="Round Name (e.g., Quarter-Finals)"
                                value={newMatch.round}
                                onChange={e => setNewMatch({ ...newMatch, round: e.target.value })}
                                className="px-3 py-2 border rounded dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                            <input
                                type="text"
                                placeholder="Team A Name"
                                value={newMatch.teamA}
                                onChange={e => setNewMatch({ ...newMatch, teamA: e.target.value })}
                                className="px-3 py-2 border rounded dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                            <input
                                type="text"
                                placeholder="Team B Name"
                                value={newMatch.teamB}
                                onChange={e => setNewMatch({ ...newMatch, teamB: e.target.value })}
                                className="px-3 py-2 border rounded dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                        </div>
                        <button
                            onClick={handleAddMatch}
                            className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition-colors"
                        >
                            Create Match
                        </button>
                    </div>
                )}

                {authLoading && !readOnly ? ( // Only show auth loading if not in readOnly mode
                    <p className="text-center text-gray-500 py-8">Authenticating user...</p>
                ) : loading ? (
                    <p className="text-gray-500">Loading knockout matches...</p>
                ) : error ? (
                    <p className="text-red-500">Error: {error}</p>
                ) : rounds.length === 0 ? (
                    <p className="text-gray-500">
                        No knockout matches configured for this tournament yet.
                        {!readOnly && " Use the 'Add New Match' button to create them."}
                    </p>
                ) : (
                    <div className="space-y-6">
                        {rounds.map((round) => (
                            <div key={round.name} className="bg-white dark:bg-gray-800 p-4 rounded shadow-md">
                                <h3 className="text-xl font-bold mb-4 border-b pb-2 dark:border-gray-700">{round.name}</h3>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                    {round.matches.map((match) => (
                                        <div
                                            key={match.id}
                                            className={`border p-4 rounded-lg shadow-sm transition-all duration-200
                                                ${match.status === 'completed' ? 'bg-green-50 dark:bg-green-950 border-green-300' : 'bg-gray-50 dark:bg-gray-700 border-gray-300'}
                                                ${editingMatchId === match.id ? 'ring-2 ring-blue-500 border-blue-500' : ''}
                                            `}
                                        >
                                            {/* --- MODIFICATION: Conditionally render edit form or display mode --- */}
                                            {editingMatchId === match.id && !readOnly ? ( // Only allow editing if not readOnly
                                                // Edit form for a match
                                                <div className="space-y-2">
                                                    <div className="flex items-center gap-2">
                                                        <p className="font-semibold">{editMatchData.teamA}</p>
                                                        <input
                                                            type="number"
                                                            value={editMatchData.scoreA}
                                                            onChange={e => setEditMatchData({ ...editMatchData, scoreA: e.target.value })}
                                                            className="w-16 px-2 py-1 border rounded text-center dark:bg-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                            placeholder="0"
                                                            min="0"
                                                        />
                                                        <span> - </span>
                                                        <input
                                                            type="number"
                                                            value={editMatchData.scoreB}
                                                            onChange={e => setEditMatchData({ ...editMatchData, scoreB: e.target.value })}
                                                            className="w-16 px-2 py-1 border rounded text-center dark:bg-gray-600 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                            placeholder="0"
                                                            min="0"
                                                        />
                                                        <p className="font-semibold">{editMatchData.teamB}</p>
                                                    </div>
                                                    <div className="flex gap-2 justify-end">
                                                        <button
                                                            onClick={() => handleUpdateMatch(match.id)}
                                                            className="bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700"
                                                        >
                                                            Save
                                                        </button>
                                                        <button
                                                            onClick={cancelEditing}
                                                            className="bg-gray-400 text-white px-3 py-1 rounded text-sm hover:bg-gray-500"
                                                        >
                                                            Cancel
                                                        </button>
                                                    </div>
                                                </div>
                                            ) : (
                                                // Display mode for a match
                                                <div className="flex flex-col">
                                                    <p className="text-lg font-semibold mb-2">
                                                        {match.teamA} vs {match.teamB}
                                                    </p>
                                                    {match.status === 'completed' ? (
                                                        <p className="text-md text-green-700 dark:text-green-300">
                                                            Final Score: <strong>{match.scoreA} - {match.scoreB}</strong>
                                                            {match.winner && <span className="ml-2">Winner: {match.winner}</span>}
                                                        </p>
                                                    ) : (
                                                        <p className="text-md text-gray-600 dark:text-gray-300">Scheduled</p>
                                                    )}
                                                    {/* --- MODIFICATION: Conditionally render action buttons --- */}
                                                    {!readOnly && (
                                                        <div className="flex gap-2 mt-3 justify-end">
                                                            {match.status !== 'completed' && ( // Only show edit if not completed
                                                                <button
                                                                    onClick={() => startEditing(match)}
                                                                    className="bg-yellow-500 text-white px-3 py-1 rounded text-sm hover:bg-yellow-600"
                                                                >
                                                                    Edit Scores
                                                                </button>
                                                            )}
                                                            <button
                                                                onClick={() => handleDeleteMatch(match.id)}
                                                                className="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600"
                                                            >
                                                                Delete
                                                            </button>
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>

            {/* Custom Modal Component (Inline) for this page's alerts/confirms */}
            {modalOpen && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                    <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm text-center">
                        {/* Renders custom content if provided, otherwise default message/input */}
                        {modalCustomContent || (
                            <>
                                <p className="text-lg font-semibold mb-4">{modalMessage}</p>
                                {modalInputRequired && !readOnly && ( // Conditional rendering for generic input field(s), only if not readOnly
                                    <div className="flex flex-col gap-2 mb-4">
                                        {modalInputLabel.split(',').map((label, index) => (
                                            <input
                                                key={index}
                                                type="text" // Using type="text" for generic string input here
                                                placeholder={label.trim()}
                                                value={modalInputValue.split(',')[index] || ''}
                                                onChange={(e) => {
                                                    const newValues = modalInputValue.split(',');
                                                    newValues[index] = e.target.value;
                                                    setModalInputValue(newValues.join(','));
                                                }}
                                                className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            />
                                        ))}
                                    </div>
                                )}
                            </>
                        )}
                        <div className="flex justify-center gap-4 mt-4">
                            {/* --- MODIFICATION: Only show confirm button if a confirm action is provided AND not in readOnly mode --- */}
                            {modalConfirmAction && modalShowConfirmButton && !readOnly && (
                                <button
                                    onClick={handleModalConfirm}
                                    className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors"
                                >
                                    Confirm
                                </button>
                            )}
                            <button
                                onClick={handleModalCancel}
                                className="bg-gray-400 text-white px-4 py-2 rounded-md hover:bg-gray-500 transition-colors"
                            >
                                {modalConfirmAction && modalShowConfirmButton && !readOnly ? 'Cancel' : 'Close'} {/* Text changes based on confirm action presence and readOnly state */}
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}

--- END FILE: src\pages\KnockoutPage.jsx ---

--- START FILE: src\pages\LeaderboardPage.jsx ---

import React, { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import { db } from '../firebase';
import { collection, onSnapshot, query, orderBy, doc, getDoc } from 'firebase/firestore'; // Added doc, getDoc

export default function LeaderboardPage() {
  const { id: tournamentId } = useParams(); // Get tournament ID from URL
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [standings, setStandings] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Effect to fetch the specific tournament's name
  useEffect(() => {
    if (!tournamentId) return;
    const fetchTournamentName = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);
        if (tournamentSnap.exists()) {
          setTournamentName(tournamentSnap.data().name);
        } else {
          // If tournament doesn't exist, set error and name accordingly
          setTournamentName('Tournament Not Found');
          setError('The requested tournament does not exist.');
        }
      } catch (err) {
        console.error('Error fetching tournament name:', err);
        setError('Failed to fetch tournament name.'); // Set error for UI
      }
    };
    fetchTournamentName();
  }, [tournamentId]);

  useEffect(() => {
    if (!tournamentId) {
      setError("No tournament ID provided.");
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Reference to the 'leaderboard' subcollection for the specific tournament
      const leaderboardCollectionRef = collection(db, `tournaments/${tournamentId}/leaderboard`);
      // Create a query to order by points in descending order
      // If two teams have the same points, sort by goalDifference (descending)
      // Then, by goalsFor (descending)
      // Finally, by name (ascending) for consistent tie-breaking
      const q = query(
        leaderboardCollectionRef,
        orderBy('points', 'desc'),
        orderBy('goalDifference', 'desc'), // Secondary sort
        orderBy('goalsFor', 'desc'),      // Tertiary sort
        orderBy('name', 'asc')            // Quaternary sort
      );

      // Set up a real-time listener for leaderboard changes
      const unsubscribe = onSnapshot(q, (snapshot) => {
        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setStandings(data);
        setLoading(false);
      }, (err) => {
        console.error('Error fetching real-time leaderboard:', err);
        setError('Failed to load leaderboard. Please try again.'); // Set error message
        setLoading(false);
      });

      // Clean up the listener when the component unmounts or tournamentId changes
      return () => unsubscribe();
    } catch (err) {
      console.error("Error setting up leaderboard listener:", err);
      setError("Failed to set up leaderboard listener.");
      setLoading(false);
    }
  }, [tournamentId]); // Re-run effect if tournamentId changes

  return (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
        {/* Changed 'Players' to 'Top Scorers' here as well, consistent with other navs */}
        <Link to={`/tournament/${tournamentId}/top-scorers`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
        {/* Added Knockout link if applicable for this tournament */}
        <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
      </div>

      <div className="p-6 max-w-4xl mx-auto w-full">
        <h2 className="text-2xl font-bold mb-4 text-center">üèÜ Leaderboard ({tournamentName})</h2>

        {loading ? (
          <p className="text-gray-500 text-center">Loading leaderboard...</p>
        ) : error ? (
          <p className="text-red-500 text-center">Error: {error}</p>
        ) : standings.length === 0 ? (
          <p className="text-gray-500 text-center">No leaderboard data available yet for this tournament. Play some matches!</p>
        ) : (
          <div className="overflow-x-auto rounded-lg shadow-lg border border-gray-300 dark:border-gray-600">
            <table className="min-w-full table-auto text-sm md:text-base"> {/* Adjusted font size for responsiveness */}
              <thead>
                <tr className="bg-gray-100 dark:bg-gray-800 text-left">
                  <th className="px-2 py-2 border-b dark:border-gray-700">P</th> {/* Position */}
                  <th className="px-2 py-2 border-b dark:border-gray-700">Team</th>
                  <th className="px-2 py-2 border-b dark:border-gray-700">Pl</th> {/* Played */}
                  <th className="px-2 py-2 border-b dark:border-gray-700">W</th> {/* Wins */}
                  <th className="px-2 py-2 border-b dark:border-gray-700">D</th> {/* Draws */}
                  <th className="px-2 py-2 border-b dark:border-gray-700">L</th> {/* Losses */}
                  <th className="px-2 py-2 border-b dark:border-gray-700">GF</th> {/* Goals For */}
                  <th className="px-2 py-2 border-b dark:border-gray-700">GA</th> {/* Goals Against */}
                  <th className="px-2 py-2 border-b dark:border-gray-700">GD</th> {/* Goal Difference */}
                  <th className="px-2 py-2 border-b dark:border-gray-700">Pts</th> {/* Points */}
                </tr>
              </thead>
              <tbody>
                {standings.map((team, index) => (
                  <tr
                    key={team.id || index}
                    className={`border-b dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700
                      ${index < 2 ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200' : ''} /* Green for top 2 (Promotion) */
                      ${index >= standings.length - 2 ? 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200' : ''} /* Red for bottom 2 (Relegation) */
                    `}
                  >
                    <td className="px-2 py-2 font-bold">{index + 1}</td>
                    <td className="px-2 py-2">{team.name || 'N/A'}</td>
                    <td className="px-2 py-2">{team.played || 0}</td>
                    <td className="px-2 py-2">{team.wins || 0}</td>
                    <td className="px-2 py-2">{team.draws || 0}</td>
                    <td className="px-2 py-2">{team.losses || 0}</td>
                    <td className="px-2 py-2">{team.goalsFor || 0}</td>
                    <td className="px-2 py-2">{team.goalsAgainst || 0}</td>
                    <td className="px-2 py-2">{team.goalDifference || 0}</td>
                    <td className="px-2 py-2 font-semibold text-blue-600 dark:text-blue-400">{team.points || 0}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}


--- END FILE: src\pages\LeaderboardPage.jsx ---

--- START FILE: src\pages\PlayerPage.jsx ---

import React, { useEffect, useState, useMemo, useCallback } from 'react';
import { db } from '../firebase';
import { collection, addDoc, onSnapshot, doc, deleteDoc, updateDoc, query, orderBy, getDoc, getDocs, writeBatch, where } from 'firebase/firestore';
import { useParams, Link } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';

// Custom Modal Component defined directly within this file for its specific use cases.
const Modal = ({ isOpen, message, confirmAction, cancelAction, inputRequired, inputLabel, inputValue, setInputValue }) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm text-center text-gray-900 dark:text-white">
        {message && <p className="text-lg font-semibold mb-4">{message}</p>}
        {inputRequired && (
          <div className="flex flex-col gap-2 mb-4">
            <input
              type="number"
              placeholder={inputLabel.trim()}
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              className="w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              style={{ pointerEvents: 'auto', zIndex: 'auto' }}
            />
          </div>
        )}
        <div className="flex justify-center gap-4 mt-4">
          {confirmAction && (
            <button
              onClick={confirmAction}
              className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors"
            >
              Confirm
            </button>
          )}
          <button
            onClick={cancelAction}
            className="bg-gray-400 text-white px-4 py-2 rounded-md hover:bg-gray-500 transition-colors"
          >
            {confirmAction ? 'Cancel' : 'Close'}
          </button>
        </div>
      </div>
    </div>
  );
};

export default function PlayerPage() {
  const { id: tournamentId } = useParams();
  const { user, loading: authLoading } = useAuth();
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [loadingTournamentData, setLoadingTournamentData] = useState(true);
  const [error, setError] = useState(null);

  const [players, setPlayers] = useState([]);
  const [matchStats, setMatchStats] = useState([]);
  const [teams, setTeams] = useState([]);

  const [newPlayerName, setNewPlayerName] = useState('');
  const [newPlayerTeam, setNewPlayerTeam] = useState('');
  const [customNewTeamName, setCustomNewTeamName] = useState('');
  const [addPlayerError, setAddPlayerError] = useState('');

  const [showAddPlayerForm, setShowAddPlayerForm] = useState(false);

  // Custom Modal Component states (for this inline modal)
  const [modalOpen, setModalOpen] = useState(false);
  const [modalMessage, setModalMessage] = useState('');
  const [modalConfirmAction, setModalConfirmAction] = useState(null);
  const [modalInputRequired, setModalInputRequired] = useState(false);
  const [modalInputLabel, setModalInputLabel] = useState('');
  const [modalInputValue, setModalInputValue] = useState('');

  // ADDED: Sorting state for the player table
  const [sortConfig, setSortConfig] = useState({ key: 'totalGoals', direction: 'descending' });

  const openModal = useCallback((message, confirmAction = null, inputRequired = false, inputLabel = '', initialValue = '') => {
    setModalMessage(message);
    setModalConfirmAction(() => confirmAction);
    setModalInputRequired(inputRequired);
    setModalInputLabel(inputLabel);
    setModalInputValue(initialValue);
    setModalOpen(true);
  }, []);

  const handleModalConfirm = useCallback(() => {
    if (modalConfirmAction) {
      if (modalInputRequired) {
        modalConfirmAction(modalInputValue);
      } else {
        modalConfirmAction();
      }
    }
    setModalOpen(false);
    setModalInputValue('');
    setModalConfirmAction(null);
  }, [modalConfirmAction, modalInputRequired, modalInputValue]);

  const handleModalCancel = useCallback(() => {
    setModalOpen(false);
    setModalInputValue('');
    setModalConfirmAction(null);
  }, []);

  useEffect(() => {
    if (authLoading) {
      setLoadingTournamentData(true);
      return;
    }

    if (!user) {
      setError("You must be logged in to view tournament details.");
      setLoadingTournamentData(false);
      return;
    }

    if (!tournamentId) {
      setError("No tournament ID provided in the URL.");
      setLoadingTournamentData(false);
      return;
    }

    setLoadingTournamentData(true);
    setError(null);

    const fetchTournamentName = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);
        if (tournamentSnap.exists()) {
          const data = tournamentSnap.data();
          if (data.userId === user.uid) {
            setTournamentName(data.name);
          } else {
            setTournamentName('Access Denied');
            setError('You do not have permission to access this tournament.');
          }
        } else {
          setTournamentName('Tournament Not Found');
          setError('The requested tournament does not exist.');
        }
        setLoadingTournamentData(false);
      } catch (err) {
        console.error('Error fetching tournament name:', err);
        setTournamentName('Error');
        setError('Failed to load tournament details.');
        setLoadingTournamentData(false);
      }
    };
    fetchTournamentName();
  }, [tournamentId, user, authLoading]);


  useEffect(() => {
    if (authLoading || !user || !tournamentId || error) return;

    const playersCollectionRef = collection(db, `tournaments/${tournamentId}/players`);
    const unsubscribePlayers = onSnapshot(playersCollectionRef, (snapshot) => {
      const fetchedPlayers = snapshot.docs.map(doc => ({
        id: doc.id,
        manOfTheMatchCount: doc.data().manOfTheMatchCount || 0,
        ...doc.data()
      }));
      setPlayers(fetchedPlayers);

      const uniqueTeams = [...new Set(fetchedPlayers.map(player => player.team))].sort((a, b) => a.localeCompare(b));
      setTeams(uniqueTeams);

      if (showAddPlayerForm && newPlayerTeam === '' && uniqueTeams.length > 0) {
        setNewPlayerTeam(uniqueTeams[0]);
      } else if (showAddPlayerForm && newPlayerTeam === '' && uniqueTeams.length === 0) {
          setNewPlayerTeam('_new_team_');
      }

    }, (err) => {
      console.error('Error fetching real-time players:', err);
      setError('Failed to load players. Please try again.');
    });

    return () => unsubscribePlayers();
  }, [tournamentId, user, authLoading, error, showAddPlayerForm]);


  useEffect(() => {
    if (authLoading || !user || !tournamentId || error) return;

    const matchStatsCollectionRef = collection(db, `tournaments/${tournamentId}/match_stats`);
    const q = query(matchStatsCollectionRef, orderBy('timestamp', 'desc'));

    const unsubscribeStats = onSnapshot(q, (snapshot) => {
      setMatchStats(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
    }, (err) => {
      console.error('Error fetching real-time match stats:', err);
      setError('Failed to load match statistics. Please try again.');
    });

    return () => unsubscribeStats();
  }, [tournamentId, user, authLoading, error]);


  const handleAddPlayer = async () => {
    setAddPlayerError('');

    if (!newPlayerName.trim()) {
      setAddPlayerError('Player name cannot be empty.');
      return;
    }

    let finalTeamName = '';
    if (newPlayerTeam === '_new_team_') {
      if (!customNewTeamName.trim()) {
        setAddPlayerError('Please enter a name for the new team.');
        return;
      }
      finalTeamName = customNewTeamName.trim();
    } else if (newPlayerTeam.trim()) {
      finalTeamName = newPlayerTeam.trim();
    } else {
      setAddPlayerError('Please select or enter a team name.');
      return;
    }

    try {
      await addDoc(collection(db, `tournaments/${tournamentId}/players`), {
        name: newPlayerName.trim(),
        team: finalTeamName,
        manOfTheMatchCount: 0
      });
      setNewPlayerName('');
      setNewPlayerTeam('');
      setCustomNewTeamName('');
      setShowAddPlayerForm(false);
    } catch (err) {
      console.error('Error adding player:', err);
      setAddPlayerError('Failed to add player.');
    }
  };

  const handleDeletePlayer = async (playerId) => {
    openModal('Are you sure you want to delete this player? This will also delete associated match stats.', async () => {
      try {
        const batch = writeBatch(db);

        const playerDocRef = doc(db, `tournaments/${tournamentId}/players`, playerId);
        batch.delete(playerDocRef);

        const matchStatsCollectionRef = collection(db, `tournaments/${tournamentId}/match_stats`);
        const statsToDeleteQuery = query(matchStatsCollectionRef, where('playerId', '==', playerId));
        const statsToDeleteSnapshot = await getDocs(statsToDeleteQuery);

        statsToDeleteSnapshot.docs.forEach(statDoc => {
          batch.delete(statDoc.ref);
        });

        await batch.commit();
        openModal('Player and associated stats deleted successfully!', null);
      } catch (err) {
        console.error('Error deleting player and associated stats:', err);
        openModal('Failed to delete player. Please try again.', null);
      }
    });
  };

  const handleAdjustPlayerStat = async (playerId, statType, changeAmount) => {
    const amount = parseInt(changeAmount, 10);
    if (isNaN(amount)) {
      openModal('Invalid input. Please enter a valid number.', null);
      return;
    }

    try {
      if (statType === 'goals' || statType === 'assists') {
        await addDoc(collection(db, `tournaments/${tournamentId}/match_stats`), {
          playerId: playerId,
          matchId: 'manual_adjustment',
          goals: statType === 'goals' ? amount : 0,
          assists: statType === 'assists' ? amount : 0,
          timestamp: new Date(),
          type: 'manual_adjustment'
        });
      } else if (statType === 'manOfTheMatchCount') {
        const playerRef = doc(db, `tournaments/${tournamentId}/players`, playerId);
        const playerSnap = await getDoc(playerRef);
        if (playerSnap.exists()) {
          const currentCount = playerSnap.data().manOfTheMatchCount || 0;
          await updateDoc(playerRef, {
            manOfTheMatchCount: Math.max(0, currentCount + amount)
          });
        }
      }
      openModal(`Stat updated successfully!`, null);
    } catch (err) {
      console.error(`Error adjusting ${statType}:`, err);
      openModal(`Failed to adjust ${statType}. Please try again.`, null);
    }
  };


  // Calculate total goals, assists, and MOTM for each player based on matchStats
  const playerAggregatedStats = useMemo(() => {
    return players.map(player => {
      const playerGoals = matchStats.filter(stat => stat.playerId === player.id)
        .reduce((sum, stat) => sum + (stat.goals || 0), 0);
      const playerAssists = matchStats.filter(stat => stat.playerId === player.id)
        .reduce((sum, stat) => sum + (stat.assists || 0), 0);
      const manOfTheMatchCount = player.manOfTheMatchCount || 0;

      return { ...player, totalGoals: playerGoals, totalAssists: playerAssists, manOfTheMatchCount: manOfTheMatchCount };
    }).sort((a, b) => {
      // Primary sort
      if (a[sortConfig.key] < b[sortConfig.key]) {
        return sortConfig.direction === 'ascending' ? -1 : 1;
      }
      if (a[sortConfig.key] > b[sortConfig.key]) {
        return sortConfig.direction === 'ascending' ? 1 : -1;
      }

      // Secondary sort for ties (e.g., if goals are tied, sort by assists, then name)
      if (sortConfig.key === 'totalGoals') {
        if (a.totalAssists < b.totalAssists) return 1;
        if (a.totalAssists > b.totalAssists) return -1;
      } else if (sortConfig.key === 'totalAssists') {
        if (a.totalGoals < b.totalGoals) return 1;
        if (a.totalGoals > b.totalGoals) return -1;
      } else if (sortConfig.key === 'manOfTheMatchCount') {
        if (a.totalGoals < b.totalGoals) return 1;
        if (a.totalGoals > b.totalGoals) return -1;
      }
      return a.name.localeCompare(b.name); // Tertiary sort by name
    });
  }, [players, matchStats, sortConfig]); // `sortConfig` is now correctly a dependency

  // ADDED: requestSort function
  const requestSort = (key) => {
    let direction = 'descending';
    if (sortConfig.key === key && sortConfig.direction === 'descending') {
      direction = 'ascending';
    }
    setSortConfig({ key, direction });
  };

  // ADDED: getSortIcon function
  const getSortIcon = (key) => {
    if (sortConfig.key === key) {
      return sortConfig.direction === 'ascending' ? '‚ñ≤' : '‚ñº';
    }
    return '';
  };

  return (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
      </div>

      <div className="p-6 max-w-5xl mx-auto w-full">
        <h2 className="text-2xl font-bold mb-4 text-center">üë§ Player Management ({tournamentName})</h2>

        {authLoading || loadingTournamentData ? (
          <p className="text-center text-gray-500 py-8">Loading data...</p>
        ) : error ? (
          <p className="text-red-500 text-center mb-4">{error}</p>
        ) : (
          <>
            {/* ADD NEW PLAYER Button */}
            <div className="flex justify-center mb-6">
              <button
                onClick={() => setShowAddPlayerForm(!showAddPlayerForm)}
                className="bg-red-600 text-white font-bold py-3 px-6 rounded-md shadow-lg hover:bg-red-700 transition-colors duration-200 uppercase tracking-wide transform hover:scale-105"
              >
                {showAddPlayerForm ? 'Hide Add Player Form' : 'Add New Player'}
              </button>
            </div>

            {/* Add New Player Section - Toggled Visibility */}
            {showAddPlayerForm && (
              <div className="mb-6 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg shadow-md">
                <h3 className="text-xl font-bold mb-3">‚ûï Add New Player Details</h3>
                <div className="flex flex-wrap gap-3 items-center">
                  <input
                    type="text"
                    placeholder="Player Name"
                    value={newPlayerName}
                    onChange={(e) => setNewPlayerName(e.target.value)}
                    className="border px-3 py-2 rounded-md dark:bg-gray-700 dark:text-white flex-grow min-w-[150px] focus:outline-none focus:ring-2 focus:ring-blue-500"
                    required
                  />

                  {/* Team Name Dropdown */}
                  <select
                    value={newPlayerTeam}
                    onChange={(e) => {
                      setNewPlayerTeam(e.target.value);
                      // Clear the custom new team name input if an existing team is selected
                      if (e.target.value !== '_new_team_') {
                        setCustomNewTeamName('');
                      }
                    }}
                    className="border px-3 py-2 rounded-md dark:bg-gray-700 dark:text-white flex-grow min-w-[150px] focus:outline-none focus:ring-2 focus:ring-blue-500"
                    required
                  >
                    <option value="" disabled>Select Team</option>
                    {/* Option to type a new team */}
                    <option value="_new_team_">-- Add New Team --</option>
                    {teams.map(team => (
                      <option key={team} value={team}>{team}</option>
                    ))}
                  </select>

                  {/* Input for new team name, shown conditionally */}
                  {newPlayerTeam === '_new_team_' && (
                    <input
                      type="text"
                      placeholder="Enter New Team Name"
                      value={customNewTeamName}
                      onChange={(e) => setCustomNewTeamName(e.target.value)}
                      className="border px-3 py-2 rounded-md dark:bg-gray-700 dark:text-white flex-grow min-w-[150px] focus:outline-none focus:ring-2 focus:ring-blue-500"
                      required
                    />
                  )}

                  <button
                    onClick={handleAddPlayer}
                    className="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition-colors"
                  >
                    Add Player
                  </button>
                </div>
                {addPlayerError && <p className="text-red-500 text-sm mt-2">{addPlayerError}</p>}
              </div>
            )}

            {/* Player Stats Table (Combined Top Scorers & Assisters, sortable) */}
            <h3 className="text-2xl font-bold mt-8 mb-4">üìä Player Statistics</h3>
            {playerAggregatedStats.length === 0 ? (
              <p className="text-gray-500">No players or stats found yet. Add some!</p>
            ) : (
              <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden mb-8">
                <table className="min-w-full table-auto">
                  <thead>
                    <tr className="bg-gray-200 dark:bg-gray-700 text-left">
                      <th className="px-4 py-2 border-b dark:border-gray-600">P</th>
                      <th className="px-4 py-2 border-b dark:border-gray-600">Player</th>
                      <th className="px-4 py-2 border-b dark:border-gray-600">Team</th>
                      <th
                        className="px-4 py-2 border-b dark:border-gray-600 cursor-pointer hover:bg-gray-300 dark:hover:bg-gray-600"
                        onClick={() => requestSort('totalGoals')}
                      >
                        Goals {getSortIcon('totalGoals')}
                      </th>
                      <th
                        className="px-4 py-2 border-b dark:border-gray-600 cursor-pointer hover:bg-gray-300 dark:hover:bg-gray-600"
                        onClick={() => requestSort('totalAssists')}
                      >
                        Assists {getSortIcon('totalAssists')}
                      </th>
                      <th
                        className="px-4 py-2 border-b dark:border-gray-600 cursor-pointer hover:bg-gray-300 dark:hover:bg-gray-600"
                        onClick={() => requestSort('manOfTheMatchCount')}
                      >
                        MOTM {getSortIcon('manOfTheMatchCount')}
                      </th>
                      <th className="px-4 py-2 border-b dark:border-gray-600">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {playerAggregatedStats.map((player, index) => (
                      <tr key={player.id} className="border-b dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700">
                        <td className="px-4 py-2 font-bold">{index + 1}</td>
                        <td className="px-4 py-2">{player.name}</td>
                        <td className="px-4 py-2">{player.team}</td>
                        <td className="px-4 py-2">{player.totalGoals}</td>
                        <td className="px-4 py-2">{player.totalAssists}</td>
                        <td className="px-4 py-2">{player.manOfTheMatchCount}</td>
                        <td className="px-4 py-2 flex flex-wrap gap-2 items-center">
                          {/* Goals Adjustment */}
                          <button
                            onClick={() => openModal(`Add Goals for ${player.name}:`, (val) => handleAdjustPlayerStat(player.id, 'goals', val), true, 'Goals to Add', '1')}
                            className="bg-gray-500 text-white px-2 py-1 rounded-md text-sm hover:bg-gray-600 transition-colors flex items-center justify-center"
                            title="Add Goals"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                            </svg>
                          </button>
                          <button
                            onClick={() => openModal(`Subtract Goals for ${player.name}:`, (val) => handleAdjustPlayerStat(player.id, 'goals', -val), true, 'Goals to Subtract', '1')}
                            className="bg-gray-500 text-white px-2 py-1 rounded-md text-sm hover:bg-gray-600 transition-colors flex items-center justify-center"
                            title="Subtract Goals"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M18 12H6" />
                            </svg>
                          </button>

                          {/* Assists Adjustment */}
                          <button
                            onClick={() => openModal(`Add Assists for ${player.name}:`, (val) => handleAdjustPlayerStat(player.id, 'assists', val), true, 'Assists to Add', '1')}
                            className="bg-blue-500 text-white px-2 py-1 rounded-md text-sm hover:bg-blue-600 transition-colors flex items-center justify-center"
                            title="Add Assists"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                            </svg>
                          </button>
                          <button
                            onClick={() => openModal(`Subtract Assists for ${player.name}:`, (val) => handleAdjustPlayerStat(player.id, 'assists', -val), true, 'Assists to Subtract', '1')}
                            className="bg-blue-500 text-white px-2 py-1 rounded-md text-sm hover:bg-blue-600 transition-colors flex items-center justify-center"
                            title="Subtract Assists"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M18 12H6" />
                            </svg>
                          </button>

                          {/* MOTM Adjustment */}
                          <button
                            onClick={() => handleAdjustPlayerStat(player.id, 'manOfTheMatchCount', 1)}
                            className="bg-purple-600 text-white px-2 py-1 rounded-md text-sm hover:bg-purple-700 transition-colors"
                            title="Add MOTM"
                          >
                            MOTM +
                          </button>
                          <button
                            onClick={() => handleAdjustPlayerStat(player.id, 'manOfTheMatchCount', -1)}
                            className="bg-purple-600 text-white px-2 py-1 rounded-md text-sm hover:bg-purple-700 transition-colors"
                            title="Subtract MOTM"
                          >
                            MOTM -
                          </button>
                          <button
                            onClick={() => handleDeletePlayer(player.id)}
                            className="bg-red-500 text-white px-3 py-1 rounded-md text-sm hover:bg-red-600 transition-colors"
                            title="Delete Player"
                          >
                            Delete
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </>
        )}
      </div>

      {/* Custom Modal Component (Inline for this page) */}
      <Modal
        isOpen={modalOpen}
        message={modalMessage}
        confirmAction={modalConfirmAction ? handleModalConfirm : null}
        cancelAction={handleModalCancel}
        inputRequired={modalInputRequired}
        inputLabel={modalInputLabel}
        inputValue={modalInputValue}
        setInputValue={setModalInputValue}
      />
    </div>
  );
}

--- END FILE: src\pages\PlayerPage.jsx ---

--- START FILE: src\pages\StatsPage.jsx ---

// üìÅ src/pages/StatsPage.jsx
import React, { useEffect, useState } from 'react';
import { db } from '../firebase';
import { collection, onSnapshot, query, orderBy, doc, getDoc } from 'firebase/firestore';
import { Bar, Pie } from 'react-chartjs-2';
import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend, ArcElement } from 'chart.js';
import { useParams, Link } from 'react-router-dom';

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend, ArcElement);

// Dynamic color generation for teams - moved outside for better performance
// This ensures colors are generated once per unique team set and are visually distinct.
const generateColors = (count) => {
  const baseColors = [
    '#3B82F6', // blue-500
    '#10B981', // green-500
    '#F59E0B', // yellow-500
    '#EF4444', // red-500
    '#6366F1', // indigo-500
    '#8B5CF6', // purple-500
    '#06B6D4', // cyan-500
    '#EC4899', // pink-500
    '#A855F7', // fuchsia-500
    '#14B8A6', // teal-500
    '#F97316', // orange-500
    '#6B7280', // gray-500
  ];
  // Extend with more vibrant random colors if needed to cover all teams
  const colors = [...baseColors];
  while (colors.length < count) {
    // Generate a random bright color (HSL for better control)
    const hue = Math.floor(Math.random() * 360);
    const saturation = Math.floor(Math.random() * (100 - 70) + 70); // 70-100% saturation
    const lightness = Math.floor(Math.random() * (70 - 40) + 40); // 40-70% lightness
    colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
  }
  return colors;
};

export default function StatsPage() {
  const { id: tournamentId } = useParams(); // Get tournament ID from URL
  const [tournamentName, setTournamentName] = useState('Loading...'); // State for tournament name
  const [stats, setStats] = useState([]); // Stores completed fixture data
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Effect to fetch the specific tournament's name
  useEffect(() => {
    if (!tournamentId) {
      setTournamentName('No Tournament ID');
      setError("Tournament ID is missing.");
      return;
    }
    const fetchTournamentName = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);
        if (tournamentSnap.exists()) {
          setTournamentName(tournamentSnap.data().name);
        } else {
          setTournamentName('Tournament Not Found');
          setError('The requested tournament does not exist.');
        }
      } catch (err) {
        console.error('Error fetching tournament name:', err);
        setTournamentName('Error loading name');
        setError('Failed to load tournament name.');
      }
    };
    fetchTournamentName();
  }, [tournamentId]);

  useEffect(() => {
    if (!tournamentId) {
      setLoading(false); // Stop loading if no tournament ID
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
      // Ordering by timestamp is good for consistency, ensures index usage if applicable
      const q = query(fixturesCollectionRef, orderBy('timestamp', 'asc'));

      const unsubscribe = onSnapshot(q, (snapshot) => {
        const matchData = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          // Ensure scores are numbers, default to 0 if undefined, null, or non-numeric
          scoreA: Number(doc.data().scoreA) || 0,
          scoreB: Number(doc.data().scoreB) || 0,
        }));
        // Filter for only completed matches for statistics
        setStats(matchData.filter(match => match.status === 'completed'));
        setLoading(false);
      }, (err) => {
        console.error('Error fetching real-time match stats:', err);
        setError('Failed to load match statistics. Please try again.');
        setLoading(false);
      });

      return () => unsubscribe(); // Clean up the listener
    } catch (err) {
      console.error("Error setting up stats listener:", err);
      setError("Failed to set up stats listener.");
      setLoading(false);
    }
  }, [tournamentId]);

  // Handle loading and error states for the main content
  if (loading) {
    return (
      <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
        {/* Top Navigation Bar */}
        <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
          <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
          <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
          <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
          <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
          <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
          <Link to={`/tournament/${tournamentId}/ai-prediction`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">AI PREDICTION</Link>
        </div>
        <div className="p-6 max-w-4xl mx-auto w-full">
          <h2 className="text-2xl font-bold mb-4 text-center">üìä Tournament Statistics ({tournamentName})</h2>
          <p className="text-center text-gray-500 py-8">Loading match stats...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
        {/* Top Navigation Bar */}
        <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
          <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
          <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
          <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
          <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
          <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
          <Link to={`/tournament/${tournamentId}/ai-prediction`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">AI PREDICTION</Link>
        </div>
        <div className="p-6 max-w-4xl mx-auto w-full">
          <h2 className="text-2xl font-bold mb-4 text-center">üìä Tournament Statistics ({tournamentName})</h2>
          <p className="text-center text-red-500 py-8">Error: {error}</p>
        </div>
      </div>
    );
  }

  // If no completed matches, display a message
  if (stats.length === 0) {
    return (
      <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
        {/* Top Navigation Bar */}
        <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
          <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
          <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
          <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
          <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
          <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
          <Link to={`/tournament/${tournamentId}/ai-prediction`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">AI PREDICTION</Link>
        </div>
        <div className="p-6 max-w-4xl mx-auto w-full">
          <h2 className="text-2xl font-bold mb-4 text-center">üìä Tournament Statistics ({tournamentName})</h2>
          <p className="text-center text-gray-500 py-8">No completed matches available for statistics in this tournament yet. Play some matches!</p>
        </div>
      </div>
    );
  }

  // Calculate team goals from completed matches
  const teamGoals = stats.reduce((acc, match) => {
    // Ensure that match.scoreA and match.scoreB are treated as numbers
    acc[match.teamA] = (acc[match.teamA] || 0) + (Number(match.scoreA) || 0);
    acc[match.teamB] = (acc[match.teamB] || 0) + (Number(match.scoreB) || 0);
    return acc;
  }, {});

  // Calculate total goals and average goals per completed match
  const totalGoals = Object.values(teamGoals).reduce((a, b) => a + b, 0);
  const avgGoals = stats.length > 0 ? (totalGoals / stats.length).toFixed(2) : 0;

  // Get the dynamic colors based on the number of unique teams
  const teamNames = Object.keys(teamGoals);
  const dynamicColors = generateColors(teamNames.length);

  const barData = {
    labels: teamNames,
    datasets: [
      {
        label: 'Goals Scored',
        data: Object.values(teamGoals),
        backgroundColor: dynamicColors,
        borderColor: dynamicColors.map(color => color.replace(')', ', 0.8)')), // Slightly darker border for contrast
        borderWidth: 1,
      },
    ],
  };

  const pieData = {
    labels: teamNames,
    datasets: [
      {
        label: 'Goals Distribution',
        data: Object.values(teamGoals),
        backgroundColor: dynamicColors,
        borderColor: '#fff', // White border for pie segments
        borderWidth: 2,
      },
    ],
  };

  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false, // Allow charts to adapt to container size
    plugins: {
      legend: {
        position: 'top',
        labels: {
          color: 'var(--text-color)', // Use CSS variable for text color
        },
      },
      title: {
        display: false, // Title is handled by H3 tag in JSX
      },
      tooltip: {
        callbacks: {
          label: function(context) {
            let label = context.label || '';
            if (label) {
              label += ': ';
            }
            if (context.parsed !== null) {
              label += context.raw; // For pie and bar, raw gives the direct value
            }
            return label;
          }
        }
      }
    },
    scales: {
      x: {
        ticks: {
          color: 'var(--text-color)', // Use CSS variable for tick labels
        },
        grid: {
          color: 'rgba(128, 128, 128, 0.2)', // Lighter grid lines
        }
      },
      y: {
        ticks: {
          color: 'var(--text-color)',
        },
        grid: {
          color: 'rgba(128, 128, 128, 0.2)',
        }
      }
    }
  };


  return (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/stats`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">AI PREDICTION</Link>
      </div>

      <div className="p-6 max-w-4xl mx-auto w-full">
        {/* CSS Variable Definition (consider moving to global CSS for better maintainability) */}
        <style>{`
          /* Define CSS variable for text color based on dark mode */
          html.dark {
            --text-color: #f3f4f6; /* light gray for dark mode */
          }
          html:not(.dark) {
            --text-color: #1f2937; /* dark gray for light mode */
          }
        `}</style>
        <h2 className="text-2xl font-bold mb-4 text-center">üìä Tournament Statistics ({tournamentName})</h2>

        {/* Average Goals per Match Stat Card */}
        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md text-center mb-6 border border-gray-200 dark:border-gray-700">
          <h4 className="text-xl font-semibold mb-2 text-gray-700 dark:text-gray-300">‚öΩ Avg. Goals per Match</h4>
          <p className="text-4xl mt-1 font-extrabold text-blue-600 dark:text-blue-400">{avgGoals}</p>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          {/* Goals by Team Bar Chart */}
          <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border border-gray-200 dark:border-gray-700 h-[400px]">
            <h3 className="text-lg font-semibold mb-3 text-gray-700 dark:text-gray-300">Goals by Team</h3>
            <Bar data={barData} options={chartOptions} />
          </div>

          {/* Goals Distribution Pie Chart */}
          <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border border-gray-200 dark:border-gray-700 h-[400px]">
            <h3 className="text-lg font-semibold mb-3 text-gray-700 dark:text-gray-300">Goals Distribution</h3>
            <Pie data={pieData} options={chartOptions} />
          </div>
        </div>
      </div>
    </div>
  );
}


--- END FILE: src\pages\StatsPage.jsx ---

--- START FILE: src\pages\TournamentPage.jsx ---

import React, { useEffect, useState, useCallback, useRef } from 'react';
import { db } from '../firebase';
import {
  collection,
  addDoc,
  onSnapshot,
  doc,
  deleteDoc,
  updateDoc,
  query,
  orderBy,
  getDoc,
  writeBatch,
  getDocs,
  setDoc // Added setDoc for potential future use or consistency
} from 'firebase/firestore';
import { Link, useNavigate, useParams, useSearchParams } from 'react-router-dom'; // Added useSearchParams
import { useAuth } from '../hooks/useAuth';
import Modal from '../components/Modal';
import ScoreInputModalContent from '../components/ScoreInputModalContent';

export default function TournamentPage() {
  const { id: tournamentId } = useParams();
  const [searchParams] = useSearchParams(); // Hook to read URL query parameters
  const shareId = searchParams.get('shareId'); // Get the shareId from the URL
  const { user, loading: authLoading } = useAuth();
  const navigate = useNavigate();

  // State to determine if the page is in view-only mode
  // This will be true if shareId is present, or if user is null AND the tournament is public.
  const [isViewOnly, setIsViewOnly] = useState(false);
  // State to hold the actual owner ID for permission checks
  const [tournamentOwnerId, setTournamentOwnerId] = useState(null);

  // Tournament Details State
  const [tournamentName, setTournamentName] = useState('Loading...');
  const [tournamentDetails, setTournamentDetails] = useState(null);
  const [loadingTournamentData, setLoadingTournamentData] = useState(true);
  const [generalError, setGeneralError] = useState(null);

  // Team Management State
  const [teams, setTeams] = useState([]);
  const [newTeamName, setNewTeamName] = useState('');
  const [teamError, setTeamError] = useState('');

  // Fixture Management State
  const [fixtures, setFixtures] = useState([]);
  const [newFixture, setNewFixture] = useState({ teamA: '', teamB: '', date: '', timestamp: null, status: 'scheduled', scoreA: 0, scoreB: 0 });
  const [fixtureError, setFixtureError] = useState('');

  // Modal State (for the shared Modal component)
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalTitle, setModalTitle] = useState('');
  const [modalMessage, setModalMessage] = useState('');
  const [modalContent, setModalContent] = useState(null);
  const [modalConfirmAction, setModalConfirmAction] = useState(null);
  const [modalShowConfirmButton, setModalShowConfirmButton] = useState(true);

  // REF to access the ScoreInputModalContent component's methods (like getScoreA/B)
  const scoreInputRef = useRef(null);
  // State to hold the specific fixture being updated when the modal is open
  const [currentFixtureToUpdate, setCurrentFixtureToUpdate] = useState(null);

  // Tournament Configuration State
  const [enableColors, setEnableColors] = useState(false);
  const [promotionSpots, setPromotionSpots] = useState('');
  const [europeLeagueSpots, setEuropeLeagueSpots] = useState('');
  const [relegationSpots, setRelegationSpots] = useState('');
  const [fixtureOption, setFixtureOption] = useState('Single Matches');
  const [pointsPerWin, setPointsPerWin] = useState(3);
  const [pointsPerDraw, setPointsPerDraw] = useState(1);
  const [shareableLink, setShareableLink] = useState(''); // New state for the share link

  // Helper function to open the custom modal (uses the shared Modal component)
  const openCustomModal = useCallback((title, message, confirmAction = null, showConfirm = true, content = null) => {
    setModalTitle(title);
    setModalMessage(message);
    setModalConfirmAction(() => confirmAction);
    setModalShowConfirmButton(showConfirm);
    setModalContent(content);
    setIsModalOpen(true);
  }, []);

  const closeCustomModal = useCallback(() => {
    setIsModalOpen(false);
    setModalTitle('');
    setModalMessage('');
    setModalContent(null);
    setModalConfirmAction(null);
    setModalShowConfirmButton(true);
  }, []);

  // --- Effect to fetch Tournament Details ---
  useEffect(() => {
    // If auth is still loading, wait.
    if (authLoading) {
      setLoadingTournamentData(true);
      return;
    }

    if (!tournamentId) {
      setGeneralError("No tournament ID provided in the URL.");
      setLoadingTournamentData(false);
      return;
    }

    setLoadingTournamentData(true);
    setGeneralError(null);

    const fetchTournamentDetails = async () => {
      try {
        const tournamentDocRef = doc(db, 'tournaments', tournamentId);
        const tournamentSnap = await getDoc(tournamentDocRef);

        if (tournamentSnap.exists()) {
          const data = tournamentSnap.data();
          const ownerId = data.userId;
          const isPublicTournament = data.isPublic || false; // Check for isPublic flag

          setTournamentOwnerId(ownerId); // Store owner ID for later checks

          // Determine if it's view-only mode
          // It's view-only if a shareId is present, OR if the user is NOT logged in AND the tournament is public.
          const currentIsViewOnly = (!!shareId) || (!user && isPublicTournament);
          setIsViewOnly(currentIsViewOnly);


          // Permission Check:
          // If a user is logged in, they must be the owner to get full access.
          // If NO user is logged in, but a shareId is present AND the tournament is public, allow read-only.
          if (user && user.uid && ownerId === user.uid) {
            // Full access for the owner
            setTournamentName(data.name);
            setTournamentDetails(data);
            setEnableColors(data.enableColors || false);
            setPromotionSpots(data.promotionSpots !== undefined ? String(data.promotionSpots) : '');
            setEuropeLeagueSpots(data.europeLeagueSpots !== undefined ? String(data.europeLeagueSpots) : '');
            setRelegationSpots(data.relegationSpots !== undefined ? String(data.relegationSpots) : '');
            setFixtureOption(data.fixtureOption || 'Single Matches');
            setPointsPerWin(data.pointsPerWin !== undefined ? data.pointsPerWin : 3);
            setPointsPerDraw(data.pointsPerDraw !== undefined ? data.pointsPerDraw : 1);
            setShareableLink(`${window.location.origin}/tournament/${tournamentId}?shareId=${tournamentId}`); // Re-generate for owner to copy
          } else if (currentIsViewOnly) {
            // Read-only access for public viewers (via share link or unauthenticated to public tourney)
            setTournamentName(data.name);
            setTournamentDetails(data);
            setEnableColors(data.enableColors || false);
            setPromotionSpots(data.promotionSpots !== undefined ? String(data.promotionSpots) : '');
            setEuropeLeagueSpots(data.europeLeagueSpots !== undefined ? String(data.europeLeagueSpots) : '');
            setRelegationSpots(data.relegationSpots !== undefined ? String(data.relegationSpots) : '');
            setFixtureOption(data.fixtureOption || 'Single Matches');
            setPointsPerWin(data.pointsPerWin !== undefined ? data.pointsPerWin : 3);
            setPointsPerDraw(data.pointsPerDraw !== undefined ? data.pointsPerDraw : 1);
            setShareableLink(''); // No share link to show for viewers
            // No error, as this is expected behavior for view-only.
          } else {
            // User is logged in but not the owner, OR user is not logged in and tournament is not public.
            setTournamentName('Access Denied');
            setGeneralError('You do not have permission to access this tournament. Please log in with the correct account or use a valid share link.');
          }
        } else {
          setTournamentName('Tournament Not Found');
          setGeneralError('The requested tournament does not exist.');
        }
        setLoadingTournamentData(false);
      } catch (err) {
        console.error('Error fetching tournament details:', err);
        setTournamentName('Error');
        setGeneralError('Failed to load tournament details. Please try again.');
        setLoadingTournamentData(false);
      }
    };
    fetchTournamentDetails();
  }, [tournamentId, user, authLoading, shareId]); // Added shareId to dependencies

  // --- Effect to listen to Teams and Fixtures ---
  // These effects now listen regardless of `user` status, but the security rules will filter access.
  useEffect(() => {
    if (loadingTournamentData || generalError) {
      setTeams([]); // Clear teams if still loading or error
      return;
    }

    // Teams subscription
    const teamsCollectionRef = collection(db, `tournaments/${tournamentId}/teams`);
    const unsubscribeTeams = onSnapshot(query(teamsCollectionRef, orderBy('name', 'asc')), (snapshot) => {
      setTeams(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
    }, (err) => {
      console.error('Error fetching real-time teams:', err);
      // For view-only, just log the error, don't necessarily show it to the user.
      // For owner, you might want to show it.
      if (!isViewOnly) {
        setTeamError('Failed to load teams.');
      }
    });

    // Fixtures subscription
    const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);
    const unsubscribeFixtures = onSnapshot(query(fixturesCollectionRef, orderBy('timestamp', 'asc')), (snapshot) => {
      setFixtures(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
    }, (err) => {
      console.error('Error fetching real-time fixtures:', err);
      if (!isViewOnly) {
        setFixtureError('Failed to load fixtures.');
      }
    });

    return () => {
      unsubscribeTeams();
      unsubscribeFixtures();
    };
  }, [tournamentId, loadingTournamentData, generalError, isViewOnly]); // Added isViewOnly to dependencies

  // --- Leaderboard Update Logic ---
  // This should ideally only be called by the owner or a backend function.
  // However, for simplicity, we'll keep it client-side but guard against view-only calls.
  const updateLeaderboard = useCallback(async () => {
    if (isViewOnly || !tournamentId || !tournamentDetails) {
      console.log('Skipping leaderboard update: View-only mode or tournament data missing.');
      return;
    }
    // Ensure the current user is the owner before attempting to write to the leaderboard
    if (user?.uid !== tournamentOwnerId) {
      console.warn('Attempted leaderboard update by non-owner in non-view-only mode. Aborting.');
      return;
    }

    const leaderboardRef = collection(db, `tournaments/${tournamentId}/leaderboard`);
    const teamsRef = collection(db, `tournaments/${tournamentId}/teams`);
    const fixturesRef = collection(db, `tournaments/${tournamentId}/fixtures`);

    try {
      const teamsSnapshot = await getDocs(teamsRef);
      const fixturesSnapshot = await getDocs(query(fixturesRef));

      const teamStats = {};
      teamsSnapshot.docs.forEach(teamDoc => {
        const teamName = teamDoc.data().name;
        teamStats[teamName] = {
          id: teamDoc.id,
          name: teamName,
          played: 0,
          wins: 0,
          draws: 0,
          losses: 0,
          goalsFor: 0,
          goalsAgainst: 0,
          goalDifference: 0,
          points: 0,
        };
      });

      fixturesSnapshot.docs.forEach(fixtureDoc => {
        const fixture = fixtureDoc.data();
        if (fixture.status === 'completed') {
          const teamA = fixture.teamA;
          const teamB = fixture.teamB;
          const scoreA = Number(fixture.scoreA) || 0;
          const scoreB = Number(fixture.scoreB) || 0;

          if (teamStats[teamA]) {
            teamStats[teamA].played++;
            teamStats[teamA].goalsFor += scoreA;
            teamStats[teamA].goalsAgainst += scoreB;
          }
          if (teamStats[teamB]) {
            teamStats[teamB].played++;
            teamStats[teamB].goalsFor += scoreB;
            teamStats[teamB].goalsAgainst += scoreA;
          }

          if (scoreA > scoreB) {
            if (teamStats[teamA]) teamStats[teamA].wins++;
            if (teamStats[teamB]) teamStats[teamB].losses++;
          } else if (scoreB > scoreA) {
            if (teamStats[teamB]) teamStats[teamB].wins++;
            if (teamStats[teamA]) teamStats[teamA].losses++;
          } else { // Draw
            if (teamStats[teamA]) teamStats[teamA].draws++;
            if (teamStats[teamB]) teamStats[teamB].draws++;
          }
        }
      });

      const currentPointsPerWin = tournamentDetails?.pointsPerWin || 3;
      const currentPointsPerDraw = tournamentDetails?.pointsPerDraw || 1;

      const batch = writeBatch(db);
      for (const teamName in teamStats) {
        const stats = teamStats[teamName];
        stats.goalDifference = stats.goalsFor - stats.goalsAgainst;
        stats.points = (stats.wins * currentPointsPerWin) + (stats.draws * currentPointsPerDraw);

        const teamLeaderboardDocRef = doc(leaderboardRef, stats.id);
        batch.set(teamLeaderboardDocRef, stats, { merge: true });
      }

      await batch.commit();
      console.log('Leaderboard updated successfully!');
    } catch (err) {
      console.error('Error updating leaderboard:', err);
    }
  }, [tournamentId, tournamentDetails, isViewOnly, user, tournamentOwnerId]); // Added user, tournamentOwnerId to dependencies

  // Effect to trigger leaderboard update when fixtures or tournamentDetails change
  useEffect(() => {
    // Only update leaderboard if not in view-only mode and is the owner
    if (!isViewOnly && user?.uid === tournamentOwnerId) {
      if (fixtures.length > 0 || (fixtures.length === 0 && !loadingTournamentData)) {
        updateLeaderboard();
      }
    }
  }, [fixtures, tournamentDetails, authLoading, user, updateLeaderboard, loadingTournamentData, isViewOnly, tournamentOwnerId]);

  // --- Team Management Handlers ---
  const handleAddTeam = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to add teams in view-only mode.', null, false);
      return;
    }
    setTeamError('');
    if (!newTeamName.trim()) {
      setTeamError('Team name cannot be empty.');
      return;
    }
    if (teams.some(team => team.name.toLowerCase() === newTeamName.trim().toLowerCase())) {
      setTeamError('A team with this name already exists.');
      return;
    }
    try {
      await addDoc(collection(db, `tournaments/${tournamentId}/teams`), { name: newTeamName });
      setNewTeamName('');
    } catch (err) {
      console.error('Error adding team:', err);
      setTeamError('Failed to add team. Make sure the tournament ID is valid and you have permission.');
    }
  };

  const handleDeleteTeam = async (teamId) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to delete teams in view-only mode.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Delete',
      'Are you sure you want to delete this team? This action cannot be undone.',
      async () => {
        try {
          await deleteDoc(doc(db, `tournaments/${tournamentId}/teams`, teamId));
          closeCustomModal();
          updateLeaderboard();
        } catch (err) {
          console.error('Error deleting team:', err);
          openCustomModal('Error', 'Failed to delete team. Please try again.');
        }
      }
    );
  };

  const handleClearAllTeams = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to clear all teams in view-only mode.', null, false);
      return;
    }
    if (teams.length === 0) {
      openCustomModal('Info', 'No teams to clear.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Clear All Teams',
      'Are you sure you want to delete ALL teams? This will also affect past match records.',
      async () => {
        const batch = writeBatch(db);
        teams.forEach(team => {
          const teamRef = doc(db, `tournaments/${tournamentId}/teams`, team.id);
          batch.delete(teamRef);
        });
        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', 'All teams cleared successfully.', null, false);
          updateLeaderboard();
        } catch (err) {
          console.error('Error clearing teams:', err);
          openCustomModal('Error', 'Failed to clear all teams. Please try again.');
        }
      }
    );
  };

  // --- Tournament Settings Handlers ---
  const handleSaveTournamentSettings = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to save settings in view-only mode.', null, false);
      return;
    }
    try {
      const tournamentRef = doc(db, 'tournaments', tournamentId);
      await updateDoc(tournamentRef, {
        enableColors: enableColors,
        promotionSpots: parseInt(promotionSpots) || 0,
        europeLeagueSpots: parseInt(europeLeagueSpots) || 0,
        relegationSpots: parseInt(relegationSpots) || 0,
        fixtureOption: fixtureOption,
        pointsPerWin: parseInt(pointsPerWin) || 3,
        pointsPerDraw: parseInt(pointsPerDraw) || 1,
      });
      openCustomModal('Success', 'Tournament settings saved successfully!', null, false);
      setTournamentDetails(prev => ({
        ...prev,
        enableColors: enableColors,
        promotionSpots: parseInt(promotionSpots) || 0,
        europeLeagueSpots: parseInt(europeLeagueSpots) || 0,
        relegationSpots: parseInt(relegationSpots) || 0,
        fixtureOption: fixtureOption,
        pointsPerWin: parseInt(pointsPerWin) || 3,
        pointsPerDraw: parseInt(pointsPerDraw) || 1,
      }));
    } catch (err) {
      console.error('Error saving tournament configuration:', err);
      openCustomModal('Error', 'Failed to save tournament configuration. Please try again.');
    }
  };

  // New handler to toggle tournament public status and generate link
  const handleTogglePublicStatus = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to change public status.', null, false);
      return;
    }

    const currentPublicStatus = tournamentDetails?.isPublic || false;
    const newPublicStatus = !currentPublicStatus;

    openCustomModal(
      'Confirm Public Status Change',
      `Are you sure you want to ${newPublicStatus ? 'make this tournament PUBLIC' : 'make this tournament PRIVATE'}?`,
      async () => {
        try {
          const tournamentRef = doc(db, 'tournaments', tournamentId);
          await updateDoc(tournamentRef, { isPublic: newPublicStatus });
          setTournamentDetails(prev => ({ ...prev, isPublic: newPublicStatus }));

          if (newPublicStatus) {
            const link = `${window.location.origin}/tournament/${tournamentId}?shareId=${tournamentId}`;
            setShareableLink(link);
            openCustomModal('Success', `Tournament is now public! Share this link: ${link}`, null, false);
          } else {
            setShareableLink('');
            openCustomModal('Success', 'Tournament is now private.', null, false);
          }
          closeCustomModal();
        } catch (err) {
          console.error('Error updating public status:', err);
          openCustomModal('Error', 'Failed to update public status. Please try again.');
        }
      }
    );
  };

  // Helper to copy share link to clipboard
  const copyShareLink = useCallback(() => {
    if (shareableLink) {
      navigator.clipboard.writeText(shareableLink)
        .then(() => openCustomModal('Link Copied!', 'The shareable link has been copied to your clipboard.', null, false))
        .catch(err => openCustomModal('Error', 'Failed to copy link. Please copy it manually.', null, false));
    }
  }, [shareableLink, openCustomModal]);


  // New helper function to shuffle an array
  const shuffleArray = useCallback((array) => {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex], array[currentIndex]];
    }
    return array;
  }, []);

  // Modified generateRoundRobinFixtures function
  const generateRoundRobinFixtures = useCallback((teamNames, isHomeAndAway) => {
    const numTeams = teamNames.length;
    if (numTeams < 2) return [];

    let teamsForScheduling = [...teamNames];
    if (numTeams % 2 !== 0) {
      teamsForScheduling.push('BYE');
    }

    const n = teamsForScheduling.length;
    const roundsNeeded = n - 1;

    let allLogicalRounds = [];

    for (let roundNum = 0; roundNum < roundsNeeded; roundNum++) {
      let currentRoundFixtures = [];
      const fixedTeam = teamsForScheduling[0];

      const rotatingTeamOppositeFixed = teamsForScheduling[(roundNum + (n - 1)) % (n - 1) + 1] || teamsForScheduling[n - 1]; // Corrected indexing for robustness
      if (fixedTeam !== 'BYE' && rotatingTeamOppositeFixed !== 'BYE') {
        if (roundNum % 2 === 0) {
          currentRoundFixtures.push({ teamA: fixedTeam, teamB: rotatingTeamOppositeFixed });
        } else {
          currentRoundFixtures.push({ teamA: rotatingTeamOppositeFixed, teamB: fixedTeam });
        }
      }

      for (let i = 1; i < n / 2; i++) {
        const team1 = teamsForScheduling[(roundNum + i) % (n - 1) + 1];
        const team2 = teamsForScheduling[(roundNum + n - 1 - i) % (n - 1) + 1];

        if (team1 !== 'BYE' && team2 !== 'BYE') {
          if (i % 2 === 0) {
            currentRoundFixtures.push({ teamA: team1, teamB: team2 });
          } else {
            currentRoundFixtures.push({ teamA: team2, teamB: team1 });
          }
        }
      }
      shuffleArray(currentRoundFixtures);
      allLogicalRounds.push(currentRoundFixtures);
    }

    let finalFixturesForDb = [];

    if (isHomeAndAway) {
      let returnRounds = [];
      allLogicalRounds.forEach(round => {
        let returnRound = [];
        round.forEach(fixture => {
          returnRound.push({ teamA: fixture.teamB, teamB: fixture.teamA });
        });
        returnRounds.push(returnRound);
      });
      allLogicalRounds = [...allLogicalRounds, ...returnRounds];
    }

    allLogicalRounds.forEach((roundFixtures, index) => {
      const weekNumber = index + 1;
      roundFixtures.forEach(fixture => {
        finalFixturesForDb.push({
          ...fixture,
          weekNumber: weekNumber,
        });
      });
    });

    return finalFixturesForDb;
  }, [shuffleArray]);

  const handleGenerateFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to generate fixtures in view-only mode.', null, false);
      return;
    }
    if (teams.length < 2) {
      openCustomModal('Info', 'You need at least two teams to generate fixtures!', null, false);
      return;
    }
    if (!tournamentDetails) {
      openCustomModal('Error', 'Tournament details not loaded. Cannot generate fixtures.', null, false);
      return;
    }

    const currentFixtureOption = tournamentDetails.fixtureOption || 'Single Matches';
    const teamNames = teams.map(t => t.name);

    const generatedFixturesWithWeekNumbers = generateRoundRobinFixtures(teamNames, currentFixtureOption === 'Home and Away Matches');

    let currentDate = new Date();
    currentDate.setHours(12, 0, 0, 0);

    const finalFixturesToSave = [];
    const groupedByWeek = generatedFixturesWithWeekNumbers.reduce((acc, fixture) => {
      const weekNum = fixture.weekNumber;
      if (!acc[weekNum]) {
        acc[weekNum] = [];
      }
      acc[weekNum].push(fixture);
      return acc;
    }, {});

    const sortedWeekNumbers = Object.keys(groupedByWeek).sort((a, b) => parseInt(a) - parseInt(b));

    sortedWeekNumbers.forEach(weekNum => {
      const fixturesInThisWeek = groupedByWeek[weekNum];
      fixturesInThisWeek.forEach(fixture => {
        finalFixturesToSave.push({
          teamA: fixture.teamA,
          teamB: fixture.teamB,
          date: currentDate.toISOString().split('T')[0],
          timestamp: new Date(currentDate),
          status: 'scheduled',
          scoreA: 0,
          scoreB: 0,
          weekNumber: parseInt(weekNum),
        });
      });
      currentDate.setDate(currentDate.getDate() + 7);
    });

    if (finalFixturesToSave.length === 0) {
      openCustomModal('Info', 'No fixtures could be generated. Check your team list and fixture options.', null, false);
      return;
    }

    openCustomModal(
      'Confirm Fixture Generation',
      `This will delete ALL existing fixtures and generate ${finalFixturesToSave.length} new ones based on '${currentFixtureOption}'. Are you sure?`,
      async () => {
        const batch = writeBatch(db);
        const fixturesCollectionRef = collection(db, `tournaments/${tournamentId}/fixtures`);

        const existingFixturesSnapshot = await getDocs(fixturesCollectionRef);
        existingFixturesSnapshot.docs.forEach((doc) => {
          batch.delete(doc.ref);
        });

        finalFixturesToSave.forEach(fixture => {
          const newFixtureRef = doc(fixturesCollectionRef);
          batch.set(newFixtureRef, fixture);
        });

        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', `Successfully generated ${finalFixturesToSave.length} fixtures!`, null, false);
          updateLeaderboard();
        } catch (err) {
          console.error('Error generating fixtures:', err);
          openCustomModal('Error', 'Failed to generate fixtures. Please try again.');
        }
      }
    );
  };

  const handleAddFixture = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to add fixtures in view-only mode.', null, false);
      return;
    }
    setFixtureError('');
    if (!newFixture.teamA || !newFixture.teamB || !newFixture.date) {
      setFixtureError('Please select both teams and a date for the fixture.');
      return;
    }
    if (newFixture.teamA === newFixture.teamB) {
      setFixtureError('Teams cannot be the same.');
      return;
    }
    try {
      const fixtureDate = new Date(newFixture.date);
      if (isNaN(fixtureDate.getTime())) {
        setFixtureError('Invalid date format.');
        return;
      }
      fixtureDate.setHours(12, 0, 0, 0);

      await addDoc(collection(db, `tournaments/${tournamentId}/fixtures`), {
        ...newFixture,
        timestamp: fixtureDate,
        scoreA: 0,
        scoreB: 0,
        status: 'scheduled',
        weekNumber: 0,
      });
      setNewFixture({ teamA: '', teamB: '', date: '', timestamp: null, status: 'scheduled', scoreA: 0, scoreB: 0 });
    } catch (err) {
      console.error('Error adding fixture:', err);
      setFixtureError('Failed to add fixture.');
    }
  };

  const handleDeleteFixture = async (fixtureId) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to delete fixtures in view-only mode.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Delete',
      'Are you sure you want to delete this fixture? This action cannot be undone.',
      async () => {
        try {
          await deleteDoc(doc(db, `tournaments/${tournamentId}/fixtures`, fixtureId));
          closeCustomModal();
          updateLeaderboard();
        } catch (err) {
          console.error('Error deleting fixture:', err);
          openCustomModal('Error', 'Failed to delete fixture. Please try again.');
        }
      }
    );
  };

  const handleClearAllFixtures = async () => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to clear all fixtures in view-only mode.', null, false);
      return;
    }
    if (fixtures.length === 0) {
      openCustomModal('Info', 'No fixtures to clear.', null, false);
      return;
    }
    openCustomModal(
      'Confirm Clear All Fixtures',
      'Are you sure you want to delete ALL fixtures? This will reset match data for the leaderboard.',
      async () => {
        const batch = writeBatch(db);
        fixtures.forEach(fixture => {
          const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, fixture.id);
          batch.delete(fixtureRef);
        });
        try {
          await batch.commit();
          closeCustomModal();
          openCustomModal('Success', 'All fixtures cleared successfully.', null, false);
          updateLeaderboard();
        } catch (err) {
          console.error('Error clearing fixtures:', err);
          openCustomModal('Error', 'Failed to clear all fixtures. Please try again.');
        }
      }
    );
  };

  // UPDATED handleUpdateScores to use ScoreInputModalContent
  const handleUpdateScores = useCallback(async (fixtureId, currentScoreA, currentScoreB) => {
    if (isViewOnly || user?.uid !== tournamentOwnerId) {
      openCustomModal('Access Denied', 'You do not have permission to update scores in view-only mode.', null, false);
      return;
    }
    const fixtureToUpdate = fixtures.find(f => f.id === fixtureId);
    if (!fixtureToUpdate) {
      console.warn(`Fixture with ID ${fixtureId} not found.`);
      return;
    }

    setCurrentFixtureToUpdate(fixtureToUpdate);

    const confirmAction = async () => {
      if (!scoreInputRef.current) {
        console.error("scoreInputRef.current is null. ScoreInputModalContent might not be mounted or ref not attached.");
        openCustomModal('Error', 'Internal error: Cannot read scores. Please try again.', null, false);
        return;
      }

      const parsedScoreA = parseInt(scoreInputRef.current.getScoreA());
      const parsedScoreB = parseInt(scoreInputRef.current.getScoreB());

      if (isNaN(parsedScoreA) || isNaN(parsedScoreB)) {
        openCustomModal('Invalid Input', 'Please enter valid numbers for scores.', null, false, (
          <ScoreInputModalContent
            ref={scoreInputRef}
            fixture={fixtureToUpdate}
            initialScoreA={scoreInputRef.current.getScoreA()}
            initialScoreB={scoreInputRef.current.getScoreB()}
          />
        ));
        return;
      }

      try {
        const fixtureRef = doc(db, `tournaments/${tournamentId}/fixtures`, fixtureId);
        await updateDoc(fixtureRef, {
          scoreA: parsedScoreA,
          scoreB: parsedScoreB,
          status: 'completed'
        });
        closeCustomModal();
        updateLeaderboard();
      } catch (err) {
        console.error('Error updating scores:', err);
        openCustomModal('Error', 'Failed to update scores. Please try again.', null, false, (
          <ScoreInputModalContent
            ref={scoreInputRef}
            fixture={fixtureToUpdate}
            initialScoreA={scoreInputRef.current.getScoreA()}
            initialScoreB={scoreInputRef.current.getScoreB()}
          />
        ));
      }
    };

    openCustomModal(
      'Update Match Scores',
      `Enter scores for ${fixtureToUpdate.teamA} vs ${fixtureToUpdate.teamB}:`,
      confirmAction,
      true,
      <ScoreInputModalContent
        ref={scoreInputRef}
        fixture={fixtureToUpdate}
        initialScoreA={currentScoreA}
        initialScoreB={currentScoreB}
      />
    );
  }, [fixtures, tournamentId, openCustomModal, closeCustomModal, updateLeaderboard, isViewOnly, user, tournamentOwnerId]);

  // Common Loading/Error/No Access UI
  const renderLoadingOrError = () => (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar - Always render for consistent layout */}
      <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">AI PREDICTION</Link>
      </div>

      <div className="p-6 max-w-4xl mx-auto w-full">
        <h2 className="text-2xl font-bold mb-4 text-center">‚ú® {tournamentName} Details</h2>
        {generalError ? (
          <p className="text-red-500 text-center py-8">{generalError}</p>
        ) : (
          <p className="text-center text-gray-500 py-8">Loading tournament data...</p>
        )}
      </div>
    </div>
  );

  if (loadingTournamentData || authLoading || generalError) {
    return renderLoadingOrError();
  }

  // Determine if the current user is the owner
  const isOwner = user && user.uid === tournamentOwnerId;

  // Render content based on view-only mode
  console.log('TournamentPage rendering. isViewOnly:', isViewOnly, 'isOwner:', isOwner);

  return (
    <div className="flex flex-col min-h-screen bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
      {/* Top Navigation Bar */}
      <div className="bg-red-600 text-white p-4 flex justify-around font-bold text-lg">
        {/* Pass shareId to sub-routes if it exists */}
        <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">LEAGUE</Link>
        <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">FIXTURES</Link>
        <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">TOP SCORERS</Link>
        <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">STATS</Link>
        <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">KNOCKOUT</Link>
        <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex-1 text-center py-2 px-1 hover:bg-red-700 transition-colors">AI PREDICTION</Link>
      </div>

      <div className="p-6 max-w-6xl mx-auto w-full">
        <h2 className="text-3xl font-extrabold mb-6 text-center text-gray-900 dark:text-white">
          ‚ú® {tournamentName} {isViewOnly ? '(View Only)' : 'Administration'}
        </h2>

        {isViewOnly && (
          <div className="bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 p-4 rounded-lg mb-6 text-center shadow-md">
            <p className="font-semibold">You are currently in view-only mode for this tournament.</p>
            <p className="text-sm mt-1">Changes are not permitted.</p>
          </div>
        )}


        <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
          {/* Navigation Sidebar */}
          <div className="lg:col-span-1 bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 h-fit">
            <h3 className="text-2xl font-bold mb-5 text-gray-800 dark:text-white">Tournament Menu</h3>
            <ul className="space-y-3">
              <li>
                <Link to={`/tournament/${tournamentId}/leaderboard${shareId ? `?shareId=${shareId}` : ''}`} className="flex items-center px-4 py-3 rounded-md hover:bg-red-100 dark:hover:bg-gray-700 transition-colors text-lg font-medium text-red-700 dark:text-red-400">
                  <svg className="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                  </svg>
                  View Leaderboard
                </Link>
              </li>
              <li>
                <Link to={`/tournament/${tournamentId}/fixtures${shareId ? `?shareId=${shareId}` : ''}`} className="flex items-center px-4 py-3 rounded-md hover:bg-red-100 dark:hover:bg-gray-700 transition-colors text-lg font-medium text-red-700 dark:text-red-400">
                  <svg className="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                  </svg>
                  View Fixtures
                </Link>
              </li>
              <li>
                <Link to={`/tournament/${tournamentId}/players${shareId ? `?shareId=${shareId}` : ''}`} className="flex items-center px-4 py-3 rounded-md hover:bg-red-100 dark:hover:bg-gray-700 transition-colors text-lg font-medium text-red-700 dark:text-red-400">
                  <svg className="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                  </svg>
                  Player Management {/* This link should ideally point to a view-only player list */}
                </Link>
              </li>
              <li>
                <Link to={`/tournament/${tournamentId}/stats${shareId ? `?shareId=${shareId}` : ''}`} className="flex items-center px-4 py-3 rounded-md hover:bg-red-100 dark:hover:bg-gray-700 transition-colors text-lg font-medium text-red-700 dark:text-red-400">
                  <svg className="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 3.055A9.001 9.001 0 1020.945 13H11V3.055z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.488 9H15V3.512A9.025 9.025 0 0120.488 9z" />
                  </svg>
                  View Statistics
                </Link>
              </li>
              <li>
                <Link to={`/tournament/${tournamentId}/knockout${shareId ? `?shareId=${shareId}` : ''}`} className="flex items-center px-4 py-3 rounded-md hover:bg-red-100 dark:hover:bg-gray-700 transition-colors text-lg font-medium text-red-700 dark:text-red-400">
                  <svg className="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                  </svg>
                  Knockout Stage
                </Link>
              </li>
              <li>
                <Link to={`/tournament/${tournamentId}/ai-prediction${shareId ? `?shareId=${shareId}` : ''}`} className="flex items-center px-4 py-3 rounded-md hover:bg-red-100 dark:hover:bg-gray-700 transition-colors text-lg font-medium text-red-700 dark:text-red-400">
                  <svg className="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 17L9 20l-1 1h6l-1-1v-3m-6 0l-2-2m2 2l-2 2m7-2l2-2m-2 2l2 2M3 11a6 6 0 0112 0v2l-3 3-3-3v-2A6 6 0 013 11z" />
                  </svg>
                  AI Prediction
                </Link>
              </li>
            </ul>
          </div>

          {/* Main Content Area (Tournament Settings, Team Management, Fixture Management) */}
          <div className="lg:col-span-3 space-y-8">
            {/* Tournament Settings Section */}
            <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700">
              <h3 className="text-2xl font-bold mb-4 text-gray-800 dark:text-white">‚öôÔ∏è Tournament Settings</h3>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                {/* Points System */}
                <div className="flex flex-col gap-3">
                  <h4 className="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">Points System:</h4>
                  <div className="flex items-center justify-between">
                    <label className="text-gray-600 dark:text-gray-400">Points for a Win:</label>
                    <input
                      type="number"
                      value={pointsPerWin}
                      onChange={(e) => setPointsPerWin(parseInt(e.target.value) || 0)}
                      className="w-20 px-3 py-1 border rounded-md text-center dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      min="0"
                      disabled={isViewOnly || !isOwner} // Disable if view-only or not owner
                    />
                  </div>
                  <div className="flex items-center justify-between">
                    <label className="text-gray-600 dark:text-gray-400">Points for a Draw:</label>
                    <input
                      type="number"
                      value={pointsPerDraw}
                      onChange={(e) => setPointsPerDraw(parseInt(e.target.value) || 0)}
                      className="w-20 px-3 py-1 border rounded-md text-center dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      min="0"
                      disabled={isViewOnly || !isOwner} // Disable if view-only or not owner
                    />
                  </div>
                </div>

                {/* Promotion/Relegation Spots */}
                <div className="flex flex-col gap-3">
                  <h4 className="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">League Spots Configuration:</h4>
                  <div className="flex items-center justify-between">
                    <label className="font-semibold text-green-600 dark:text-green-400">Promotion Spots</label>
                    <input
                      type="number"
                      value={promotionSpots}
                      onChange={(e) => setPromotionSpots(e.target.value)}
                      className="w-20 px-3 py-1 border rounded-md text-center dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      placeholder="0"
                      min="0"
                      disabled={isViewOnly || !isOwner} // Disable if view-only or not owner
                    />
                  </div>
                  <div className="flex items-center justify-between">
                    <label className="font-semibold text-yellow-600 dark:text-yellow-400">Europe League Spots</label>
                    <input
                      type="number"
                      value={europeLeagueSpots}
                      onChange={(e) => setEuropeLeagueSpots(e.target.value)}
                      className="w-20 px-3 py-1 border rounded-md text-center dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      placeholder="0"
                      min="0"
                      disabled={isViewOnly || !isOwner} // Disable if view-only or not owner
                    />
                  </div>
                  <div className="flex items-center justify-between">
                    <label className="font-semibold text-red-600 dark:text-red-400">Relegation Spots</label>
                    <input
                      type="number"
                      value={relegationSpots}
                      onChange={(e) => setRelegationSpots(e.target.value)}
                      className="w-20 px-3 py-1 border rounded-md text-center dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      placeholder="0"
                      min="0"
                      disabled={isViewOnly || !isOwner} // Disable if view-only or not owner
                    />
                  </div>
                </div>
              </div>

              {/* Fixture Option & Colors */}
              <div className="flex flex-col gap-4 mb-6">
                <div className="flex items-center justify-between">
                  <label className="text-lg font-semibold text-gray-700 dark:text-gray-300">Fixture Type:</label>
                  <select
                    value={fixtureOption}
                    onChange={(e) => setFixtureOption(e.target.value)}
                    className="border p-2 rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    disabled={isViewOnly || !isOwner} // Disable if view-only or not owner
                  >
                    <option value="Single Matches">Single Matches (Each team plays once)</option>
                    <option value="Home and Away Matches">Home and Away (Each team plays twice)</option>
                  </select>
                </div>
                <div className="flex items-center justify-between">
                  <label className="text-lg font-semibold text-gray-700 dark:text-gray-300">Enable Leaderboard Colors:</label>
                  <input
                    type="checkbox"
                    checked={enableColors}
                    onChange={(e) => setEnableColors(e.target.checked)}
                    className="w-5 h-5 accent-red-600"
                    disabled={isViewOnly || !isOwner} // Disable if view-only or not owner
                  />
                </div>
              </div>

              {/* Share Link Section (Only for Owner) */}
              {isOwner && (
                <div className="border-t border-gray-200 dark:border-gray-700 pt-6 mt-6">
                  <h4 className="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-3">Share Tournament</h4>
                  <div className="flex items-center justify-between mb-4">
                    <label className="text-gray-600 dark:text-gray-400">Publicly Shareable:</label>
                    <input
                      type="checkbox"
                      checked={tournamentDetails?.isPublic || false}
                      onChange={handleTogglePublicStatus}
                      className="w-5 h-5 accent-green-600"
                    />
                  </div>
                  {tournamentDetails?.isPublic && shareableLink && (
                    <div className="flex flex-col gap-2">
                      <p className="text-sm text-gray-500 dark:text-gray-400">Copy this link to share your tournament:</p>
                      <div className="flex">
                        <input
                          type="text"
                          value={shareableLink}
                          readOnly
                          className="flex-grow px-3 py-2 border rounded-l-md text-sm bg-gray-100 dark:bg-gray-700 dark:text-white truncate"
                        />
                        <button
                          onClick={copyShareLink}
                          className="bg-purple-600 text-white px-4 py-2 rounded-r-md hover:bg-purple-700 transition-colors text-sm"
                        >
                          Copy
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              )}


              <button
                onClick={handleSaveTournamentSettings}
                className={`w-full text-white font-bold py-3 px-8 rounded-md shadow-lg transition-colors duration-200 uppercase tracking-wide transform hover:scale-105 mt-6
                  ${isViewOnly || !isOwner ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'}`}
                disabled={isViewOnly || !isOwner} // Disable button if view-only or not owner
              >
                Save Settings
              </button>
            </div>

            {/* Team Management Section */}
            <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700">
              <h3 className="text-2xl font-bold mb-4 text-gray-800 dark:text-white">‚öΩ Team Management ({teams.length} Teams)</h3>
              {(!isViewOnly && isOwner) && ( // Only show if not view-only AND owner
                <div className="flex flex-wrap gap-3 mb-4 items-center">
                  <input
                    type="text"
                    value={newTeamName}
                    onChange={(e) => setNewTeamName(e.target.value)}
                    placeholder="Enter a new team name"
                    className="flex-grow px-4 py-2 border rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 max-w-sm"
                  />
                  <button
                    onClick={handleAddTeam}
                    className="bg-red-600 text-white font-bold py-2 px-6 rounded-md hover:bg-red-700 transition-colors duration-200 uppercase tracking-wide"
                  >
                    Add Team
                  </button>
                </div>
              )}
              {teamError && <p className="text-red-500 text-sm mb-4">{teamError}</p>}

              <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg border border-gray-300 dark:border-gray-600 h-64 overflow-y-auto custom-scrollbar">
                {teams.length === 0 ? (
                  <p className="text-gray-500 text-center py-8">No teams added yet. {(!isViewOnly && isOwner) && 'Add teams above!'}</p>
                ) : (
                  <ul className="space-y-2">
                    {teams.map(team => (
                      <li key={team.id} className="flex justify-between items-center bg-white dark:bg-gray-800 p-3 rounded-md shadow-sm border border-gray-200 dark:border-gray-600">
                        <span className="font-medium text-gray-800 dark:text-white text-lg">{team.name}</span>
                        {(!isViewOnly && isOwner) && ( // Only show delete button if not view-only AND owner
                          <button
                            onClick={() => handleDeleteTeam(team.id)}
                            className="text-red-500 hover:text-red-700 transition-colors p-1"
                            title="Delete Team"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                              <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm1 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1zm1 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" clipRule="evenodd" />
                            </svg>
                          </button>
                        )}
                      </li>
                    ))}
                  </ul>
                )}
              </div>

              {(!isViewOnly && isOwner) && ( // Only show these buttons if not view-only AND owner
                <div className="flex justify-between gap-4 mt-6">
                  <button
                    onClick={handleClearAllTeams}
                    className="bg-red-500 text-white font-bold py-2 px-6 rounded-md hover:bg-red-600 transition-colors duration-200 uppercase tracking-wide flex-grow"
                  >
                    Clear All Teams
                  </button>
                  <button
                    onClick={() => openCustomModal('Info', 'List saving and loading are automatic via real-time database. For bulk operations, consider dedicated import/export features.', null, false)}
                    className="bg-gray-600 text-white font-bold py-2 px-6 rounded-md hover:bg-gray-700 transition-colors duration-200 uppercase tracking-wide flex-grow"
                  >
                    Info on Lists
                  </button>
                </div>
              )}

              {(!isViewOnly && isOwner) && ( // Only show this button if not view-only AND owner
                <button
                  onClick={handleGenerateFixtures}
                  className="w-full bg-blue-600 text-white font-bold py-3 px-6 rounded-md shadow-lg hover:bg-blue-700 transition-colors duration-200 uppercase tracking-wide transform hover:scale-105 mt-8"
                >
                  Generate Fixtures
                </button>
              )}
            </div>

            {/* Fixture Management Section */}
            <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700">
              <h3 className="text-2xl font-bold mb-4 text-gray-800 dark:text-white">üìÖ Fixture Management ({fixtures.length} Fixtures)</h3>
              {(!isViewOnly && isOwner) && ( // Only show if not view-only AND owner
                <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-4">
                  <select
                    value={newFixture.teamA}
                    onChange={(e) => setNewFixture({ ...newFixture, teamA: e.target.value })}
                    className="border p-3 rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="">Select Home Team</option>
                    {teams.map(team => (
                      <option key={team.id} value={team.name}>{team.name}</option>
                    ))}
                  </select>
                  <select
                    value={newFixture.teamB}
                    onChange={(e) => setNewFixture({ ...newFixture, teamB: e.target.value })}
                    className="border p-3 rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="">Select Away Team</option>
                    {teams.map(team => (
                      <option key={team.id} value={team.name}>{team.name}</option>
                    ))}
                  </select>
                  <input
                    type="date"
                    value={newFixture.date}
                    onChange={(e) => setNewFixture({ ...newFixture, date: e.target.value })}
                    className="border p-3 rounded-md dark:bg-gray-700 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
              )}
              {fixtureError && <p className="text-red-500 text-sm mb-4">{fixtureError}</p>}
              {(!isViewOnly && isOwner) && ( // Only show if not view-only AND owner
                <button
                  onClick={handleAddFixture}
                  className="bg-green-600 text-white px-6 py-2 rounded-md hover:bg-green-700 transition-colors font-bold uppercase tracking-wide"
                >
                  Add Custom Fixture
                </button>
              )}

              <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg border border-gray-300 dark:border-gray-600 h-96 overflow-y-auto custom-scrollbar mt-6">
                {fixtures.length === 0 ? (
                  <p className="text-gray-500 text-center py-8">No fixtures added yet. {(!isViewOnly && isOwner) && 'Generate or add above!'}</p>
                ) : (
                  <ul className="space-y-3">
                    {fixtures.map(fixture => (
                      <li key={fixture.id} className="flex flex-col sm:flex-row justify-between items-start sm:items-center bg-white dark:bg-gray-800 p-4 rounded-md shadow-sm border border-gray-200 dark:border-gray-600">
                        <div className="flex-1 min-w-0">
                          <p className="font-semibold text-gray-800 dark:text-white text-lg break-words">
                            {fixture.teamA} vs {fixture.teamB}
                          </p>
                          {fixture.timestamp && fixture.timestamp.seconds ? (
                            <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                              Date: {new Date(fixture.timestamp.seconds * 1000).toLocaleDateString()}
                            </p>
                          ) : (
                            <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">Date: {fixture.date}</p>
                          )}
                          {/* Display Week Number if available */}
                          {fixture.weekNumber && fixture.weekNumber > 0 && (
                            <p className="text-sm text-gray-600 dark:text-gray-300 font-medium mt-1">
                              Week: {fixture.weekNumber}
                            </p>
                          )}
                          {fixture.status === 'completed' ? (
                            <p className="text-sm text-green-700 dark:text-green-300 font-bold mt-1">
                              Final Score: {fixture.scoreA} - {fixture.scoreB}
                            </p>
                          ) : (
                            <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 mt-1">
                              Scheduled
                            </span>
                          )}
                        </div>
                        {(!isViewOnly && isOwner) && ( // Only show these buttons if not view-only AND owner
                          <div className="flex gap-2 mt-3 sm:mt-0 sm:ml-4 flex-shrink-0">
                            {fixture.status !== 'completed' && (
                              <button
                                onClick={() => handleUpdateScores(fixture.id, fixture.scoreA, fixture.scoreB)}
                                className="bg-yellow-500 text-white px-4 py-2 rounded-md text-sm hover:bg-yellow-600 transition-colors font-semibold"
                              >
                                Update Scores
                              </button>
                            )}
                            <button
                              onClick={() => handleDeleteFixture(fixture.id)}
                              className="bg-red-500 text-white px-4 py-2 rounded-md text-sm hover:bg-red-600 transition-colors font-semibold"
                            >
                              Delete
                            </button>
                          </div>
                        )}
                      </li>
                    ))}
                  </ul>
                )}
              </div>
              {(!isViewOnly && isOwner) && ( // Only show this button if not view-only AND owner
                <button
                  onClick={handleClearAllFixtures}
                  className="bg-red-500 text-white font-bold py-2 px-6 rounded-md hover:bg-red-600 transition-colors duration-200 uppercase tracking-wide mt-6 w-full"
                >
                  Clear All Fixtures
                </button>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Reusable Modal Component (from ../components/Modal.jsx) */}
      <Modal
        isOpen={isModalOpen}
        onClose={closeCustomModal}
        onConfirm={modalConfirmAction}
        title={modalTitle}
        message={modalMessage}
        showConfirmButton={modalShowConfirmButton}
      >
        {/* Render custom content (e.g., score input fields) inside the modal */}
        {modalContent}
      </Modal>
    </div>
  );
}

--- END FILE: src\pages\TournamentPage.jsx ---

--- START FILE: src\utils\passwordStrength.js ---

// src/utils/passwordStrength.js

export const getPasswordStrength = (password) => {
    let strength = 0;

    // Check for length
    if (password.length >= 8) {
        strength++;
    }

    // Check for uppercase and lowercase characters
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) {
        strength++;
    }

    // Check for numbers
    if (/\d/.test(password)) {
        strength++;
    }

    // Check for special characters
    if (/[^a-zA-Z0-9]/.test(password)) {
        strength++;
    }

    // Cap strength at 4
    return Math.min(strength, 4);
};

export const getStrengthColor = (strength) => {
    switch (strength) {
        case 0:
            return 'text-gray-400'; // Too Short / No Input
        case 1:
            return 'text-red-500'; // Weak
        case 2:
            return 'text-orange-500'; // Moderate
        case 3:
            return 'text-yellow-500'; // Good
        case 4:
            return 'text-green-500'; // Strong
        default:
            return 'text-gray-400';
    }
};

--- END FILE: src\utils\passwordStrength.js ---
